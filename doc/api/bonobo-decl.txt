<MACRO>
<NAME>BONOBO_CANVAS_COMPONENT_TYPE</NAME>
#define BONOBO_CANVAS_COMPONENT_TYPE        (bonobo_canvas_component_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_CANVAS_COMPONENT</NAME>
#define BONOBO_CANVAS_COMPONENT(o)          (GTK_CHECK_CAST ((o), BONOBO_CANVAS_COMPONENT_TYPE, BonoboCanvasComponent))
</MACRO>
<MACRO>
<NAME>BONOBO_CANVAS_COMPONENT_CLASS</NAME>
#define BONOBO_CANVAS_COMPONENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_CANVAS_COMPONENT__TYPE, BonoboCanvasComponentClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CANVAS_COMPONENT</NAME>
#define BONOBO_IS_CANVAS_COMPONENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_CANVAS_COMPONENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CANVAS_COMPONENT_CLASS</NAME>
#define BONOBO_IS_CANVAS_COMPONENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_CANVAS_COMPONENT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboCanvasComponent</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboCanvasComponentPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboCanvasComponentClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboCanvasComponent</NAME>
struct BonoboCanvasComponent {
	BonoboObject base;
	BonoboCanvasComponentPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboCanvasComponentClass</NAME>
struct BonoboCanvasComponentClass {
	BonoboObjectClass parent_class;

	/*
	 * Signals
	 */
	 void (*set_bounds) (BonoboCanvasComponent *component, Bonobo_Canvas_DRect *bbox, CORBA_Environment *ev);
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_canvas_component_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_object_create</NAME>
<RETURNS>Bonobo_Canvas_Component  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_set_proxy</NAME>
<RETURNS>void  </RETURNS>
BonoboCanvasComponent *comp,Bonobo_Canvas_ComponentProxy proxy
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_construct</NAME>
<RETURNS>BonoboCanvasComponent  *</RETURNS>
BonoboCanvasComponent *comp,Bonobo_Canvas_Component    ccomp,GnomeCanvasItem     *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_new</NAME>
<RETURNS>BonoboCanvasComponent  *</RETURNS>
GnomeCanvasItem *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_get_item</NAME>
<RETURNS>GnomeCanvasItem       *</RETURNS>
BonoboCanvasComponent *comp
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_get_epv</NAME>
<RETURNS>POA_Bonobo_Canvas_Component__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_CANVAS_ITEM</NAME>
#define BONOBO_CANVAS_ITEM(obj)          (GTK_CHECK_CAST((obj), bonobo_canvas_item_get_type (), BonoboCanvasItem))
</MACRO>
<MACRO>
<NAME>BONOBO_CANVAS_ITEM_CLASS</NAME>
#define BONOBO_CANVAS_ITEM_CLASS(k)      (GTK_CHECK_CLASS_CAST ((k), gnome_bonobo_get_type (), BonoboCanvasItemClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CANVAS_ITEM</NAME>
#define BONOBO_IS_CANVAS_ITEM(o)         (GTK_CHECK_TYPE((o), gnome_bonobo_get_type ()))
</MACRO>
<STRUCT>
<NAME>BonoboCanvasItemPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboCanvasItem</NAME>
typedef struct {
	GnomeCanvasItem         canvas_item;
	BonoboEmbeddable        *embeddable;
	BonoboCanvasItemPrivate *priv;
} BonoboCanvasItem;
</STRUCT>
<STRUCT>
<NAME>BonoboCanvasItemClass</NAME>
typedef struct {
	GnomeCanvasItemClass parent_class;
} BonoboCanvasItemClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_canvas_item_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_item_new</NAME>
<RETURNS>GnomeCanvasItem  *</RETURNS>
GnomeCanvasGroup  *parent,BonoboObjectClient *embeddable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_item_set_bounds</NAME>
<RETURNS>void 	</RETURNS>
BonoboCanvasItem *item, double x1, double y1, double x2, double y2
</FUNCTION>
<MACRO>
<NAME>BONOBO_CLIENT_SITE_TYPE</NAME>
#define BONOBO_CLIENT_SITE_TYPE        (bonobo_client_site_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_CLIENT_SITE</NAME>
#define BONOBO_CLIENT_SITE(o)          (GTK_CHECK_CAST ((o), BONOBO_CLIENT_SITE_TYPE, BonoboClientSite))
</MACRO>
<MACRO>
<NAME>BONOBO_CLIENT_SITE_CLASS</NAME>
#define BONOBO_CLIENT_SITE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_CLIENT_SITE_TYPE, BonoboClientSiteClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CLIENT_SITE</NAME>
#define BONOBO_IS_CLIENT_SITE(o)       (GTK_CHECK_TYPE ((o), BONOBO_CLIENT_SITE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CLIENT_SITE_CLASS</NAME>
#define BONOBO_IS_CLIENT_SITE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_CLIENT_SITE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboClientSite</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboClientSitePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboClientSite</NAME>
struct BonoboClientSite {
	BonoboObject base;

	BonoboItemContainer *container;
	BonoboObjectClient  *bound_embeddable; /* IDL:Bonobo/Embeddable:1.0 */
	GList		    *view_frames;
	GList               *canvas_items;
	unsigned int         child_shown:1;

	BonoboClientSitePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboClientSiteClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	void (*show_window)  (BonoboClientSite *, CORBA_boolean shown);
	void (*queue_resize) (BonoboClientSite *);
	void (*save_object)  (BonoboClientSite *, Bonobo_Persist_Status *status);
} BonoboClientSiteClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_client_site_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_corba_object_create</NAME>
<RETURNS>Bonobo_ClientSite  </RETURNS>
BonoboObject        *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_new</NAME>
<RETURNS>BonoboClientSite            *</RETURNS>
BonoboItemContainer *container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_construct</NAME>
<RETURNS>BonoboClientSite            *</RETURNS>
BonoboClientSite    *client_site,Bonobo_ClientSite    corba_client_site,BonoboItemContainer *container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_bind_embeddable</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboClientSite    *client_site,BonoboObjectClient  *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_get_embeddable</NAME>
<RETURNS>BonoboObjectClient          *</RETURNS>
BonoboClientSite    *client_site
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_get_container</NAME>
<RETURNS>BonoboItemContainer         *</RETURNS>
BonoboClientSite    *client_site
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_new_view_full</NAME>
<RETURNS>BonoboViewFrame             *</RETURNS>
BonoboClientSite   *client_site,Bonobo_UIContainer  uih,gboolean            visible_cover,gboolean            active_view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_new_view</NAME>
<RETURNS>BonoboViewFrame             *</RETURNS>
BonoboClientSite   *client_site,Bonobo_UIContainer  uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_new_item</NAME>
<RETURNS>GnomeCanvasItem             *</RETURNS>
BonoboClientSite   *client_site,GnomeCanvasGroup   *group
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_get_verbs</NAME>
<RETURNS>GList                       *</RETURNS>
BonoboClientSite   *client_site
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_free_verbs</NAME>
<RETURNS>void  </RETURNS>
GList              *verb_list
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_get_epv</NAME>
<RETURNS>POA_Bonobo_ClientSite__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_load</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboStorage *storage,const char *interface,BonoboClientSite *client_site
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_save</NAME>
<RETURNS>int  </RETURNS>
BonoboEmbeddable *bonobo_object,BonoboStorage   *storage,gboolean       same_as_loaded
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_load_from_stream</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboStream *stream,const char *interface
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_save_to_stream</NAME>
<RETURNS>int  </RETURNS>
BonoboEmbeddable *bonobo_object,BonoboStream    *stream
</FUNCTION>
<FUNCTION>
<NAME>gnome_get_class_id_from_file</NAME>
<RETURNS>char               *</RETURNS>
const char *filename
</FUNCTION>
<MACRO>
<NAME>BONOBO_CONTROL_FRAME_TYPE</NAME>
#define BONOBO_CONTROL_FRAME_TYPE        (bonobo_control_frame_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_CONTROL_FRAME</NAME>
#define BONOBO_CONTROL_FRAME(o)          (GTK_CHECK_CAST ((o), BONOBO_CONTROL_FRAME_TYPE, BonoboControlFrame))
</MACRO>
<MACRO>
<NAME>BONOBO_CONTROL_FRAME_CLASS</NAME>
#define BONOBO_CONTROL_FRAME_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_CONTROL_FRAME_TYPE, BonoboControlFrameClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTROL_FRAME</NAME>
#define BONOBO_IS_CONTROL_FRAME(o)       (GTK_CHECK_TYPE ((o), BONOBO_CONTROL_FRAME_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTROL_FRAME_CLASS</NAME>
#define BONOBO_IS_CONTROL_FRAME_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_CONTROL_FRAME_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboControlFramePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboControlFrame</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboControlFrame</NAME>
struct BonoboControlFrame {
	BonoboObject base;
	BonoboControlFramePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboControlFrameClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * Signals.
	 */
	void (*activated)           (BonoboControlFrame *control_frame, gboolean state);
	void (*activate_uri)        (BonoboControlFrame *control_frame, const char *uri, gboolean relative);

} BonoboControlFrameClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_control_frame_new</NAME>
<RETURNS>BonoboControlFrame            *</RETURNS>
Bonobo_UIContainer   uic
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_widget</NAME>
<RETURNS>GtkWidget                     *</RETURNS>
BonoboControlFrame  *frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_set_ui_container</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,Bonobo_UIContainer   uic
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_control_activate</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_control_deactivate</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_set_autoactivate</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,gboolean             autoactivate
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_autoactivate</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_control_property_bag</NAME>
<RETURNS>Bonobo_PropertyBag  </RETURNS>
BonoboControlFrame  *control_frame,CORBA_Environment   *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_set_propbag</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,BonoboPropertyBag   *propbag
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_propbag</NAME>
<RETURNS>BonoboPropertyBag             *</RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_control_set_state</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,GtkStateType         state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_set_autostate</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,gboolean             autostate
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_autostate</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_bind_to_control</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,Bonobo_Control       control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_control</NAME>
<RETURNS>Bonobo_Control  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_ui_container</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_construct</NAME>
<RETURNS>BonoboControlFrame            *</RETURNS>
BonoboControlFrame  *control_frame,Bonobo_ControlFrame  corba_control_frame,Bonobo_UIContainer   uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_epv</NAME>
<RETURNS>POA_Bonobo_ControlFrame__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_size_request</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame *control_frame,int *desired_width,int *desired_height
</FUNCTION>
<MACRO>
<NAME>BONOBO_CONTROL_TYPE</NAME>
#define BONOBO_CONTROL_TYPE        (bonobo_control_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_CONTROL</NAME>
#define BONOBO_CONTROL(o)          (GTK_CHECK_CAST ((o), BONOBO_CONTROL_TYPE, BonoboControl))
</MACRO>
<MACRO>
<NAME>BONOBO_CONTROL_CLASS</NAME>
#define BONOBO_CONTROL_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_CONTROL_TYPE, BonoboControlClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTROL</NAME>
#define BONOBO_IS_CONTROL(o)       (GTK_CHECK_TYPE ((o), BONOBO_CONTROL_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTROL_CLASS</NAME>
#define BONOBO_IS_CONTROL_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_CONTROL_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboControl</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboControlPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboControlClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboControl</NAME>
struct BonoboControl {
	BonoboObject base;

	BonoboControlPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboControlClass</NAME>
struct BonoboControlClass {
	BonoboObjectClass parent_class;

	/*
	 * Signals.
	 */
	void (*set_frame)           (BonoboControl *control);
	void (*activate)            (BonoboControl *control, gboolean state);
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_control_new</NAME>
<RETURNS>BonoboControl               *</RETURNS>
GtkWidget     *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_widget</NAME>
<RETURNS>GtkWidget                   *</RETURNS>
BonoboControl *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_automerge</NAME>
<RETURNS>void  </RETURNS>
BonoboControl *control,gboolean       automerge
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_automerge</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboControl *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_property</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,const char          *first_prop,...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_property</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,const char          *first_prop,...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_construct</NAME>
<RETURNS>BonoboControl               *</RETURNS>
BonoboControl       *control,Bonobo_Control       corba_control,GtkWidget           *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_corba_object_create</NAME>
<RETURNS>Bonobo_Control  </RETURNS>
BonoboObject        *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_ui_component</NAME>
<RETURNS>BonoboUIComponent           *</RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_ui_component</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,BonoboUIComponent   *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_remote_ui_container</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_control_frame</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,Bonobo_ControlFrame  control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_control_frame</NAME>
<RETURNS>Bonobo_ControlFrame  </RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_properties</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,BonoboPropertyBag   *pb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_properties</NAME>
<RETURNS>BonoboPropertyBag           *</RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_ambient_properties</NAME>
<RETURNS>Bonobo_PropertyBag  </RETURNS>
BonoboControl       *control,CORBA_Environment   *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_activate_notify</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,gboolean             activated
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_windowid_from_x11</NAME>
<RETURNS>Bonobo_Control_windowId  </RETURNS>
guint32              x11_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_epv</NAME>
<RETURNS>POA_Bonobo_Control__epv     *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_sync_realize</NAME>
<RETURNS>void  </RETURNS>
Bonobo_Control       control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_sync_unrealize</NAME>
<RETURNS>void  </RETURNS>
Bonobo_Control       control
</FUNCTION>
<MACRO>
<NAME>BONOBO_DESKTOP_WINDOW_TYPE</NAME>
#define BONOBO_DESKTOP_WINDOW_TYPE        (bonobo_desktop_window_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_DESKTOP_WINDOW</NAME>
#define BONOBO_DESKTOP_WINDOW(o)          (GTK_CHECK_CAST ((o), BONOBO_DESKTOP_WINDOW_TYPE, BonoboDesktopWindow))
</MACRO>
<MACRO>
<NAME>BONOBO_DESKTOP_WINDOW_CLASS</NAME>
#define BONOBO_DESKTOP_WINDOW_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_DESKTOP_WINDOW_TYPE, BonoboDesktopWindowClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_DESKTOP_WINDOW</NAME>
#define BONOBO_IS_DESKTOP_WINDOW(o)       (GTK_CHECK_TYPE ((o), BONOBO_DESKTOP_WINDOW_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_DESKTOP_WINDOW_CLASS</NAME>
#define BONOBO_IS_DESKTOP_WINDOW_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_DESKTOP_WINDOW_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboDesktopWindow</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboDesktopWindowPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboDesktopWindowClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboDesktopWindow</NAME>
struct BonoboDesktopWindow {
	BonoboObject base;
	GtkWindow   *window;
	BonoboDesktopWindowPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboDesktopWindowClass</NAME>
struct BonoboDesktopWindowClass {
	BonoboObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_desktop_window_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_desktop_window_construct</NAME>
<RETURNS>BonoboDesktopWindow  *</RETURNS>
BonoboDesktopWindow *desktop_window,Bonobo_Desktop_Window corba_desktop_window,GtkWindow *toplevel
</FUNCTION>
<FUNCTION>
<NAME>bonobo_desktop_window_new</NAME>
<RETURNS>BonoboDesktopWindow  *</RETURNS>
GtkWindow *toplevel
</FUNCTION>
<FUNCTION>
<NAME>bonobo_desktop_window_control</NAME>
<RETURNS>void  </RETURNS>
BonoboObject *object,GtkWindow *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_desktop_window_corba_object_create</NAME>
<RETURNS>Bonobo_Desktop_Window  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_desktop_window_get_epv</NAME>
<RETURNS>POA_Bonobo_Desktop_Window__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_FACTORY_TYPE</NAME>
#define BONOBO_EMBEDDABLE_FACTORY_TYPE        BONOBO_GENERIC_FACTORY_TYPE
</MACRO>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_FACTORY</NAME>
#define BONOBO_EMBEDDABLE_FACTORY(o)          BONOBO_GENERIC_FACTORY(o)
</MACRO>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_FACTORY_CLASS</NAME>
#define BONOBO_EMBEDDABLE_FACTORY_CLASS(k)    BONOBO_GENERIC_FACTORY_CLASS(k)
</MACRO>
<MACRO>
<NAME>BONOBO_IS_EMBEDDABLE_FACTORY</NAME>
#define BONOBO_IS_EMBEDDABLE_FACTORY(o)       BONOBO_IS_GENERIC_FACTORY(o)
</MACRO>
<MACRO>
<NAME>BONOBO_IS_EMBEDDABLE_FACTORY_CLASS</NAME>
#define BONOBO_IS_EMBEDDABLE_FACTORY_CLASS(k) BONOBO_IS_GENERIC_FACTORY_CLASS(k)
</MACRO>
<TYPEDEF>
<NAME>BonoboEmbeddableFactory</NAME>
typedef BonoboGenericFactory BonoboEmbeddableFactory;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboEmbeddableFactoryClass</NAME>
typedef BonoboGenericFactoryClass BonoboEmbeddableFactoryClass;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboEmbeddableFactoryFn</NAME>
typedef BonoboGenericFactoryFn BonoboEmbeddableFactoryFn;
</TYPEDEF>
<MACRO>
<NAME>bonobo_embeddable_factory_get_type</NAME>
#define bonobo_embeddable_factory_get_type  bonobo_generic_factory_get_type
</MACRO>
<MACRO>
<NAME>bonobo_embeddable_factory_new</NAME>
#define bonobo_embeddable_factory_new       bonobo_generic_factory_new
</MACRO>
<MACRO>
<NAME>bonobo_embeddable_factory_construct</NAME>
#define bonobo_embeddable_factory_construct bonobo_generic_factory_construct
</MACRO>
<MACRO>
<NAME>bonobo_embeddable_factory_set</NAME>
#define bonobo_embeddable_factory_set       bonobo_generic_factory_set
</MACRO>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_TYPE</NAME>
#define BONOBO_EMBEDDABLE_TYPE        (bonobo_embeddable_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_EMBEDDABLE</NAME>
#define BONOBO_EMBEDDABLE(o)          (GTK_CHECK_CAST ((o), BONOBO_EMBEDDABLE_TYPE, BonoboEmbeddable))
</MACRO>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_CLASS</NAME>
#define BONOBO_EMBEDDABLE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_EMBEDDABLE_TYPE, BonoboEmbeddableClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_EMBEDDABLE</NAME>
#define BONOBO_IS_EMBEDDABLE(o)       (GTK_CHECK_TYPE ((o), BONOBO_EMBEDDABLE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_EMBEDDABLE_CLASS</NAME>
#define BONOBO_IS_EMBEDDABLE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_EMBEDDABLE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboEmbeddable</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboEmbeddablePrivate</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_VIEW_FACTORY</NAME>
#define BONOBO_VIEW_FACTORY(fn) ((BonoboViewFactory)(fn))
</MACRO>
<USER_FUNCTION>
<NAME>BonoboViewFactory</NAME>
<RETURNS>BonoboView *</RETURNS>
BonoboEmbeddable *embeddable, const Bonobo_ViewFrame view_frame, void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeItemCreator</NAME>
<RETURNS>BonoboCanvasComponent *</RETURNS>
BonoboEmbeddable *embeddable, GnomeCanvas *canvas, void *user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboEmbeddableForeachViewFn</NAME>
<RETURNS>void </RETURNS>
BonoboView *view, void *data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboEmbeddableForeachItemFn</NAME>
<RETURNS>void </RETURNS>
BonoboCanvasComponent *comp, void *data
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboEmbeddable</NAME>
struct BonoboEmbeddable {
	BonoboObject base;

	char *host_name;
	char *host_appname;
	Bonobo_ClientSite client_site;

	/*
	 * The URI this component represents
	 */
	char *uri;
	
	BonoboEmbeddablePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboEmbeddableClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * Signals
	 */
	void (*host_name_changed)  (BonoboEmbeddable *comp, const char *hostname);
	void (*uri_changed)        (BonoboEmbeddable *comp, const char *uri);
} BonoboEmbeddableClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_embeddable_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_new</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboViewFactory  factory,void              *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_new_canvas_item</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
GnomeItemCreator item_factory,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_construct</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboEmbeddable *embeddable,Bonobo_Embeddable corba_embeddable,BonoboViewFactory factory,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_construct_full</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboEmbeddable *embeddable,Bonobo_Embeddable corba_embeddable,BonoboViewFactory factory,void *factory_data,GnomeItemCreator item_factory,void *item_factory_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_corba_object_create</NAME>
<RETURNS>Bonobo_Embeddable  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_set_view_factory</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,BonoboViewFactory factory,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_get_uri</NAME>
<RETURNS>const char       *</RETURNS>
BonoboEmbeddable *embeddable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_set_uri</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,const char *uri
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_foreach_view</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,BonoboEmbeddableForeachViewFn fn,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_foreach_item</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,BonoboEmbeddableForeachItemFn fn,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_get_epv</NAME>
<RETURNS>POA_Bonobo_Embeddable__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_EX</NAME>
#define BONOBO_EX(ev)         ((ev) && (ev)->_major != CORBA_NO_EXCEPTION)
</MACRO>
<MACRO>
<NAME>BONOBO_USER_EX</NAME>
#define BONOBO_USER_EX(ev,id) ((ev) && (ev)->major == CORBA_USER_EXCEPTION &&	\
			       (ev)->_repo_id != NULL && !strcmp ((ev)->_repo_id, id))
</MACRO>
<MACRO>
<NAME>BONOBO_RET_EX</NAME>
#define BONOBO_RET_EX(ev)		\
	G_STMT_START			\
		if (BONOBO_EX (ev))	\
			return;		\
	G_STMT_END
</MACRO>
<MACRO>
<NAME>BONOBO_RET_VAL_EX</NAME>
#define BONOBO_RET_VAL_EX(ev,v)		\
	G_STMT_START			\
		if (BONOBO_EX (ev))	\
			return (v);	\
	G_STMT_END
</MACRO>
<USER_FUNCTION>
<NAME>BonoboExceptionFn</NAME>
<RETURNS>char *</RETURNS>
CORBA_Environment *ev, gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>bonobo_exception_get_text</NAME>
<RETURNS>char  *</RETURNS>
CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_exception_add_handler_str</NAME>
<RETURNS>void  </RETURNS>
const char *repo_id,const char *str
</FUNCTION>
<FUNCTION>
<NAME>bonobo_exception_add_handler_fn</NAME>
<RETURNS>void  </RETURNS>
const char *repo_id,BonoboExceptionFn fn,gpointer          user_data,GDestroyNotify    destroy_fn
</FUNCTION>
<MACRO>
<NAME>BONOBO_GENERIC_FACTORY_TYPE</NAME>
#define BONOBO_GENERIC_FACTORY_TYPE        (bonobo_generic_factory_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_GENERIC_FACTORY</NAME>
#define BONOBO_GENERIC_FACTORY(o)          (GTK_CHECK_CAST ((o), BONOBO_GENERIC_FACTORY_TYPE, BonoboGenericFactory))
</MACRO>
<MACRO>
<NAME>BONOBO_GENERIC_FACTORY_CLASS</NAME>
#define BONOBO_GENERIC_FACTORY_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_GENERIC_FACTORY_TYPE, BonoboGenericFactoryClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_GENERIC_FACTORY</NAME>
#define BONOBO_IS_GENERIC_FACTORY(o)       (GTK_CHECK_TYPE ((o), BONOBO_GENERIC_FACTORY_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_GENERIC_FACTORY_CLASS</NAME>
#define BONOBO_IS_GENERIC_FACTORY_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_GENERIC_FACTORY_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboGenericFactory</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboGenericFactoryPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboGenericFactoryFn</NAME>
<RETURNS>BonoboObject *</RETURNS>
BonoboGenericFactory *Factory, void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeFactoryCallback</NAME>
<RETURNS>BonoboObject *</RETURNS>
BonoboGenericFactory *factory, const char *goad_id, gpointer closure
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboGenericFactory</NAME>
struct BonoboGenericFactory {
	BonoboObject base;

	/*
	 * The function factory
	 */
	BonoboGenericFactoryFn factory; /* compat reasons only */
	GnomeFactoryCallback factory_cb;
	gpointer factory_closure;

	/*
	 * The goad_id for this generic factory
	 */
	char *goad_id;
};
</STRUCT>
<STRUCT>
<NAME>BonoboGenericFactoryClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * Virtual methods
	 */
	BonoboObject * (*new_generic)(BonoboGenericFactory *c_factory, const char *goad_id);
} BonoboGenericFactoryClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_generic_factory_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_new</NAME>
<RETURNS>BonoboGenericFactory  *</RETURNS>
const char *goad_id,BonoboGenericFactoryFn factory,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_new_multi</NAME>
<RETURNS>BonoboGenericFactory  *</RETURNS>
const char *goad_id,GnomeFactoryCallback factory_cb,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_construct</NAME>
<RETURNS>BonoboGenericFactory  *</RETURNS>
const char *goad_id,BonoboGenericFactory  *c_factory,CORBA_Object          corba_factory,BonoboGenericFactoryFn factory,GnomeFactoryCallback factory_cb,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_set</NAME>
<RETURNS>void  </RETURNS>
BonoboGenericFactory *c_factory,BonoboGenericFactoryFn factory,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_get_epv</NAME>
<RETURNS>POA_GNOME_ObjectFactory__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_ITEM_CONTAINER_TYPE</NAME>
#define BONOBO_ITEM_CONTAINER_TYPE        (bonobo_item_container_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_ITEM_CONTAINER</NAME>
#define BONOBO_ITEM_CONTAINER(o)          (GTK_CHECK_CAST ((o), BONOBO_ITEM_CONTAINER_TYPE, BonoboItemContainer))
</MACRO>
<MACRO>
<NAME>BONOBO_ITEM_CONTAINER_CLASS</NAME>
#define BONOBO_ITEM_CONTAINER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_ITEM_CONTAINER_TYPE, BonoboItemContainerClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_ITEM_CONTAINER</NAME>
#define BONOBO_IS_ITEM_CONTAINER(o)       (GTK_CHECK_TYPE ((o), BONOBO_ITEM_CONTAINER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_ITEM_CONTAINER_CLASS</NAME>
#define BONOBO_IS_ITEM_CONTAINER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_ITEM_CONTAINER_TYPE))
</MACRO>
<TYPEDEF>
<NAME>BonoboClientSiteList</NAME>
typedef GList BonoboClientSiteList;
</TYPEDEF>
<STRUCT>
<NAME>BonoboItemContainerPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboItemContainer</NAME>
typedef struct {
	BonoboObject base;

	BonoboClientSiteList *client_sites;
	
	BonoboMoniker *moniker;

	BonoboItemContainerPrivate *priv;
} BonoboItemContainer;
</STRUCT>
<STRUCT>
<NAME>BonoboItemContainerClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	Bonobo_Unknown (*get_object) (BonoboItemContainer *item_container,
				      CORBA_char          *item_name,
				      CORBA_boolean        only_if_exists,
				      CORBA_Environment   *ev);
} BonoboItemContainerClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_item_container_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_container_new</NAME>
<RETURNS>BonoboItemContainer  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_container_construct</NAME>
<RETURNS>BonoboItemContainer  *</RETURNS>
BonoboItemContainer *container,Bonobo_ItemContainer container_corba
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_container_get_moniker</NAME>
<RETURNS>BonoboMoniker        *</RETURNS>
BonoboItemContainer *container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_container_add</NAME>
<RETURNS>void  </RETURNS>
BonoboItemContainer *container,BonoboObject    *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_container_remove</NAME>
<RETURNS>void  </RETURNS>
BonoboItemContainer *container,BonoboObject    *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_container_get_epv</NAME>
<RETURNS>POA_Bonobo_ItemContainer__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_init</NAME>
<RETURNS>gboolean 	</RETURNS>
CORBA_ORB orb,PortableServer_POA poa,PortableServer_POAManager manager
</FUNCTION>
<FUNCTION>
<NAME>bonobo_main</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_activate</NAME>
<RETURNS>gboolean 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_setup_x_error_handler</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_orb</NAME>
<RETURNS>CORBA_ORB 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_poa</NAME>
<RETURNS>PortableServer_POA 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_poa_manager</NAME>
<RETURNS>PortableServer_POAManager  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_get_object</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
const CORBA_char  *name,const char        *interface_name,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_client_new_from_name</NAME>
<RETURNS>Bonobo_Moniker  </RETURNS>
const CORBA_char  *name,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_client_get_name</NAME>
<RETURNS>CORBA_char          *</RETURNS>
Bonobo_Moniker     moniker,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_client_resolve_default</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
Bonobo_Moniker     moniker,const char        *interface_name,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_client_resolve_client_default</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
Bonobo_Moniker     moniker,const char        *interface_name,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_util_new_from_name_full</NAME>
<RETURNS>Bonobo_Moniker  </RETURNS>
Bonobo_Moniker     parent,const CORBA_char  *name,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_util_get_parent_name</NAME>
<RETURNS>CORBA_char     *</RETURNS>
Bonobo_Moniker     moniker,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_util_qi_return</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
Bonobo_Unknown     object,const CORBA_char  *requested_interface,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_util_seek_std_separator</NAME>
<RETURNS>int  </RETURNS>
const CORBA_char  *str,int                min_idx
</FUNCTION>
<STRUCT>
<NAME>BonoboMonikerPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_MONIKER_TYPE</NAME>
#define BONOBO_MONIKER_TYPE        (bonobo_moniker_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_MONIKER</NAME>
#define BONOBO_MONIKER(o)          (GTK_CHECK_CAST ((o), BONOBO_MONIKER_TYPE, BonoboMoniker))
</MACRO>
<MACRO>
<NAME>BONOBO_MONIKER_CLASS</NAME>
#define BONOBO_MONIKER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_MONIKER_TYPE, BonoboMonikerClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_MONIKER</NAME>
#define BONOBO_IS_MONIKER(o)       (GTK_CHECK_TYPE ((o), BONOBO_MONIKER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_MONIKER_CLASS</NAME>
#define BONOBO_IS_MONIKER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_MONIKER_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboMoniker</NAME>
typedef struct {
        BonoboObject          object;
	
	BonoboMonikerPrivate *priv;
} BonoboMoniker;
</STRUCT>
<STRUCT>
<NAME>BonoboMonikerClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * virtual methods
	 */
	Bonobo_Moniker (*get_parent)         (BonoboMoniker               *moniker,
					      CORBA_Environment           *ev);
	void           (*set_parent)         (BonoboMoniker               *moniker,
					      const Bonobo_Moniker         parent,
					      CORBA_Environment           *ev);
	CORBA_char    *(*get_display_name)   (BonoboMoniker               *moniker,
					      CORBA_Environment           *ev);
	Bonobo_Moniker (*parse_display_name) (BonoboMoniker               *moniker,
					      Bonobo_Moniker               parent,
					      const CORBA_char            *name,
					      CORBA_Environment           *ev);
	Bonobo_Unknown (*resolve)            (BonoboMoniker               *moniker,
					      const Bonobo_ResolveOptions *options,
					      const CORBA_char            *requested_interface,
					      CORBA_Environment           *ev);
} BonoboMonikerClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_moniker_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_get_epv</NAME>
<RETURNS>POA_Bonobo_Moniker__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_corba_object_create</NAME>
<RETURNS>Bonobo_Moniker  </RETURNS>
BonoboObject      *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_get_parent</NAME>
<RETURNS>Bonobo_Moniker  </RETURNS>
BonoboMoniker     *moniker,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_set_parent</NAME>
<RETURNS>void  </RETURNS>
BonoboMoniker     *moniker,Bonobo_Moniker     parent,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_get_name</NAME>
<RETURNS>const char               *</RETURNS>
BonoboMoniker     *moniker,int                char_offset
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_set_name</NAME>
<RETURNS>void  </RETURNS>
BonoboMoniker     *moniker,const char        *name,int                num_chars
</FUNCTION>
<MACRO>
<NAME>BONOBO_OBJECT_CLIENT_TYPE</NAME>
#define BONOBO_OBJECT_CLIENT_TYPE        (bonobo_object_client_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_OBJECT_CLIENT</NAME>
#define BONOBO_OBJECT_CLIENT(o)          (GTK_CHECK_CAST ((o), BONOBO_OBJECT_CLIENT_TYPE, BonoboObjectClient))
</MACRO>
<MACRO>
<NAME>BONOBO_OBJECT_CLIENT_CLASS</NAME>
#define BONOBO_OBJECT_CLIENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_OBJECT_CLIENT_TYPE, BonoboObjectClientClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_OBJECT_CLIENT</NAME>
#define BONOBO_IS_OBJECT_CLIENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_OBJECT_CLIENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_OBJECT_CLIENT_CLASS</NAME>
#define BONOBO_IS_OBJECT_CLIENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_OBJECT_CLIENT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboObjectClient</NAME>
typedef struct {
	BonoboObject parent;
} BonoboObjectClient;
</STRUCT>
<STRUCT>
<NAME>BonoboObjectClientClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;
} BonoboObjectClientClass;
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboObjectClientAsyncCallback</NAME>
<RETURNS>void </RETURNS>
BonoboObjectClient             *o,
							  const char                     *error,
							  gpointer                        user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_from_corba</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
Bonobo_Unknown                  o
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_construct</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
BonoboObjectClient             *object_client,CORBA_Object                    corba_object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_activate</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
const char                     *iid,gint                            oaf_flags
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_activate_async</NAME>
<RETURNS>void  </RETURNS>
const char                     *iid,gint                            oaf_flags,BonoboObjectClientAsyncCallback callback,gpointer                        user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_has_interface</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboObjectClient             *object,const char                     *interface_desc,CORBA_Environment              *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_query_interface</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboObjectClient             *object,const char                     *interface_desc,CORBA_Environment              *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_ref</NAME>
<RETURNS>void  </RETURNS>
BonoboObjectClient             *object_client,BonoboObject                   *opt_exception_obj
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_unref</NAME>
<RETURNS>void  </RETURNS>
BonoboObjectClient             *object_client,BonoboObject                   *opt_exception_obj
</FUNCTION>
<STRUCT>
<NAME>ODServerInfo</NAME>
</STRUCT>
<ENUM>
<NAME>ODRegistrationResult</NAME>
typedef enum {
        OD_REG_SUCCESS,
        OD_REG_NOT_LISTED,
        OD_REG_ALREADY_ACTIVE,
        OD_REG_ERROR
} ODRegistrationResult;
</ENUM>
<FUNCTION>
<NAME>bonobo_directory_get_orb</NAME>
<RETURNS>CORBA_ORB  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_new_server_info</NAME>
<RETURNS>ODServerInfo         *</RETURNS>
const gchar       *iid,const gchar       *name,const gchar       *desc
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_get_server_info_id</NAME>
<RETURNS>const gchar          *</RETURNS>
ODServerInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_get_server_info_name</NAME>
<RETURNS>const gchar          *</RETURNS>
ODServerInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_get_server_info_description</NAME>
<RETURNS>const gchar          *</RETURNS>
ODServerInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_server_info_ref</NAME>
<RETURNS>void  </RETURNS>
ODServerInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_server_info_unref</NAME>
<RETURNS>void  </RETURNS>
ODServerInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_get_server_list</NAME>
<RETURNS>GList                *</RETURNS>
const gchar      **required_ids
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_free_server_list</NAME>
<RETURNS>void  </RETURNS>
GList             *list
</FUNCTION>
<FUNCTION>
<NAME>od_server_activate_with_id</NAME>
<RETURNS>CORBA_Object  </RETURNS>
const gchar       *iid,gint               flags,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_register_server</NAME>
<RETURNS>ODRegistrationResult  </RETURNS>
CORBA_Object       objref,const gchar       *iid
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_unregister_server</NAME>
<RETURNS>ODRegistrationResult  </RETURNS>
CORBA_Object       objref,const gchar       *iid
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_get_name_service</NAME>
<RETURNS>CORBA_Object  </RETURNS>
CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_find_for_file</NAME>
<RETURNS>char                 *</RETURNS>
const char  *fname,const char **required_ids,char       **error
</FUNCTION>
<ENUM>
<NAME>GnomeIOStatus</NAME>
typedef enum {
	GNOME_IO_OK,
	
	/* Generic error */
	GNOME_IOERR_GENERAL,

	/* PersistStorage interface not supported by object */
	GNOME_IOERR_PERSIST_NOT_SUPPORTED
	
} GnomeIOStatus;
</ENUM>
<FUNCTION>
<NAME>bonobo_persist_stream_save_object_iid</NAME>
<RETURNS>void  </RETURNS>
Bonobo_Stream target,const CORBA_char *object_iid,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_load_object_iid</NAME>
<RETURNS>char            *</RETURNS>
Bonobo_Stream source
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persiststream_save_to_stream</NAME>
<RETURNS>GnomeIOStatus  </RETURNS>
Bonobo_PersistStream pstream,Bonobo_Stream target,const char *object_iid
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_save_to_stream</NAME>
<RETURNS>GnomeIOStatus  </RETURNS>
BonoboObject *object,Bonobo_Stream stream,const char *object_iid
</FUNCTION>
<MACRO>
<NAME>BONOBO_OBJECT_TYPE</NAME>
#define BONOBO_OBJECT_TYPE        (bonobo_object_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_OBJECT</NAME>
#define BONOBO_OBJECT(o)          (GTK_CHECK_CAST ((o), BONOBO_OBJECT_TYPE, BonoboObject))
</MACRO>
<MACRO>
<NAME>BONOBO_OBJECT_CLASS</NAME>
#define BONOBO_OBJECT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_OBJECT_TYPE, BonoboObjectClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_OBJECT</NAME>
#define BONOBO_IS_OBJECT(o)       (GTK_CHECK_TYPE ((o), BONOBO_OBJECT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_OBJECT_CLASS</NAME>
#define BONOBO_IS_OBJECT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_OBJECT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboObjectServant</NAME>
typedef struct {
	POA_Bonobo_Unknown servant_placeholder;
	gpointer           bonobo_object;
} BonoboObjectServant;
</STRUCT>
<STRUCT>
<NAME>BonoboObjectPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboObject</NAME>
typedef struct {
	GtkObject            base;

	Bonobo_Unknown       corba_objref;
	gpointer             servant;
	BonoboObjectPrivate *priv;
} BonoboObject;
</STRUCT>
<STRUCT>
<NAME>BonoboObjectClass</NAME>
typedef struct {
	GtkObjectClass parent_class;

	/*
	 * signals.  
	 */
	void  (*query_interface) (BonoboObject *object, const char *repo_id,  CORBA_Object      *retval);
	void  (*system_exception)(BonoboObject *object, CORBA_Object cobject, CORBA_Environment *ev);
	void  (*object_gone)     (BonoboObject *object, CORBA_Object cobject, CORBA_Environment *ev);
} BonoboObjectClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_object_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_construct</NAME>
<RETURNS>BonoboObject             *</RETURNS>
BonoboObject           *object,CORBA_Object            corba_object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_new_from_servant</NAME>
<RETURNS>BonoboObject             *</RETURNS>
void                   *servant
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_from_servant</NAME>
<RETURNS>BonoboObject             *</RETURNS>
PortableServer_Servant  servant
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_bind_to_servant</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object,void                   *servant
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_get_servant</NAME>
<RETURNS>PortableServer_Servant  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_activate_servant</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboObject           *object,void                   *servant
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_add_interface</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object,BonoboObject           *newobj
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_query_local_interface</NAME>
<RETURNS>BonoboObject             *</RETURNS>
BonoboObject           *object,const char             *repo_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_query_interface</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboObject           *object,const char             *repo_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_corba_objref</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_dup_ref</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
Bonobo_Unknown          object,CORBA_Environment      *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_release_unref</NAME>
<RETURNS>void  </RETURNS>
Bonobo_Unknown          object,CORBA_Environment      *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_ref</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_unref</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_get_epv</NAME>
<RETURNS>POA_Bonobo_Unknown__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_trace_refs</NAME>
<RETURNS>void  </RETURNS>
BonoboObject *object,const char   *fn,int           line,gboolean      ref
</FUNCTION>
<MACRO>
<NAME>bonobo_object_ref</NAME>
#	define           bonobo_object_ref(o)   G_STMT_START{bonobo_object_trace_refs((o),G_GNUC_PRETTY_FUNCTION,__LINE__,TRUE);}G_STMT_END
</MACRO>
<MACRO>
<NAME>bonobo_object_unref</NAME>
#	define           bonobo_object_unref(o) G_STMT_START{bonobo_object_trace_refs((o),G_GNUC_PRETTY_FUNCTION,__LINE__,FALSE);}G_STMT_END
</MACRO>
<FUNCTION>
<NAME>bonobo_object_dump_interfaces</NAME>
<RETURNS>void  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_check_env</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object,CORBA_Object            corba_object,CORBA_Environment      *ev
</FUNCTION>
<MACRO>
<NAME>BONOBO_OBJECT_CHECK</NAME>
#define BONOBO_OBJECT_CHECK(o,c,e)	\
			G_STMT_START {				\
			if ((e)->_major != CORBA_NO_EXCEPTION)	\
				bonobo_object_check_env(o,c,e);	\
			} G_STMT_END
</MACRO>
<FUNCTION>
<NAME>gnome_unknown_ping</NAME>
<RETURNS>gboolean  </RETURNS>
Bonobo_Unknown object
</FUNCTION>
<MACRO>
<NAME>BONOBO_PERSIST_FILE_TYPE</NAME>
#define BONOBO_PERSIST_FILE_TYPE (bonobo_persist_file_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_FILE</NAME>
#define BONOBO_PERSIST_FILE(o)   (GTK_CHECK_CAST ((o), BONOBO_PERSIST_FILE_TYPE, BonoboPersistFile))
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_FILE_CLASS</NAME>
#define BONOBO_PERSIST_FILE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PERSIST_FILE_TYPE, BonoboPersistFileClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_FILE</NAME>
#define BONOBO_IS_PERSIST_FILE(o)       (GTK_CHECK_TYPE ((o), BONOBO_PERSIST_FILE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_FILE_CLASS</NAME>
#define BONOBO_IS_PERSIST_FILE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PERSIST_FILE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPersistFile</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboPersistFilePrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboPersistFileIOFn</NAME>
<RETURNS>int </RETURNS>
BonoboPersistFile *pf,
				      const CORBA_char  *filename,
				      CORBA_Environment *ev,
				      void              *closure
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboPersistFile</NAME>
struct BonoboPersistFile {
	BonoboPersist persist;

	gboolean     is_dirty;
	char *filename;

	/*
	 * For the sample routines, NULL if we use the ::save and ::load
	 * methods from the class
	 */
	BonoboPersistFileIOFn  save_fn;
	BonoboPersistFileIOFn  load_fn;
	void *closure;

	BonoboPersistFilePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboPersistFileClass</NAME>
typedef struct {
	BonoboPersistClass parent_class;

	/*
	 * methods
	 */
	int   (*load)             (BonoboPersistFile *ps,
				   const CORBA_char  *filename,
				   CORBA_Environment *ev);

	int   (*save)             (BonoboPersistFile *ps,
				   const CORBA_char  *filename,
				   CORBA_Environment *ev);

	char *(*get_current_file) (BonoboPersistFile *ps,
				   CORBA_Environment *ev);

} BonoboPersistFileClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_persist_file_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_file_set_dirty</NAME>
<RETURNS>void  </RETURNS>
BonoboPersistFile *ps,gboolean dirty
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_file_new</NAME>
<RETURNS>BonoboPersistFile  *</RETURNS>
BonoboPersistFileIOFn load_fn,BonoboPersistFileIOFn save_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_file_construct</NAME>
<RETURNS>BonoboPersistFile  *</RETURNS>
BonoboPersistFile *ps,Bonobo_PersistFile corba_ps,BonoboPersistFileIOFn load_fn,BonoboPersistFileIOFn save_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_file_get_epv</NAME>
<RETURNS>POA_Bonobo_PersistFile__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_PERSIST_STREAM_TYPE</NAME>
#define BONOBO_PERSIST_STREAM_TYPE        (bonobo_persist_stream_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_STREAM</NAME>
#define BONOBO_PERSIST_STREAM(o)          (GTK_CHECK_CAST ((o), BONOBO_PERSIST_STREAM_TYPE, BonoboPersistStream))
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_STREAM_CLASS</NAME>
#define BONOBO_PERSIST_STREAM_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PERSIST_STREAM_TYPE, BonoboPersistStreamClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_STREAM</NAME>
#define BONOBO_IS_PERSIST_STREAM(o)       (GTK_CHECK_TYPE ((o), BONOBO_PERSIST_STREAM_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_STREAM_CLASS</NAME>
#define BONOBO_IS_PERSIST_STREAM_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PERSIST_STREAM_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPersistStream</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboPersistStreamPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboPersistStreamIOFn</NAME>
<RETURNS>void </RETURNS>
BonoboPersistStream         *ps,
					  const Bonobo_Stream         stream,
					  Bonobo_Persist_ContentType  type,
					  void                       *closure,
					  CORBA_Environment          *ev
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboPersistStreamMaxFn</NAME>
<RETURNS>CORBA_long </RETURNS>
BonoboPersistStream *ps,
						void                *closure,
						CORBA_Environment   *ev
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboPersistStreamTypesFn</NAME>
<RETURNS>Bonobo_Persist_ContentTypeList *</RETURNS>
BonoboPersistStream *ps,
									void                *closure,
									CORBA_Environment   *ev
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboPersistStream</NAME>
struct BonoboPersistStream {
	BonoboPersist persist;

	gboolean     is_dirty;

	/*
	 * For the sample routines, NULL if we use the
	 * methods from the class
	 */
	BonoboPersistStreamIOFn    save_fn;
	BonoboPersistStreamIOFn    load_fn;
	BonoboPersistStreamMaxFn   max_fn;
	BonoboPersistStreamTypesFn types_fn;
	
	void *closure;

	BonoboPersistStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboPersistStreamClass</NAME>
typedef struct {
	BonoboPersistClass parent_class;

	/*
	 * methods
	 */
	void       (*load)         (BonoboPersistStream        *ps,
				    Bonobo_Stream              stream,
				    Bonobo_Persist_ContentType type,
				    CORBA_Environment          *ev);
	void       (*save)         (BonoboPersistStream        *ps,
				    Bonobo_Stream              stream,
				    Bonobo_Persist_ContentType type,
				    CORBA_Environment          *ev);
	CORBA_long (*get_size_max) (BonoboPersistStream *ps,
				    CORBA_Environment   *ev);
	Bonobo_Persist_ContentTypeList * (*get_content_types) (BonoboPersistStream *ps,
							       CORBA_Environment   *ev);

} BonoboPersistStreamClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_persist_stream_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_set_dirty</NAME>
<RETURNS>void  </RETURNS>
BonoboPersistStream *ps,gboolean dirty
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_new</NAME>
<RETURNS>BonoboPersistStream  *</RETURNS>
BonoboPersistStreamIOFn load_fn,BonoboPersistStreamIOFn save_fn,BonoboPersistStreamMaxFn max_fn,BonoboPersistStreamTypesFn types_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_construct</NAME>
<RETURNS>BonoboPersistStream  *</RETURNS>
BonoboPersistStream *ps,Bonobo_PersistStream corba_ps,BonoboPersistStreamIOFn load_fn,BonoboPersistStreamIOFn save_fn,BonoboPersistStreamMaxFn max_fn,BonoboPersistStreamTypesFn types_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_get_epv</NAME>
<RETURNS>POA_Bonobo_PersistStream__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_PERSIST_TYPE</NAME>
#define BONOBO_PERSIST_TYPE        (bonobo_persist_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST</NAME>
#define BONOBO_PERSIST(o)          (GTK_CHECK_CAST ((o), BONOBO_PERSIST_TYPE, BonoboPersist))
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_CLASS</NAME>
#define BONOBO_PERSIST_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PERSIST_TYPE, BonoboPersistClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST</NAME>
#define BONOBO_IS_PERSIST(o)       (GTK_CHECK_TYPE ((o), BONOBO_PERSIST_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_CLASS</NAME>
#define BONOBO_IS_PERSIST_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PERSIST_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPersist</NAME>
typedef struct {
	BonoboObject object;

	BonoboPersistPrivate *priv;
} BonoboPersist;
</STRUCT>
<STRUCT>
<NAME>BonoboPersistClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	Bonobo_Persist_ContentTypeList * (*get_content_types) (BonoboPersist *persist,
							       CORBA_Environment *ev);
} BonoboPersistClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_persist_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_construct</NAME>
<RETURNS>BonoboPersist  *</RETURNS>
BonoboPersist *persist,Bonobo_Persist corba_persist
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_generate_content_types</NAME>
<RETURNS>Bonobo_Persist_ContentTypeList  *</RETURNS>
int num,...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_get_epv</NAME>
<RETURNS>POA_Bonobo_Persist__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_PLUG</NAME>
#define BONOBO_PLUG(obj)          GTK_CHECK_CAST (obj, bonobo_plug_get_type (), BonoboPlug)
</MACRO>
<MACRO>
<NAME>BONOBO_PLUG_CLASS</NAME>
#define BONOBO_PLUG_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, bonobo_plug_get_type (), BonoboPlugClass)
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PLUG</NAME>
#define BONOBO_IS_PLUG(obj)       GTK_CHECK_TYPE (obj, bonobo_plug_get_type ())
</MACRO>
<STRUCT>
<NAME>BonoboPlug</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboPlugClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboPlug</NAME>
struct BonoboPlug {
	GtkWindow window;

	GdkWindow *socket_window;
	gint same_app;
};
</STRUCT>
<STRUCT>
<NAME>BonoboPlugClass</NAME>
struct BonoboPlugClass {
	GtkWindowClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_plug_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_plug_construct</NAME>
<RETURNS>void  </RETURNS>
BonoboPlug *plug, guint32 socket_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_plug_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
guint32 socket_id
</FUNCTION>
<MACRO>
<NAME>BONOBO_PRINT_CLIENT_TYPE</NAME>
#define BONOBO_PRINT_CLIENT_TYPE        (bonobo_print_client_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT_CLIENT</NAME>
#define BONOBO_PRINT_CLIENT(o)          (GTK_CHECK_CAST ((o), BONOBO_PRINT_CLIENT_TYPE, BonoboPrintClient))
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT_CLIENT_CLASS</NAME>
#define BONOBO_PRINT_CLIENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PRINT_CLIENT_TYPE, BonoboPrintClientClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PRINT_CLIENT</NAME>
#define BONOBO_IS_PRINT_CLIENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_PRINT_CLIENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PRINT_CLIENT_CLASS</NAME>
#define BONOBO_IS_PRINT_CLIENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PRINT_CLIENT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPrintClient</NAME>
typedef struct {
	GtkObject    parent;
	Bonobo_Print corba_print;
} BonoboPrintClient;
</STRUCT>
<STRUCT>
<NAME>BonoboPrintClientClass</NAME>
typedef struct {
	GtkObjectClass			parent;
} BonoboPrintClientClass;
</STRUCT>
<STRUCT>
<NAME>BonoboPrintData</NAME>
typedef struct {
	double width;
	double height;
	
	double width_first_page;
	double width_per_page;
	double height_first_page;
	double height_per_page;

	GnomePrintMeta *meta_data;
} BonoboPrintData;
</STRUCT>
<FUNCTION>
<NAME>bonobo_print_client_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_client_new</NAME>
<RETURNS>BonoboPrintClient   *</RETURNS>
Bonobo_Print         corba_print
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_client_get</NAME>
<RETURNS>BonoboPrintClient   *</RETURNS>
BonoboObjectClient  *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_client_render</NAME>
<RETURNS>void  </RETURNS>
BonoboPrintClient   *client,BonoboPrintData     *pd
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_new</NAME>
<RETURNS>BonoboPrintData     *</RETURNS>
double               width,double               height
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_new_full</NAME>
<RETURNS>BonoboPrintData     *</RETURNS>
double               width,double               height,double               width_first_page,double               width_per_page,double               height_first_page,double               height_per_page
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_free</NAME>
<RETURNS>void  </RETURNS>
BonoboPrintData     *pd
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_get_meta</NAME>
<RETURNS>GnomePrintMeta      *</RETURNS>
BonoboPrintData     *pd
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_render</NAME>
<RETURNS>void  </RETURNS>
GnomePrintContext   *pc,double               x,double               y,BonoboPrintData     *pd,double               meta_x,double               meta_y
</FUNCTION>
<MACRO>
<NAME>BONOBO_PRINT_TYPE</NAME>
#define BONOBO_PRINT_TYPE        (bonobo_print_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT</NAME>
#define BONOBO_PRINT(o)          (GTK_CHECK_CAST ((o), BONOBO_PRINT_TYPE, BonoboPrint))
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT_CLASS</NAME>
#define BONOBO_PRINT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PRINT_TYPE, BonoboPrintClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PRINT</NAME>
#define BONOBO_IS_PRINT(o)       (GTK_CHECK_TYPE ((o), BONOBO_PRINT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PRINT_CLASS</NAME>
#define BONOBO_IS_PRINT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PRINT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPrint</NAME>
typedef struct {
        BonoboObject         object;

	BonoboPrintRenderFn *render;
	gpointer             user_data;
} BonoboPrint;
</STRUCT>
<STRUCT>
<NAME>BonoboPrintClass</NAME>
typedef struct {
	BonoboObjectClass    parent;
	BonoboPrintRenderFn *render;
} BonoboPrintClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_print_get_epv</NAME>
<RETURNS>POA_Bonobo_Print__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_corba_object_create</NAME>
<RETURNS>Bonobo_Print  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_construct</NAME>
<RETURNS>BonoboPrint     *</RETURNS>
BonoboPrint         *p,Bonobo_Print         corba_p,BonoboPrintRenderFn *render,gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_new</NAME>
<RETURNS>BonoboPrint     *</RETURNS>
BonoboPrintRenderFn *render,gpointer             user_data
</FUNCTION>
<MACRO>
<NAME>BONOBO_PROGRESSIVE_DATA_SINK_TYPE</NAME>
#define BONOBO_PROGRESSIVE_DATA_SINK_TYPE        (bonobo_progressive_data_sink_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PROGRESSIVE_DATA_SINK</NAME>
#define BONOBO_PROGRESSIVE_DATA_SINK(o)          (GTK_CHECK_CAST ((o), BONOBO_PROGRESSIVE_DATA_SINK_TYPE, BonoboProgressiveDataSink))
</MACRO>
<MACRO>
<NAME>BONOBO_PROGRESSIVE_DATA_SINK_CLASS</NAME>
#define BONOBO_PROGRESSIVE_DATA_SINK_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PROGRESSIVE_DATA_SINK_TYPE, BonoboProgressiveDataSinkClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROGRESSIVE_DATA_SINK</NAME>
#define BONOBO_IS_PROGRESSIVE_DATA_SINK(o)       (GTK_CHECK_TYPE ((o), BONOBO_PROGRESSIVE_DATA_SINK_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROGRESSIVE_DATA_SINK_CLASS</NAME>
#define BONOBO_IS_PROGRESSIVE_DATA_SINK_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PROGRESSIVE_DATA_SINK_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboProgressiveDataSink</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboProgressiveDataSinkPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboProgressiveDataSinkStartFn</NAME>
<RETURNS>int </RETURNS>
BonoboProgressiveDataSink *psink,
						  void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboProgressiveDataSinkEndFn</NAME>
<RETURNS>int </RETURNS>
BonoboProgressiveDataSink *psink, void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboProgressiveDataSinkAddDataFn</NAME>
<RETURNS>int </RETURNS>
BonoboProgressiveDataSink *psink,
						  const Bonobo_ProgressiveDataSink_iobuf *buffer,
						  void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboProgressiveDataSinkSetSizeFn</NAME>
<RETURNS>int </RETURNS>
BonoboProgressiveDataSink *psink,
						  const CORBA_long count, void *closure
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboProgressiveDataSink</NAME>
struct BonoboProgressiveDataSink {
	BonoboObject object;

	/*
	 * These are the callbacks the user can set.  If we use the
	 * default class methods, then these are NULL.
	 */
	BonoboProgressiveDataSinkStartFn start_fn;
	BonoboProgressiveDataSinkEndFn end_fn;
	BonoboProgressiveDataSinkAddDataFn add_data_fn;
	BonoboProgressiveDataSinkSetSizeFn set_size_fn;

	void *closure;

	BonoboProgressiveDataSinkPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboProgressiveDataSinkClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * Methods.
	 */
	int (*start_fn)    (BonoboProgressiveDataSink *psink);
	int (*end_fn)      (BonoboProgressiveDataSink *psink);
	int (*add_data_fn) (BonoboProgressiveDataSink *psink,
			    const Bonobo_ProgressiveDataSink_iobuf *buffer);
	int (*set_size_fn) (BonoboProgressiveDataSink *psink,
			    const CORBA_long count);
			 
} BonoboProgressiveDataSinkClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_progressive_data_sink_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_progressive_data_sink_new</NAME>
<RETURNS>BonoboProgressiveDataSink  *</RETURNS>
BonoboProgressiveDataSinkStartFn start_fn,BonoboProgressiveDataSinkEndFn end_fn,BonoboProgressiveDataSinkAddDataFn add_data_fn,BonoboProgressiveDataSinkSetSizeFn set_size_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_progressive_data_sink_construct</NAME>
<RETURNS>BonoboProgressiveDataSink  *</RETURNS>
BonoboProgressiveDataSink *psink,Bonobo_ProgressiveDataSink corba_psink,BonoboProgressiveDataSinkStartFn start_fn,BonoboProgressiveDataSinkEndFn end_fn,BonoboProgressiveDataSinkAddDataFn add_data_fn,BonoboProgressiveDataSinkSetSizeFn set_size_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_progressive_get_epv</NAME>
<RETURNS>POA_Bonobo_ProgressiveDataSink__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_properties</NAME>
<RETURNS>GList 			*</RETURNS>
Bonobo_PropertyBag       pb,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_free_properties</NAME>
<RETURNS>void  </RETURNS>
GList *list
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_property_names</NAME>
<RETURNS>GList 			*</RETURNS>
Bonobo_PropertyBag       pb,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_property</NAME>
<RETURNS>Bonobo_Property 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *property_name,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_persist</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,Bonobo_Stream            stream,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_depersist</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,Bonobo_Stream            stream,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_setv</NAME>
<RETURNS>char                     *</RETURNS>
Bonobo_PropertyBag       pb,CORBA_Environment       *ev,const char              *first_arg,va_list                  var_args
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_getv</NAME>
<RETURNS>char                     *</RETURNS>
Bonobo_PropertyBag       pb,CORBA_Environment       *ev,const char              *first_arg,va_list                  var_args
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_property_type</NAME>
<RETURNS>CORBA_TypeCode  </RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_gboolean</NAME>
<RETURNS>gboolean 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_gint</NAME>
<RETURNS>gint 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_glong</NAME>
<RETURNS>glong 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_gfloat</NAME>
<RETURNS>gfloat 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_gdouble</NAME>
<RETURNS>gdouble 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_string</NAME>
<RETURNS>char 			*</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_any</NAME>
<RETURNS>BonoboArg 		*</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_gboolean</NAME>
<RETURNS>gboolean 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_gint</NAME>
<RETURNS>gint 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_glong</NAME>
<RETURNS>glong 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_gfloat</NAME>
<RETURNS>gfloat 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_gdouble</NAME>
<RETURNS>gdouble 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_string</NAME>
<RETURNS>char 			*</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_any</NAME>
<RETURNS>BonoboArg 		*</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_gboolean</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,gboolean                value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_gint</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,gint                     value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_glong</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,glong                    value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_gfloat</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,gfloat                   value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_gdouble</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,gdouble                  value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_string</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,const char              *value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_any</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,BonoboArg               *value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_docstring</NAME>
<RETURNS>char 			*</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_flags</NAME>
<RETURNS>BonoboPropertyFlags 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<STRUCT>
<NAME>BonoboPropertyBagPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboPropertyBag</NAME>
</STRUCT>
<ENUM>
<NAME>BonoboPropertyFlags</NAME>
typedef enum {
	BONOBO_PROPERTY_UNSTORED        = 1,
	BONOBO_PROPERTY_READABLE        = 2,
	BONOBO_PROPERTY_WRITEABLE       = 4,
	BONOBO_PROPERTY_USE_DEFAULT_OPT = 8,
	BONOBO_PROPERTY_NO_LISTENING    = 16
} BonoboPropertyFlags;
</ENUM>
<USER_FUNCTION>
<NAME>BonoboPropertyGetFn</NAME>
<RETURNS>void </RETURNS>
BonoboPropertyBag *bag,
				     BonoboArg         *arg,
				     guint              arg_id,
				     gpointer           user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboPropertySetFn</NAME>
<RETURNS>void </RETURNS>
BonoboPropertyBag *bag,
				     const BonoboArg   *arg,
				     guint              arg_id,
				     gpointer           user_data
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboPropertyBag</NAME>
struct BonoboPropertyBag {
	BonoboObject              parent;
	BonoboPropertyBagPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboPropertyBagClass</NAME>
typedef struct {
	BonoboObjectClass   parent;
} BonoboPropertyBagClass;
</STRUCT>
<MACRO>
<NAME>BONOBO_PROPERTY_BAG_TYPE</NAME>
#define BONOBO_PROPERTY_BAG_TYPE                (bonobo_property_bag_get_gtk_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PROPERTY_BAG</NAME>
#define BONOBO_PROPERTY_BAG(o)		        (GTK_CHECK_CAST ((o), BONOBO_PROPERTY_BAG_TYPE, BonoboPropertyBag))
</MACRO>
<MACRO>
<NAME>BONOBO_PROPERTY_BAG_CLASS</NAME>
#define BONOBO_PROPERTY_BAG_CLASS(k)		(GTK_CHECK_CLASS_CAST((k), BONOBO_PROPERTY_BAG_TYPE, BonoboPropertyBagClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROPERTY_BAG</NAME>
#define BONOBO_IS_PROPERTY_BAG(o)		(GTK_CHECK_TYPE ((o), BONOBO_PROPERTY_BAG_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROPERTY_BAG_CLASS</NAME>
#define BONOBO_IS_PROPERTY_BAG_CLASS(k)		(GTK_CHECK_CLASS_TYPE ((k), BONOBO_PROPERTY_BAG_TYPE))
</MACRO>
<FUNCTION>
<NAME>bonobo_property_bag_get_gtk_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_new</NAME>
<RETURNS>BonoboPropertyBag 	 *</RETURNS>
BonoboPropertyGetFn get_prop,BonoboPropertySetFn set_prop,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_add</NAME>
<RETURNS>void  </RETURNS>
BonoboPropertyBag  *pb,const char         *name,int                 idx,BonoboArgType       type,BonoboArg          *default_value,const char         *docstring,BonoboPropertyFlags flags
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_add_full</NAME>
<RETURNS>void  </RETURNS>
BonoboPropertyBag  *pb,const char         *name,int                 idx,BonoboArgType       type,BonoboArg          *default_value,const char         *docstring,BonoboPropertyFlags flags,BonoboPropertyGetFn get_prop,BonoboPropertySetFn set_prop,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_add_gtk_args</NAME>
<RETURNS>void  </RETURNS>
BonoboPropertyBag  *pb,GtkObject          *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_type</NAME>
<RETURNS>BonoboArgType  </RETURNS>
BonoboPropertyBag *pb, const char *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_set_value</NAME>
<RETURNS>void 	</RETURNS>
BonoboPropertyBag *pb,const char        *name,const BonoboArg   *value,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_value</NAME>
<RETURNS>BonoboArg                 *</RETURNS>
BonoboPropertyBag *pb, const char *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_default</NAME>
<RETURNS>BonoboArg                 *</RETURNS>
BonoboPropertyBag *pb, const char *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_docstring</NAME>
<RETURNS>const char 	         *</RETURNS>
BonoboPropertyBag *pb, const char *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_flags</NAME>
<RETURNS>const BonoboPropertyFlags  </RETURNS>
BonoboPropertyBag *pb, const char *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_has_property</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboPropertyBag *pb, const char *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_add_listener</NAME>
<RETURNS>void  </RETURNS>
BonoboPropertyBag      *pb,const gchar            *name,Bonobo_PropertyListener listener,CORBA_Environment      *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_remove_listener</NAME>
<RETURNS>void  </RETURNS>
BonoboPropertyBag      *pb,const gchar            *name,Bonobo_PropertyListener listener,CORBA_Environment      *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_notify_listeners</NAME>
<RETURNS>void  </RETURNS>
BonoboPropertyBag      *pb,const char             *name,const BonoboArg        *new_value,CORBA_Environment      *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_prop_list</NAME>
<RETURNS>GList                     *</RETURNS>
BonoboPropertyBag *pb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_epv</NAME>
<RETURNS>POA_Bonobo_PropertyBag__epv  *</RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>BonoboPropertyListener</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_PROPERTY_LISTENER_TYPE</NAME>
#define BONOBO_PROPERTY_LISTENER_TYPE        (bonobo_property_listener_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PROPERTY_LISTENER</NAME>
#define BONOBO_PROPERTY_LISTENER(o)          (GTK_CHECK_CAST ((o), BONOBO_PROPERTY_LISTENER_TYPE, BonoboPropertyListener))
</MACRO>
<MACRO>
<NAME>BONOBO_PROPERTY_LISTENER_CLASS</NAME>
#define BONOBO_PROPERTY_LISTENER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PROPERTY_LISTENER_TYPE, BonoboPropertyListenerClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROPERTY_LISTENER</NAME>
#define BONOBO_IS_PROPERTY_LISTENER(o)       (GTK_CHECK_TYPE ((o), BONOBO_PROPERTY_LISTENER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROPERTY_LISTENER_CLASS</NAME>
#define BONOBO_IS_PROPERTY_LISTENER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PROPERTY_LISTENER_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPropertyListener</NAME>
struct BonoboPropertyListener {
        BonoboObject		object;
};
</STRUCT>
<STRUCT>
<NAME>BonoboPropertyListenerClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/* Signal definition */
	void (* prop_changed) (BonoboPropertyListener *listener, gchar *name, BonoboArg *event_data);
} BonoboPropertyListenerClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_property_listener_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_listener_get_epv</NAME>
<RETURNS>POA_Bonobo_PropertyListener__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_listener_new</NAME>
<RETURNS>BonoboPropertyListener  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_marshal_boolean</NAME>
<RETURNS>CORBA_any  *</RETURNS>
const char *type, gconstpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_marshal_string</NAME>
<RETURNS>CORBA_any  *</RETURNS>
const char *type, gconstpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_marshal_short</NAME>
<RETURNS>CORBA_any  *</RETURNS>
const char *type, gconstpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_marshal_ushort</NAME>
<RETURNS>CORBA_any  *</RETURNS>
const char *type, gconstpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_marshal_long</NAME>
<RETURNS>CORBA_any  *</RETURNS>
const char *type, gconstpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_marshal_ulong</NAME>
<RETURNS>CORBA_any  *</RETURNS>
const char *type, gconstpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_marshal_float</NAME>
<RETURNS>CORBA_any  *</RETURNS>
const char *type, gconstpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_marshal_double</NAME>
<RETURNS>CORBA_any  *</RETURNS>
const char *type, gconstpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_demarshal_boolean</NAME>
<RETURNS>gpointer  </RETURNS>
const char *type, const CORBA_any *any,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_demarshal_string</NAME>
<RETURNS>gpointer  </RETURNS>
const char *type, const CORBA_any *any,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_demarshal_short</NAME>
<RETURNS>gpointer  </RETURNS>
const char *type, const CORBA_any *any,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_demarshal_ushort</NAME>
<RETURNS>gpointer  </RETURNS>
const char *type, const CORBA_any *any,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_demarshal_long</NAME>
<RETURNS>gpointer  </RETURNS>
const char *type, const CORBA_any *any,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_demarshal_ulong</NAME>
<RETURNS>gpointer  </RETURNS>
const char *type, const CORBA_any *any,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_demarshal_float</NAME>
<RETURNS>gpointer  </RETURNS>
const char *type, const CORBA_any *any,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_demarshal_double</NAME>
<RETURNS>gpointer  </RETURNS>
const char *type, const CORBA_any *any,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_compare_boolean</NAME>
<RETURNS>gboolean  </RETURNS>
const char *type, gpointer value1,gpointer value2,  gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_compare_string</NAME>
<RETURNS>gboolean  </RETURNS>
const char *type, gpointer value1,gpointer value2,  gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_compare_short</NAME>
<RETURNS>gboolean  </RETURNS>
const char *type, gpointer value1,gpointer value2,  gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_compare_ushort</NAME>
<RETURNS>gboolean  </RETURNS>
const char *type, gpointer value1,gpointer value2,  gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_compare_long</NAME>
<RETURNS>gboolean  </RETURNS>
const char *type, gpointer value1,gpointer value2,  gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_compare_ulong</NAME>
<RETURNS>gboolean  </RETURNS>
const char *type, gpointer value1,gpointer value2,  gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_compare_float</NAME>
<RETURNS>gboolean  </RETURNS>
const char *type, gpointer value1,gpointer value2,  gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_compare_double</NAME>
<RETURNS>gboolean  </RETURNS>
const char *type, gpointer value1,gpointer value2,  gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_generic_releaser</NAME>
<RETURNS>void 	</RETURNS>
const char *type, gpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_servant_new</NAME>
<RETURNS>PortableServer_Servant  </RETURNS>
PortableServer_POA adapter, BonoboPropertyBag *pb,char *property_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_servant_destroy</NAME>
<RETURNS>void 	</RETURNS>
PortableServer_Servant servant
</FUNCTION>
<STRUCT>
<NAME>BonoboProperty</NAME>
typedef struct {
	char			*name;
	int                      idx;
	BonoboArgType            type;
	BonoboArg               *default_value;
	char			*docstring;
	BonoboPropertyFlags	 flags;

	BonoboPropertyGetFn      get_prop;
	BonoboPropertySetFn      set_prop;
	gpointer                 user_data;
	GSList                  *listeners;
} BonoboProperty;
</STRUCT>
<MACRO>
<NAME>BONOBO_SELECTOR</NAME>
#define BONOBO_SELECTOR(obj)	GTK_CHECK_CAST(obj, bonobo_selector_get_type (), BonoboSelector)
</MACRO>
<MACRO>
<NAME>BONOBO_SELECTOR_CLASS</NAME>
#define BONOBO_SELECTOR_CLASS	GTK_CHECK_CLASS_CAST (klass, bonobo_selector_get_type (), BonoboSelectorClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_BONOBO_SELECTOR</NAME>
#define GNOME_IS_BONOBO_SELECTOR(obj)	GTK_CHECK_TYPE (obj, bonobo_selector_get_type ())
</MACRO>
<STRUCT>
<NAME>BonoboSelector</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboSelectorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboSelectorPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboSelectorClass</NAME>
struct BonoboSelectorClass
{
	GnomeDialogClass parent_class;
	
	void (* ok)	(BonoboSelector *sel);
	void (* cancel)	(BonoboSelector *sel);
};
</STRUCT>
<STRUCT>
<NAME>BonoboSelector</NAME>
struct BonoboSelector
{
	GnomeDialog dialog;
		
	BonoboSelectorPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_selector_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar *title,const gchar **interfaces_required
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_get_selected_id</NAME>
<RETURNS>gchar 	  *</RETURNS>
BonoboSelector *sel
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_get_selected_name</NAME>
<RETURNS>gchar      *</RETURNS>
BonoboSelector *sel
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_get_selected_description</NAME>
<RETURNS>gchar      *</RETURNS>
BonoboSelector *sel
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_select_id</NAME>
<RETURNS>gchar 	  *</RETURNS>
const gchar *title,const gchar **interfaces_required
</FUNCTION>
<MACRO>
<NAME>BONOBO_SOCKET</NAME>
#define BONOBO_SOCKET(obj)          GTK_CHECK_CAST (obj, bonobo_socket_get_type (), BonoboSocket)
</MACRO>
<MACRO>
<NAME>BONOBO_SOCKET_CLASS</NAME>
#define BONOBO_SOCKET_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, bonobo_socket_get_type (), BonoboSocketClass)
</MACRO>
<MACRO>
<NAME>BONOBO_IS_SOCKET</NAME>
#define BONOBO_IS_SOCKET(obj)       GTK_CHECK_TYPE (obj, bonobo_socket_get_type ())
</MACRO>
<STRUCT>
<NAME>BonoboSocket</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboSocketClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboSocketPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboSocket</NAME>
struct BonoboSocket {
	GtkContainer container;

	BonoboSocketPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboSocketClass</NAME>
struct BonoboSocketClass {
	GtkContainerClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_socket_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_socket_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_socket_set_control</NAME>
<RETURNS>void  </RETURNS>
BonoboSocket  *socket,Bonobo_Control control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_socket_steal</NAME>
<RETURNS>void  </RETURNS>
BonoboSocket    *socket,guint32          wid
</FUNCTION>
<STRUCT>
<NAME>StoragePlugin</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>StoragePluginInitFn</NAME>
<RETURNS>gint </RETURNS>
StoragePlugin *plugin
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboStorageOpenFn</NAME>
<RETURNS>BonoboStorage *</RETURNS>
const char *path, 
					       gint flags, 
					       gint mode, 
					       CORBA_Environment *ev
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboStreamOpenFn</NAME>
<RETURNS>BonoboStream *</RETURNS>
const char *path, 
					       gint flags, 
					       gint mode,
					       CORBA_Environment *ev
</USER_FUNCTION>
<STRUCT>
<NAME>StoragePlugin</NAME>
struct StoragePlugin {
	/* public, read only */
	gchar               *filename;     
	gchar               *name;         /* efs, file */
	gchar               *description;
	gchar               *version;
	BonoboStorageOpenFn  storage_open;
	BonoboStreamOpenFn   stream_open;
	/* private */
	GModule             *handle;
};
</STRUCT>
<VARIABLE>
<NAME>storage_plugin_list</NAME>
extern GList *storage_plugin_list;
</VARIABLE>
<FUNCTION>
<NAME>init_storage_plugin</NAME>
<RETURNS>gint  </RETURNS>
StoragePlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_load_plugins</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_plugin_find</NAME>
<RETURNS>StoragePlugin  *</RETURNS>
const gchar *name
</FUNCTION>
<MACRO>
<NAME>BONOBO_STORAGE_TYPE</NAME>
#define BONOBO_STORAGE_TYPE        (bonobo_storage_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_STORAGE</NAME>
#define BONOBO_STORAGE(o)          (GTK_CHECK_CAST ((o), BONOBO_STORAGE_TYPE, BonoboStorage))
</MACRO>
<MACRO>
<NAME>BONOBO_STORAGE_CLASS</NAME>
#define BONOBO_STORAGE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_STORAGE_TYPE, BonoboStorageClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STORAGE</NAME>
#define BONOBO_IS_STORAGE(o)       (GTK_CHECK_TYPE ((o), BONOBO_STORAGE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STORAGE_CLASS</NAME>
#define BONOBO_IS_STORAGE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_STORAGE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboStoragePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboStorage</NAME>
typedef struct {
        BonoboObject object;

	BonoboStoragePrivate *priv;
} BonoboStorage;
</STRUCT>
<STRUCT>
<NAME>BonoboStorageClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * virtual methods
	 */
	Bonobo_StorageInfo *(*get_info) (BonoboStorage *storage,
					 const CORBA_char *path,
					 const Bonobo_StorageInfoFields mask,
					 CORBA_Environment *ev);
	void          (*set_info)       (BonoboStorage *storage,
					 const CORBA_char *path,
					 const Bonobo_StorageInfo * info,
					 const Bonobo_StorageInfoFields mask,
					 CORBA_Environment *ev);
	BonoboStream  *(*open_stream)   (BonoboStorage *storage,
					 const CORBA_char *path,
					 Bonobo_Storage_OpenMode, 
					 CORBA_Environment *ev);
	BonoboStorage *(*open_storage)  (BonoboStorage *storage,
					 const CORBA_char *path,
					 Bonobo_Storage_OpenMode, 
					 CORBA_Environment *ev);
	void         (*copy_to)         (BonoboStorage *storage, 
					 Bonobo_Storage target,
					 CORBA_Environment *ev);
	void         (*rename)          (BonoboStorage *storage,
					 const CORBA_char *path_name,
					 const CORBA_char *new_path_name,
					 CORBA_Environment *ev);
	void         (*commit)          (BonoboStorage *storage,
					 CORBA_Environment *ev);
	void         (*revert)          (BonoboStorage *storage,
					 CORBA_Environment *ev);
	Bonobo_Storage_DirectoryList *
	             (*list_contents)   (BonoboStorage *storage,
					 const CORBA_char *path,
					 Bonobo_StorageInfoFields mask,
					 CORBA_Environment *ev);
	void         (*erase)           (BonoboStorage *storage,
                                         const CORBA_char *path,
                                         CORBA_Environment *ev);
} BonoboStorageClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_storage_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_construct</NAME>
<RETURNS>BonoboStorage    *</RETURNS>
BonoboStorage *storage,Bonobo_Storage corba_storage
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_open</NAME>
<RETURNS>BonoboStorage    *</RETURNS>
const char *driver,const char *path,gint flags,gint mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_open_full</NAME>
<RETURNS>BonoboStorage    *</RETURNS>
const char *driver,const char *path,gint flags,gint mode,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_copy_to</NAME>
<RETURNS>void  </RETURNS>
Bonobo_Storage src,Bonobo_Storage dest,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_corba_object_create</NAME>
<RETURNS>Bonobo_Storage  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_write_class_id</NAME>
<RETURNS>void  </RETURNS>
BonoboStorage *storage,char *class_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_write_class_id</NAME>
<RETURNS>void  </RETURNS>
BonoboStream *stream,char *class_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_get_epv</NAME>
<RETURNS>POA_Bonobo_Storage__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_write</NAME>
<RETURNS>void  </RETURNS>
const Bonobo_Stream stream,const void        *buffer,const size_t       size,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_write_string</NAME>
<RETURNS>void  </RETURNS>
const Bonobo_Stream stream,const char         *str,const gboolean      terminate,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_printf</NAME>
<RETURNS>void  </RETURNS>
const Bonobo_Stream stream,const gboolean      terminate,CORBA_Environment  *ev,const char         *fmt, ...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_read_string</NAME>
<RETURNS>CORBA_long  </RETURNS>
const Bonobo_Stream stream,char              **str,CORBA_Environment  *ev
</FUNCTION>
<STRUCT>
<NAME>BonoboStreamMem</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboStreamMemPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboStorageMem</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_STREAM_MEM_TYPE</NAME>
#define BONOBO_STREAM_MEM_TYPE        (bonobo_stream_mem_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_MEM</NAME>
#define BONOBO_STREAM_MEM(o)          (GTK_CHECK_CAST ((o), BONOBO_STREAM_MEM_TYPE, BonoboStreamMem))
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_MEM_CLASS</NAME>
#define BONOBO_STREAM_MEM_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_STREAM_MEM_TYPE, BonoboStreamMemClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM_MEM</NAME>
#define BONOBO_IS_STREAM_MEM(o)       (GTK_CHECK_TYPE ((o), BONOBO_STREAM_MEM_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM_MEM_CLASS</NAME>
#define BONOBO_IS_STREAM_MEM_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_STREAM_MEM_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboStreamMem</NAME>
struct BonoboStreamMem {
	BonoboStream  stream;

	char        *buffer;
	size_t       size;
	long         pos;
	gboolean     read_only;
	gboolean     resizable;

	BonoboStreamMemPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboStreamMemClass</NAME>
typedef struct {
	BonoboStreamClass parent_class;
	char           *(*get_buffer) (BonoboStreamMem *stream_mem);
	size_t          (*get_size)   (BonoboStreamMem *stream_mem);
} BonoboStreamMemClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_stream_mem_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_mem_construct</NAME>
<RETURNS>BonoboStreamMem  *</RETURNS>
BonoboStreamMem  *stream_mem,Bonobo_Stream        corba_stream,const char          *buffer,size_t               size,gboolean             read_only,gboolean             resizable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_mem_create</NAME>
<RETURNS>BonoboStream     *</RETURNS>
const char *buffer, size_t size,gboolean read_only,gboolean resizable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_mem_get_buffer</NAME>
<RETURNS>const char       *</RETURNS>
BonoboStreamMem *stream_mem
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_mem_get_size</NAME>
<RETURNS>size_t  </RETURNS>
BonoboStreamMem *stream_mem
</FUNCTION>
<MACRO>
<NAME>BONOBO_IO_DRIVER_FS</NAME>
#define BONOBO_IO_DRIVER_FS  "fs"
</MACRO>
<MACRO>
<NAME>BONOBO_IO_DRIVER_EFS</NAME>
#define BONOBO_IO_DRIVER_EFS "efs"
</MACRO>
<MACRO>
<NAME>BONOBO_IO_DRIVER_VFS</NAME>
#define BONOBO_IO_DRIVER_VFS "vfs"
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_TYPE</NAME>
#define BONOBO_STREAM_TYPE        (bonobo_stream_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM</NAME>
#define BONOBO_STREAM(o)          (GTK_CHECK_CAST ((o), BONOBO_STREAM_TYPE, BonoboStream))
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_CLASS</NAME>
#define BONOBO_STREAM_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_STREAM_TYPE, BonoboStreamClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM</NAME>
#define BONOBO_IS_STREAM(o)       (GTK_CHECK_TYPE ((o), BONOBO_STREAM_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM_CLASS</NAME>
#define BONOBO_IS_STREAM_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_STREAM_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboStream</NAME>
typedef struct {
        BonoboObject object;
} BonoboStream;
</STRUCT>
<STRUCT>
<NAME>BonoboStreamClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * virtual methods
	 */

	Bonobo_StorageInfo *(*get_info) (BonoboStream *stream,
					 const Bonobo_StorageInfoFields mask,
					 CORBA_Environment *ev);
	void          (*set_info)       (BonoboStream *stream,
					 const Bonobo_StorageInfo *info,
					 const Bonobo_StorageInfoFields mask,
					 CORBA_Environment *ev);
	void          (*write)          (BonoboStream *stream,
					 const Bonobo_Stream_iobuf *buffer,
					 CORBA_Environment *ev);
	void          (*read)           (BonoboStream *stream, 
					 CORBA_long count,
					 Bonobo_Stream_iobuf **buffer,
					 CORBA_Environment *ev);
        CORBA_long    (*seek)           (BonoboStream *stream,
					 CORBA_long offset, 
					 Bonobo_Stream_SeekType whence,
					 CORBA_Environment *ev);
        void          (*truncate)       (BonoboStream *stream,
					 const CORBA_long new_size, 
					 CORBA_Environment *ev);
	void          (*copy_to)        (BonoboStream *stream,
					 const CORBA_char * dest,
					 const CORBA_long bytes,
					 CORBA_long *read,
					 CORBA_long *written,
					 CORBA_Environment *ev);
        void          (*commit)         (BonoboStream *stream,
					 CORBA_Environment *ev);
        void          (*revert)         (BonoboStream *stream,
					 CORBA_Environment *ev);
} BonoboStreamClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_stream_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_get_epv</NAME>
<RETURNS>POA_Bonobo_Stream__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_corba_object_create</NAME>
<RETURNS>Bonobo_Stream  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_open</NAME>
<RETURNS>BonoboStream            *</RETURNS>
const char *driver,const char *path,gint flags,gint mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_open_full</NAME>
<RETURNS>BonoboStream            *</RETURNS>
const char *driver,const char *path,gint flags,gint mode,CORBA_Environment *opt_ev
</FUNCTION>
<MACRO>
<NAME>BONOBO_TRANSIENT_TYPE</NAME>
#define BONOBO_TRANSIENT_TYPE        (bonobo_transient_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_TRANSIENT</NAME>
#define BONOBO_TRANSIENT(o)          (GTK_CHECK_CAST ((o), BONOBO_TRANSIENT_TYPE, BonoboTransient))
</MACRO>
<MACRO>
<NAME>BONOBO_TRANSIENT_CLASS</NAME>
#define BONOBO_TRANSIENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_TRANSIENT_TYPE, BonoboTransientClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_TRANSIENT</NAME>
#define BONOBO_IS_TRANSIENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_TRANSIENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_TRANSIENT_CLASS</NAME>
#define BONOBO_IS_TRANSIENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_TRANSIENT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboTransientPriv</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboTransient</NAME>
typedef struct {
	GtkObject parent;

	PortableServer_POA  poa;
	BonoboTransientPriv *priv;
} BonoboTransient;
</STRUCT>
<STRUCT>
<NAME>BonoboTransientClass</NAME>
typedef struct {
	GtkObjectClass parent_class;
} BonoboTransientClass;
</STRUCT>
<FUNCTION>
<NAME>PortableServer_Servant</NAME>
<RETURNS>typedef  </RETURNS>
*BonoboTransientServantNew) (PortableServer_POA, BonoboTransient *, char *name, gpointer *data
</FUNCTION>
<USER_FUNCTION>
<NAME>BonoboTransientServantDestroy</NAME>
<RETURNS>void </RETURNS>
PortableServer_Servant servant, gpointer *data
</USER_FUNCTION>
<FUNCTION>
<NAME>bonobo_transient_new</NAME>
<RETURNS>BonoboTransient  *</RETURNS>
BonoboTransientServantNew     new_servant,BonoboTransientServantDestroy destroy_servant,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_transient_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_UI_COMPONENT_TYPE</NAME>
#define BONOBO_UI_COMPONENT_TYPE        (bonobo_ui_component_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_COMPONENT</NAME>
#define BONOBO_UI_COMPONENT(o)          (GTK_CHECK_CAST ((o), BONOBO_UI_COMPONENT_TYPE, BonoboUIComponent))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_COMPONENT_CLASS</NAME>
#define BONOBO_UI_COMPONENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_UI_COMPONENT_TYPE, BonoboUIComponentClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_COMPONENT</NAME>
#define BONOBO_IS_UI_COMPONENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_UI_COMPONENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_COMPONENT_CLASS</NAME>
#define BONOBO_IS_UI_COMPONENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_UI_COMPONENT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboUIComponent</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIComponentPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboUIListenerFn</NAME>
<RETURNS>void </RETURNS>
BonoboUIComponent           *component,
				    const char                  *path,
				    Bonobo_UIComponent_EventType type,
				    const char                  *state,
				    gpointer                     user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboUIVerbFn</NAME>
<RETURNS>void </RETURNS>
BonoboUIComponent           *component,
				   gpointer                     user_data,
				   const char                  *cname
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboUIComponent</NAME>
struct BonoboUIComponent {
	BonoboObject              object;
	BonoboUIComponentPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboUIComponentClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * Signals
	 */
	void (*exec_verb) (BonoboUIComponent *comp,
			   const char        *cname);

	void (*ui_event)  (BonoboUIComponent *comp,
			   const char        *path,
			   Bonobo_UIComponent_EventType type,
			   const char        *state);
	/*
	 * Virtual XML Methods
	 */
	void (*freeze)    (BonoboUIComponent *component,
			   CORBA_Environment *opt_ev);

	void (*thaw)      (BonoboUIComponent *component,
			   CORBA_Environment *opt_ev);

	void (*xml_set)   (BonoboUIComponent *component,
			   const char        *path,
			   const char        *xml,
			   CORBA_Environment *ev);

	CORBA_char *(*xml_get) (BonoboUIComponent *component,
				const char        *path,
				gboolean           recurse,
				CORBA_Environment *ev);

	void (*xml_rm)    (BonoboUIComponent *component,
			   const char        *path,
			   CORBA_Environment *ev);

	void (*set_prop)  (BonoboUIComponent *component,
			   const char        *path,
			   const char        *prop,
			   const char        *value,
			   CORBA_Environment *opt_ev);
	
	gchar *(*get_prop) (BonoboUIComponent *component,
			    const char        *path,
			    const char        *prop,
			    CORBA_Environment *opt_ev);

	gboolean (*exists) (BonoboUIComponent *component,
			    const char        *path,
			    CORBA_Environment *ev);
	

	gpointer            dummy;
} BonoboUIComponentClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_ui_component_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_construct</NAME>
<RETURNS>BonoboUIComponent  *</RETURNS>
BonoboUIComponent  *component,Bonobo_UIComponent  corba_ui,const char         *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_new</NAME>
<RETURNS>BonoboUIComponent  *</RETURNS>
const char         *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_new_default</NAME>
<RETURNS>BonoboUIComponent  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_name</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get_name</NAME>
<RETURNS>const char         *</RETURNS>
BonoboUIComponent  *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_container</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,Bonobo_UIContainer  container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_unset_container</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get_container</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboUIComponent  *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_add_verb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *cname,BonoboUIVerbFn      fn,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_add_verb_full</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *cname,BonoboUIVerbFn      fn,gpointer            user_data,GDestroyNotify      destroy_fn
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_remove_verb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *cname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_remove_verb_by_func</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,BonoboUIVerbFn      fn
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_remove_verb_by_data</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_add_listener</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *id,BonoboUIListenerFn  fn,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_add_listener_full</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *id,BonoboUIListenerFn  fn,gpointer            user_data,GDestroyNotify      destroy_fn
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_remove_listener</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *cname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_remove_listener_by_func</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,BonoboUIListenerFn  fn
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_remove_listener_by_data</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,const char         *xml,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_translate</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,const char         *xml,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_tree</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,BonoboUINode       *node,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_rm</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_path_exists</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIComponent  *component,const char         *path,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get</NAME>
<RETURNS>CORBA_char         *</RETURNS>
BonoboUIComponent  *component,const char         *path,gboolean            recurse,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get_tree</NAME>
<RETURNS>BonoboUINode       *</RETURNS>
BonoboUIComponent  *component,const char         *path,gboolean            recurse,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_object_set</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,Bonobo_Unknown      control,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_object_get</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboUIComponent  *component,const char         *path,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_freeze</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_thaw</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_prop</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,const char         *prop,const char         *value,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get_prop</NAME>
<RETURNS>gchar              *</RETURNS>
BonoboUIComponent  *component,const char         *path,const char         *prop,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_status</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *text,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get_epv</NAME>
<RETURNS>POA_Bonobo_UIComponent__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_corba_object_create</NAME>
<RETURNS>Bonobo_UIComponent  </RETURNS>
BonoboObject *object
</FUNCTION>
<STRUCT>
<NAME>BonoboUIVerb</NAME>
typedef struct {
	char          *cname;
	BonoboUIVerbFn cb;
	gpointer       user_data;
	gpointer       dummy;
} BonoboUIVerb;
</STRUCT>
<MACRO>
<NAME>BONOBO_UI_VERB</NAME>
#define BONOBO_UI_VERB(name,cb)                  { (name), (cb), NULL   }
</MACRO>
<MACRO>
<NAME>BONOBO_UI_VERB_DATA</NAME>
#define BONOBO_UI_VERB_DATA(name,cb,data)        { (name), (cb), (data) }
</MACRO>
<MACRO>
<NAME>BONOBO_UI_UNSAFE_VERB</NAME>
#define BONOBO_UI_UNSAFE_VERB(name,cb)           { (name), ((BonoboUIVerbFn)(cb)), NULL   }
</MACRO>
<MACRO>
<NAME>BONOBO_UI_UNSAFE_VERB_DATA</NAME>
#define BONOBO_UI_UNSAFE_VERB_DATA(name,cb,data) { (name), ((BonoboUIVerbFn)(cb)), (data) }
</MACRO>
<MACRO>
<NAME>BONOBO_UI_VERB_END</NAME>
#define BONOBO_UI_VERB_END                       { NULL, NULL, NULL }
</MACRO>
<FUNCTION>
<NAME>bonobo_ui_component_add_verb_list</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,BonoboUIVerb       *list
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_add_verb_list_with_data</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,BonoboUIVerb       *list,gpointer            user_data
</FUNCTION>
<MACRO>
<NAME>BONOBO_UI_CONTAINER_TYPE</NAME>
#define BONOBO_UI_CONTAINER_TYPE        (bonobo_ui_container_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_CONTAINER</NAME>
#define BONOBO_UI_CONTAINER(o)          (GTK_CHECK_CAST ((o), BONOBO_UI_CONTAINER_TYPE, BonoboUIContainer))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_CONTAINER_CLASS</NAME>
#define BONOBO_UI_CONTAINER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_UI_CONTAINER_TYPE, BonoboUIContainerClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_CONTAINER</NAME>
#define BONOBO_IS_UI_CONTAINER(o)       (GTK_CHECK_TYPE ((o), BONOBO_UI_CONTAINER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_CONTAINER_CLASS</NAME>
#define BONOBO_IS_UI_CONTAINER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_UI_CONTAINER_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboUIContainer</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIContainerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIContainer</NAME>
struct BonoboUIContainer {
	BonoboObject base;

	int          flags;
	BonoboWindow   *win;
};
</STRUCT>
<STRUCT>
<NAME>BonoboUIContainerClass</NAME>
struct BonoboUIContainerClass {
	BonoboObjectClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_ui_container_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_container_get_epv</NAME>
<RETURNS>POA_Bonobo_UIContainer__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_container_corba_object_create</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboObject       *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_container_construct</NAME>
<RETURNS>BonoboUIContainer            *</RETURNS>
BonoboUIContainer  *container,Bonobo_UIContainer  corba_container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_container_new</NAME>
<RETURNS>BonoboUIContainer            *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_container_set_win</NAME>
<RETURNS>void  </RETURNS>
BonoboUIContainer  *container,BonoboWindow          *win
</FUNCTION>
<STRUCT>
<NAME>BonoboUINode</NAME>
</STRUCT>
<FUNCTION>
<NAME>bonobo_ui_node_new</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
const char   *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_new_child</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
BonoboUINode *parent,const char   *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_copy</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
BonoboUINode *node,gboolean      recursive
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_free</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_set_data</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *node,gpointer      data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_get_data</NAME>
<RETURNS>gpointer  </RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_set_attr</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *node,const char   *name,const char   *value
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_get_attr</NAME>
<RETURNS>char  *</RETURNS>
BonoboUINode *node,const char   *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_has_attr</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUINode *node,const char   *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_remove_attr</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *node,const char   *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_add_child</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *parent,BonoboUINode *child
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_insert_before</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *sibling,BonoboUINode *prev_sibling
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_unlink</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_replace</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *old_node,BonoboUINode *new_node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_set_content</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *node,const char   *content
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_get_content</NAME>
<RETURNS>char          *</RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_next</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_prev</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_children</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_parent</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_get_name</NAME>
<RETURNS>const char    *</RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_has_name</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUINode *node,const char   *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_transparent</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_copy_attrs</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *src,BonoboUINode *dest
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_free_string</NAME>
<RETURNS>void  </RETURNS>
char *str
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_to_string</NAME>
<RETURNS>char  *</RETURNS>
BonoboUINode *node,gboolean      recurse
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_from_string</NAME>
<RETURNS>BonoboUINode *</RETURNS>
const char *str
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_from_file</NAME>
<RETURNS>BonoboUINode *</RETURNS>
const char *filename
</FUNCTION>
<MACRO>
<NAME>BONOBO_TYPE_UI_TOOLBAR_BUTTON_ITEM</NAME>
#define BONOBO_TYPE_UI_TOOLBAR_BUTTON_ITEM		(bonobo_ui_toolbar_button_item_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_BUTTON_ITEM</NAME>
#define BONOBO_UI_TOOLBAR_BUTTON_ITEM(obj)		(GTK_CHECK_CAST ((obj), BONOBO_TYPE_UI_TOOLBAR_BUTTON_ITEM, BonoboUIToolbarButtonItem))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_BUTTON_ITEM_CLASS</NAME>
#define BONOBO_UI_TOOLBAR_BUTTON_ITEM_CLASS(klass)	(GTK_CHECK_CLASS_CAST ((klass), BONOBO_TYPE_UI_TOOLBAR_BUTTON_ITEM, BonoboUIToolbarButtonItemClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_TOOLBAR_BUTTON_ITEM</NAME>
#define BONOBO_IS_UI_TOOLBAR_BUTTON_ITEM(obj)		(GTK_CHECK_TYPE ((obj), BONOBO_TYPE_UI_TOOLBAR_BUTTON_ITEM))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_TOOLBAR_BUTTON_ITEM_CLASS</NAME>
#define BONOBO_IS_UI_TOOLBAR_BUTTON_ITEM_CLASS(klass)	(GTK_CHECK_CLASS_TYPE ((obj), BONOBO_TYPE_UI_TOOLBAR_BUTTON_ITEM))
</MACRO>
<STRUCT>
<NAME>BonoboUIToolbarButtonItem</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIToolbarButtonItemPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIToolbarButtonItemClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIToolbarButtonItem</NAME>
struct BonoboUIToolbarButtonItem {
	BonoboUIToolbarItem parent;

	BonoboUIToolbarButtonItemPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboUIToolbarButtonItemClass</NAME>
struct BonoboUIToolbarButtonItemClass {
	BonoboUIToolbarItemClass parent_class;

	/* Virtual methods */
	void (* set_icon)       (BonoboUIToolbarButtonItem *button_item,
				 GdkPixbuf                 *icon);
	void (* set_label)      (BonoboUIToolbarButtonItem *button_item,
				 const char                *label);

	/* Signals.  */
	void (* clicked)	(BonoboUIToolbarButtonItem *toolbar_button_item);
	void (* set_want_label) (BonoboUIToolbarButtonItem *toolbar_button_item);
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_ui_toolbar_button_item_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_button_item_construct</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarButtonItem *item,GtkButton                 *button_widget,GdkPixbuf                 *icon,const char                *label
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_button_item_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GdkPixbuf                 *icon,const char                *label
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_button_item_set_icon</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarButtonItem *button_item,GdkPixbuf                 *icon
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_button_item_set_label</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarButtonItem *button_item,const char                *label
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_button_item_get_button_widget</NAME>
<RETURNS>GtkButton  *</RETURNS>
BonoboUIToolbarButtonItem *button_item
</FUNCTION>
<ENUM>
<NAME>BonoboUIToolbarIconDrawMode</NAME>
typedef enum {
        /* update struct when adding enum values */
	BONOBO_UI_TOOLBAR_ICON_SIMPLE, /* No alpha blending */
	BONOBO_UI_TOOLBAR_ICON_COLOR   /* */
} BonoboUIToolbarIconDrawMode;
</ENUM>
<MACRO>
<NAME>BONOBO_TYPE_UI_TOOLBAR_ICON</NAME>
#define BONOBO_TYPE_UI_TOOLBAR_ICON            (bonobo_ui_toolbar_icon_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_ICON</NAME>
#define BONOBO_UI_TOOLBAR_ICON(obj)            (GTK_CHECK_CAST ((obj), BONOBO_TYPE_UI_TOOLBAR_ICON, BonoboUIToolbarIcon))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_ICON_CLASS</NAME>
#define BONOBO_UI_TOOLBAR_ICON_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), BONOBO_TYPE_UI_TOOLBAR_ICON, BonoboUIToolbarIconClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_TOOLBAR_ICON</NAME>
#define BONOBO_IS_UI_TOOLBAR_ICON(obj)         (GTK_CHECK_TYPE ((obj), BONOBO_TYPE_UI_TOOLBAR_ICON))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_TOOLBAR_ICON_CLASS</NAME>
#define BONOBO_IS_UI_TOOLBAR_ICON_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), BONOBO_TYPE_UI_TOOLBAR_ICON))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_ICON_GET_CLASS</NAME>
#define BONOBO_UI_TOOLBAR_ICON_GET_CLASS(obj)  (GTK_CHECK_GET_CLASS ((obj), BONOBO_TYPE_UI_TOOLBAR_ICON, BonoboUIToolbarIconClass))
</MACRO>
<STRUCT>
<NAME>BonoboUIToolbarIcon</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIToolbarIconClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIToolbarIcon</NAME>
struct BonoboUIToolbarIcon {
	GtkMisc misc;

        /* NOTE. In the old BonoboUIToolbarIcon, _lots_ of people were using BonoboUIToolbarIcon to
	 * load images, sucking out the pixmap field, and then not using the
	 * BonoboUIToolbarIcon as a widget at all. IF YOU DO THIS I WILL PERSONALLY
	 * KICK YOUR ASS. Use gdk_pixbuf_new_from_file(). Thank you.
	 * These are PRIVATE FIELDS which I will gratuitously change just to
	 * break your broken code.
	 *                          -  hp + jrb + quartic + Jesse Ventura + GW Bush 
	 */

	GdkPixbuf *provided_image;

        struct {
                GdkPixbuf *pixbuf;
                GdkBitmap *mask;
		gfloat saturation;
		gboolean pixelate;
        } provided[5]; /* the five states */

	GdkPixbuf *generated_scaled_image;
	GdkBitmap *generated_scaled_mask;
        
        struct {
                GdkPixbuf *pixbuf;
                GdkBitmap *mask;
        } generated[5]; /* the five states */
        
	gint width, height;
	gint alpha_threshold;

	BonoboUIToolbarIconDrawMode mode : 2;
};
</STRUCT>
<STRUCT>
<NAME>BonoboUIToolbarIconClass</NAME>
struct BonoboUIToolbarIconClass {
	GtkMiscClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_new_from_file</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar  *filename
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_new_from_file_at_size</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar  *filename,gint          width,gint          height
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_new_from_xpm_d</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar **xpm_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_new_from_xpm_d_at_size</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar **xpm_data,gint          width,gint          height
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_new_from_pixbuf</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GdkPixbuf    *pixbuf
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_new_from_pixbuf_at_size</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GdkPixbuf    *pixbuf,gint          width,gint          height
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_set_pixbuf_size</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap,gint                 width,gint                 height
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_get_pixbuf_size</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap,gint                *width,gint                *height
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_set_pixbuf</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap,GdkPixbuf           *pixbuf
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_get_pixbuf</NAME>
<RETURNS>GdkPixbuf  *</RETURNS>
BonoboUIToolbarIcon *gpixmap
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_set_pixbuf_at_state</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap,GtkStateType         state,GdkPixbuf           *pixbuf,GdkBitmap           *mask
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_set_state_pixbufs</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap,GdkPixbuf           *pixbufs[5],GdkBitmap           *masks[5]
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_set_draw_vals</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap,GtkStateType         state,gfloat               saturation,gboolean             pixelate
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_get_draw_vals</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap,GtkStateType         state,gfloat              *saturation,gboolean            *pixelate
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_set_draw_mode</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon          *gpixmap,BonoboUIToolbarIconDrawMode   mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_get_draw_mode</NAME>
<RETURNS>BonoboUIToolbarIconDrawMode  </RETURNS>
BonoboUIToolbarIcon          *gpixmap
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_clear</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_set_alpha_threshold</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap,gint                 alpha_threshold
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_get_alpha_threshold</NAME>
<RETURNS>gint  </RETURNS>
BonoboUIToolbarIcon *gpixmap
</FUNCTION>
<MACRO>
<NAME>BONOBO_TYPE_UI_TOOLBAR_ITEM</NAME>
#define BONOBO_TYPE_UI_TOOLBAR_ITEM			(bonobo_ui_toolbar_item_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_ITEM</NAME>
#define BONOBO_UI_TOOLBAR_ITEM(obj)			(GTK_CHECK_CAST ((obj), BONOBO_TYPE_UI_TOOLBAR_ITEM, BonoboUIToolbarItem))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_ITEM_CLASS</NAME>
#define BONOBO_UI_TOOLBAR_ITEM_CLASS(klass)		(GTK_CHECK_CLASS_CAST ((klass), BONOBO_TYPE_UI_TOOLBAR_ITEM, BonoboUIToolbarItemClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_TOOLBAR_ITEM</NAME>
#define BONOBO_IS_UI_TOOLBAR_ITEM(obj)			(GTK_CHECK_TYPE ((obj), BONOBO_TYPE_UI_TOOLBAR_ITEM))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_TOOLBAR_ITEM_CLASS</NAME>
#define BONOBO_IS_UI_TOOLBAR_ITEM_CLASS(klass)		(GTK_CHECK_CLASS_TYPE ((obj), BONOBO_TYPE_UI_TOOLBAR_ITEM))
</MACRO>
<ENUM>
<NAME>BonoboUIToolbarItemStyle</NAME>
typedef enum {
	BONOBO_UI_TOOLBAR_ITEM_STYLE_ICON_AND_TEXT_VERTICAL,
	BONOBO_UI_TOOLBAR_ITEM_STYLE_ICON_AND_TEXT_HORIZONTAL,
	BONOBO_UI_TOOLBAR_ITEM_STYLE_ICON_ONLY,
	BONOBO_UI_TOOLBAR_ITEM_STYLE_TEXT_ONLY
} BonoboUIToolbarItemStyle;
</ENUM>
<STRUCT>
<NAME>BonoboUIToolbarItem</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIToolbarItemPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIToolbarItemClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIToolbarItem</NAME>
struct BonoboUIToolbarItem {
	GtkBin parent;

	BonoboUIToolbarItemPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboUIToolbarItemClass</NAME>
struct BonoboUIToolbarItemClass {
	GtkBinClass parent_class;

	/* Virtual method */
	void (* set_state)       (BonoboUIToolbarItem     *item,
				  const char              *new_state);
	void (* set_tooltip)     (BonoboUIToolbarItem     *item,
				  GtkTooltips             *tooltips,
				  const char              *tooltip);

	/* Signals */
	void (* set_orientation) (BonoboUIToolbarItem     *item,
				  GtkOrientation           orientation);
	void (* set_style)       (BonoboUIToolbarItem     *item,
				  BonoboUIToolbarItemStyle style);
	void (* set_want_label)  (BonoboUIToolbarItem     *item,
				  gboolean                 want_label);
	/* Notifies that the state changed, and what it changed to */
	void (* state_altered)   (BonoboUIToolbarItem     *item,
				  const char              *new_state);
	void (* activate)        (BonoboUIToolbarItem     *item);
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_new</NAME>
<RETURNS>GtkWidget                 *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_tooltip</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem      *item,GtkTooltips              *tooltips,const char               *tooltip
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_state</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem      *item,const char               *new_state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_orientation</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem      *item,GtkOrientation            orientation
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_get_orientation</NAME>
<RETURNS>GtkOrientation  </RETURNS>
BonoboUIToolbarItem      *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_style</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem      *item,BonoboUIToolbarItemStyle  style
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_get_style</NAME>
<RETURNS>BonoboUIToolbarItemStyle  </RETURNS>
BonoboUIToolbarItem      *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_minimum_width</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIToolbarItem *item,int minimum_width
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_tooltip</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem     *item,GtkTooltips             *tooltips,const char              *tooltip
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_state</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem     *item,const char              *new_state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_orientation</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem     *item,GtkOrientation           orientation
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_get_orientation</NAME>
<RETURNS>GtkOrientation  </RETURNS>
BonoboUIToolbarItem     *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_style</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem     *item,BonoboUIToolbarItemStyle style
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_get_style</NAME>
<RETURNS>BonoboUIToolbarItemStyle  </RETURNS>
BonoboUIToolbarItem     *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_want_label</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem      *button_item,gboolean                  prefer_text
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_get_want_label</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIToolbarItem      *button_item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_expandable</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem      *button_item,gboolean                  expandable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_get_expandable</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIToolbarItem      *button_item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_pack_end</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem      *button_item,gboolean                  expandable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_get_pack_end</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIToolbarItem      *button_item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_activate</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem     *item
</FUNCTION>
<MACRO>
<NAME>BONOBO_TYPE_UI_TOOLBAR_TOGGLE_BUTTON_ITEM</NAME>
#define BONOBO_TYPE_UI_TOOLBAR_TOGGLE_BUTTON_ITEM             (bonobo_ui_toolbar_toggle_button_item_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_TOGGLE_BUTTON_ITEM</NAME>
#define BONOBO_UI_TOOLBAR_TOGGLE_BUTTON_ITEM(obj)             (GTK_CHECK_CAST ((obj), BONOBO_TYPE_UI_TOOLBAR_TOGGLE_BUTTON_ITEM, BonoboUIToolbarToggleButtonItem))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_TOGGLE_BUTTON_ITEM_CLASS</NAME>
#define BONOBO_UI_TOOLBAR_TOGGLE_BUTTON_ITEM_CLASS(klass)     (GTK_CHECK_CLASS_CAST ((klass), BONOBO_TYPE_UI_TOOLBAR_TOGGLE_BUTTON_ITEM, BonoboUIToolbarToggleButtonItemClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_TOOLBAR_TOGGLE_BUTTON_ITEM</NAME>
#define BONOBO_IS_UI_TOOLBAR_TOGGLE_BUTTON_ITEM(obj)          (GTK_CHECK_TYPE ((obj), BONOBO_TYPE_UI_TOOLBAR_TOGGLE_BUTTON_ITEM))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_TOOLBAR_TOGGLE_BUTTON_ITEM_CLASS</NAME>
#define BONOBO_IS_UI_TOOLBAR_TOGGLE_BUTTON_ITEM_CLASS(klass)  (GTK_CHECK_CLASS_TYPE ((obj), BONOBO_TYPE_UI_TOOLBAR_TOGGLE_BUTTON_ITEM))
</MACRO>
<STRUCT>
<NAME>BonoboUIToolbarToggleButtonItem</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIToolbarToggleButtonItemPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIToolbarToggleButtonItemClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIToolbarToggleButtonItem</NAME>
struct BonoboUIToolbarToggleButtonItem {
	BonoboUIToolbarButtonItem parent;
};
</STRUCT>
<STRUCT>
<NAME>BonoboUIToolbarToggleButtonItemClass</NAME>
struct BonoboUIToolbarToggleButtonItemClass {
	BonoboUIToolbarButtonItemClass parent_class;

	void (* toggled) (BonoboUIToolbarToggleButtonItem *toggle_button_item);
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_ui_toolbar_toggle_button_item_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_toggle_button_item_construct</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarToggleButtonItem *toggle_button_item,GdkPixbuf                     *icon,const char                    *label
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_toggle_button_item_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GdkPixbuf                     *icon,const char                    *label
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_toggle_button_item_set_active</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarToggleButtonItem *item,gboolean                       active
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_toggle_button_item_get_active</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIToolbarToggleButtonItem *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_build_skeleton</NAME>
<RETURNS>void  </RETURNS>
BonoboUIXml  *xml
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_pixbuf_to_xml</NAME>
<RETURNS>char       *</RETURNS>
GdkPixbuf    *pixbuf
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_to_pixbuf</NAME>
<RETURNS>GdkPixbuf  *</RETURNS>
const char *xml
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_get_icon_pixbuf</NAME>
<RETURNS>GdkPixbuf  *</RETURNS>
BonoboUINode *node, gboolean prepend_menu
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_get_icon_pixmap_widget</NAME>
<RETURNS>GtkWidget  *</RETURNS>
BonoboUINode *node, gboolean prepend_menu
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_set_pixbuf</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode  *node,GdkPixbuf     *pixbuf
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_set_pix_xpm</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode  *node,const char   **xpm
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_set_pix_stock</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode  *node,const char    *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_set_pix_fname</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode  *node,const char    *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_build_help_menu</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent *listener,const char        *app_prefix,const char        *app_name,BonoboUINode      *parent
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_build_accel</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
guint              accelerator_key,GdkModifierType    accelerator_mods,const char        *verb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_new_menu</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
gboolean           submenu,const char        *name,const char        *label,const char        *tip,const char        *verb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_new_placeholder</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
const char        *name,gboolean           top,gboolean           bottom
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_set_radiogroup</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode           *node,const char        *group_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_set_toggle</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode           *node,const char        *id,const char        *init_state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_new_std_toolbar</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
const char        *name,const char        *label,const char        *tip,const char        *verb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_new_toggle_toolbar</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
const char        *name,const char        *label,const char        *tip,const char        *id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_get_ui_fname</NAME>
<RETURNS>char       *</RETURNS>
const char        *component_prefix,const char        *file_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_translate_ui</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode      *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_fixup_help</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent *component,BonoboUINode      *node,const char        *app_prefix,const char        *app_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_new_ui</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
BonoboUIComponent *component,const char        *fname,const char        *app_prefix,const char        *app_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_set_ui</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent *component,const char        *app_prefix,const char        *file_name,const char        *app_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_set_pixbuf</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent *component,const char        *path,GdkPixbuf         *pixbuf
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_accel_name</NAME>
<RETURNS>gchar           *</RETURNS>
guint              accelerator_key,GdkModifierType    accelerator_mods
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_accel_parse</NAME>
<RETURNS>void  </RETURNS>
char              *name,guint             *accelerator_key,GdkModifierType   *accelerator_mods
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_decode_str</NAME>
<RETURNS>char            *</RETURNS>
const char *str, gboolean *err
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_encode_str</NAME>
<RETURNS>char            *</RETURNS>
const char *str
</FUNCTION>
<MACRO>
<NAME>BONOBO_UI_XML_TYPE</NAME>
#define BONOBO_UI_XML_TYPE        (bonobo_ui_xml_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_XML</NAME>
#define BONOBO_UI_XML(o)          (GTK_CHECK_CAST ((o), BONOBO_UI_XML_TYPE, BonoboUIXml))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_XML_CLASS</NAME>
#define BONOBO_UI_XML_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_UI_XML_TYPE, BonoboUIXmlClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_XML</NAME>
#define BONOBO_IS_UI_XML(o)       (GTK_CHECK_TYPE ((o), BONOBO_UI_XML_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_XML_CLASS</NAME>
#define BONOBO_IS_UI_XML_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_UI_XML_TYPE))
</MACRO>
<ENUM>
<NAME>BonoboUIXmlError</NAME>
typedef enum {
	BONOBO_UI_XML_OK,
	BONOBO_UI_XML_BAD_PARAM,
	BONOBO_UI_XML_INVALID_PATH,
	BONOBO_UI_XML_INVALID_XML
} BonoboUIXmlError;
</ENUM>
<STRUCT>
<NAME>BonoboUIXml</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIXmlData</NAME>
typedef struct {
	gpointer id;
	gboolean dirty;
	GSList  *overridden;
} BonoboUIXmlData;
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboUIXmlCompareFn</NAME>
<RETURNS>gboolean </RETURNS>
gpointer         id_a,
						    gpointer         id_b
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboUIXmlDataNewFn</NAME>
<RETURNS>BonoboUIXmlData *</RETURNS>
void
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboUIXmlDataFreeFn</NAME>
<RETURNS>void </RETURNS>
BonoboUIXmlData *data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboUIXmlDumpFn</NAME>
<RETURNS>void </RETURNS>
BonoboUIXml      *tree,
						    BonoboUINode     *node
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboUIXmlAddNode</NAME>
<RETURNS>void </RETURNS>
BonoboUINode     *parent,
						    BonoboUINode     *child
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboUIXml</NAME>
struct BonoboUIXml {
	GtkObject              object;

	BonoboUIXmlCompareFn   compare;
	BonoboUIXmlDataNewFn   data_new;
	BonoboUIXmlDataFreeFn  data_free;
	BonoboUIXmlDumpFn      dump;
	BonoboUIXmlAddNode     add_node;

	BonoboUINode          *root;
	
	gpointer               dummy;
};
</STRUCT>
<STRUCT>
<NAME>BonoboUIXmlClass</NAME>
typedef struct {
	GtkObjectClass         object_klass;

	void                 (*override)          (BonoboUINode *node);
	void                 (*replace_override)  (BonoboUINode *new_node,
						   BonoboUINode *old_node);
	void                 (*reinstate)         (BonoboUINode *node);
	void                 (*rename)            (BonoboUINode *node);
	void                 (*remove)            (BonoboUINode *node);

	gpointer               dummy;
} BonoboUIXmlClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_ui_xml_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_new</NAME>
<RETURNS>BonoboUIXml      *</RETURNS>
BonoboUIXmlCompareFn  compare,BonoboUIXmlDataNewFn  data_new,BonoboUIXmlDataFreeFn data_free,BonoboUIXmlDumpFn     dump,BonoboUIXmlAddNode    add_node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_get_data</NAME>
<RETURNS>gpointer  </RETURNS>
BonoboUIXml  *tree,BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_set_dirty</NAME>
<RETURNS>void  </RETURNS>
BonoboUIXml  *tree,BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_clean</NAME>
<RETURNS>void  </RETURNS>
BonoboUIXml  *tree,BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_get_path</NAME>
<RETURNS>BonoboUINode     *</RETURNS>
BonoboUIXml  *tree,const char   *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_get_path_wildcard</NAME>
<RETURNS>BonoboUINode     *</RETURNS>
BonoboUIXml  *tree,const char   *path,gboolean     *wildcard
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_make_path</NAME>
<RETURNS>char             *</RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_get_parent_path</NAME>
<RETURNS>char             *</RETURNS>
const char   *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_merge</NAME>
<RETURNS>BonoboUIXmlError  </RETURNS>
BonoboUIXml  *tree,const char   *path,BonoboUINode *nodes,gpointer      id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_rm</NAME>
<RETURNS>BonoboUIXmlError  </RETURNS>
BonoboUIXml  *tree,const char   *path,gpointer      id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_dump</NAME>
<RETURNS>void  </RETURNS>
BonoboUIXml  *tree,BonoboUINode *node,const char   *msg
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_strip</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode **node
</FUNCTION>
<MACRO>
<NAME>BONOBO_VIEW_FRAME_TYPE</NAME>
#define BONOBO_VIEW_FRAME_TYPE        (bonobo_view_frame_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_VIEW_FRAME</NAME>
#define BONOBO_VIEW_FRAME(o)          (GTK_CHECK_CAST ((o), BONOBO_VIEW_FRAME_TYPE, BonoboViewFrame))
</MACRO>
<MACRO>
<NAME>BONOBO_VIEW_FRAME_CLASS</NAME>
#define BONOBO_VIEW_FRAME_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_VIEW_FRAME_TYPE, BonoboViewFrameClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_VIEW_FRAME</NAME>
#define BONOBO_IS_VIEW_FRAME(o)       (GTK_CHECK_TYPE ((o), BONOBO_VIEW_FRAME_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_VIEW_FRAME_CLASS</NAME>
#define BONOBO_IS_VIEW_FRAME_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_VIEW_FRAME_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboViewFramePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboViewFrame</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboViewFrame</NAME>
struct BonoboViewFrame {
	BonoboControlFrame	 base;
	BonoboViewFramePrivate	*priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboViewFrameClass</NAME>
typedef struct {
	BonoboControlFrameClass parent_class;

	/*
	 * Signals.
	 */
	void (*user_activate)       (BonoboViewFrame *view_frame);
	void (*user_context)        (BonoboViewFrame *view_frame);
} BonoboViewFrameClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_view_frame_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_construct</NAME>
<RETURNS>BonoboViewFrame            *</RETURNS>
BonoboViewFrame   *view_frame,Bonobo_ViewFrame   corba_view_frame,BonoboClientSite  *client_site,Bonobo_UIContainer uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_new</NAME>
<RETURNS>BonoboViewFrame            *</RETURNS>
BonoboClientSite *client_site,Bonobo_Unknown    uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_bind_to_view</NAME>
<RETURNS>void  </RETURNS>
BonoboViewFrame  *view_frame,Bonobo_View       view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_get_view</NAME>
<RETURNS>Bonobo_View  </RETURNS>
BonoboViewFrame  *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_get_client_site</NAME>
<RETURNS>BonoboClientSite           *</RETURNS>
BonoboViewFrame  *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_get_wrapper</NAME>
<RETURNS>GtkWidget                  *</RETURNS>
BonoboViewFrame  *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_set_covered</NAME>
<RETURNS>void  </RETURNS>
BonoboViewFrame  *view_frame,gboolean          covered
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_get_ui_container</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboViewFrame *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_view_activate</NAME>
<RETURNS>void  </RETURNS>
BonoboViewFrame  *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_view_deactivate</NAME>
<RETURNS>void  </RETURNS>
BonoboViewFrame  *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_set_zoom_factor</NAME>
<RETURNS>void  </RETURNS>
BonoboViewFrame  *view_frame,double            zoom
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_get_epv</NAME>
<RETURNS>POA_Bonobo_ViewFrame__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_VIEW_TYPE</NAME>
#define BONOBO_VIEW_TYPE        (bonobo_view_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_VIEW</NAME>
#define BONOBO_VIEW(o)          (GTK_CHECK_CAST ((o), BONOBO_VIEW_TYPE, BonoboView))
</MACRO>
<MACRO>
<NAME>BONOBO_VIEW_CLASS</NAME>
#define BONOBO_VIEW_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_VIEW_TYPE, BonoboViewClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_VIEW</NAME>
#define BONOBO_IS_VIEW(o)       (GTK_CHECK_TYPE ((o), BONOBO_VIEW_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_VIEW_CLASS</NAME>
#define BONOBO_IS_VIEW_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_VIEW_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboView</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboViewPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboViewClass</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_VIEW_VERB_FUNC</NAME>
#define BONOBO_VIEW_VERB_FUNC(fn) ((BonoboViewVerbFunc)(fn))
</MACRO>
<USER_FUNCTION>
<NAME>BonoboViewVerbFunc</NAME>
<RETURNS>void </RETURNS>
BonoboView *view, const char *verb_name, void *user_data
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboView</NAME>
struct BonoboView {
	BonoboControl base;

	BonoboEmbeddable  *embeddable;
	Bonobo_ViewFrame   view_frame;
	BonoboViewPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboViewClass</NAME>
struct BonoboViewClass {
	BonoboControlClass parent_class;

	/*
	 * Signals
	 */
	void (*do_verb)                  (BonoboView *view,
					  const CORBA_char *verb_name);
	void (*set_zoom_factor)          (BonoboView *view, double zoom);
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_view_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_construct</NAME>
<RETURNS>BonoboView            *</RETURNS>
BonoboView         *view,Bonobo_View         corba_view,GtkWidget          *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_new</NAME>
<RETURNS>BonoboView            *</RETURNS>
GtkWidget          *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_corba_object_create</NAME>
<RETURNS>Bonobo_View  </RETURNS>
BonoboObject       *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_set_embeddable</NAME>
<RETURNS>void  </RETURNS>
BonoboView         *view,BonoboEmbeddable   *embeddable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_embeddable</NAME>
<RETURNS>BonoboEmbeddable      *</RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_set_view_frame</NAME>
<RETURNS>void  </RETURNS>
BonoboView         *view,Bonobo_ViewFrame    view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_view_frame</NAME>
<RETURNS>Bonobo_ViewFrame  </RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_remote_ui_container</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_ui_component</NAME>
<RETURNS>BonoboUIComponent     *</RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_activate_notify</NAME>
<RETURNS>void  </RETURNS>
BonoboView         *view,gboolean            activated
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_epv</NAME>
<RETURNS>POA_Bonobo_View__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_WIDGET_TYPE</NAME>
#define BONOBO_WIDGET_TYPE        (bonobo_widget_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_WIDGET</NAME>
#define BONOBO_WIDGET(o)          (GTK_CHECK_CAST ((o), BONOBO_WIDGET_TYPE, BonoboWidget))
</MACRO>
<MACRO>
<NAME>BONOBO_WIDGET_CLASS</NAME>
#define BONOBO_WIDGET_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_WIDGET_TYPE, BonoboWidgetClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WIDGET</NAME>
#define BONOBO_IS_WIDGET(o)       (GTK_CHECK_TYPE ((o), BONOBO_WIDGET_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WIDGET_CLASS</NAME>
#define BONOBO_IS_WIDGET_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_WIDGET_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboWidget</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWidgetPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWidget</NAME>
struct BonoboWidget {
	GtkBin		          bin;

	BonoboWidgetPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboWidgetClass</NAME>
typedef struct {
	GtkBinClass	 bin_class;
} BonoboWidgetClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_widget_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_server</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
BonoboWidget     *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_new_control</NAME>
<RETURNS>GtkWidget           *</RETURNS>
const char        *goad_id,Bonobo_UIContainer uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_new_control_from_objref</NAME>
<RETURNS>GtkWidget           *</RETURNS>
Bonobo_Control     control,Bonobo_UIContainer uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_control_frame</NAME>
<RETURNS>BonoboControlFrame  *</RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_new_subdoc</NAME>
<RETURNS>GtkWidget            *</RETURNS>
const char        *object_desc,Bonobo_UIContainer uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_container</NAME>
<RETURNS>BonoboItemContainer  *</RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_client_site</NAME>
<RETURNS>BonoboClientSite     *</RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_view_frame</NAME>
<RETURNS>BonoboViewFrame      *</RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_uih</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_set_property</NAME>
<RETURNS>void  </RETURNS>
BonoboWidget       *control,const char         *first_prop,...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_property</NAME>
<RETURNS>void  </RETURNS>
BonoboWidget       *control,const char         *first_prop,...
</FUNCTION>
<MACRO>
<NAME>BONOBO_TYPE_WINDOW</NAME>
#define BONOBO_TYPE_WINDOW        (bonobo_window_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_WINDOW</NAME>
#define BONOBO_WINDOW(o)          (GTK_CHECK_CAST ((o), BONOBO_TYPE_WINDOW, BonoboWindow))
</MACRO>
<MACRO>
<NAME>BONOBO_WINDOW_CLASS</NAME>
#define BONOBO_WINDOW_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_TYPE_WINDOW, BonoboWindowClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WIN</NAME>
#define BONOBO_IS_WIN(o)       (GTK_CHECK_TYPE ((o), BONOBO_TYPE_WINDOW))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WIN_CLASS</NAME>
#define BONOBO_IS_WIN_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_TYPE_WINDOW))
</MACRO>
<STRUCT>
<NAME>BonoboWindow</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWindowPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWindowClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWindow</NAME>
struct BonoboWindow {
	GtkWindow          parent;
	
	BonoboWindowPrivate  *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboWindowClass</NAME>
struct BonoboWindowClass {
	GtkWindowClass    parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_window_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_construct</NAME>
<RETURNS>GtkWidget            *</RETURNS>
BonoboWindow  *win,const char *win_name,const char *title
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_new</NAME>
<RETURNS>GtkWidget            *</RETURNS>
const char *win_name,const char *title
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_set_contents</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow  *win,GtkWidget  *contents
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_get_contents</NAME>
<RETURNS>GtkWidget            *</RETURNS>
BonoboWindow  *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_freeze</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_thaw</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_set_name</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow  *win,const char *win_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_get_name</NAME>
<RETURNS>char                 *</RETURNS>
BonoboWindow *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_xml_merge</NAME>
<RETURNS>BonoboUIXmlError  </RETURNS>
BonoboWindow  *win,const char *path,const char *xml,const char *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_xml_merge_tree</NAME>
<RETURNS>BonoboUIXmlError  </RETURNS>
BonoboWindow  *win,const char *path,BonoboUINode    *tree,const char *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_xml_get</NAME>
<RETURNS>char                 *</RETURNS>
BonoboWindow  *win,const char *path,gboolean    node_only
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_xml_node_exists</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboWindow  *win,const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_xml_rm</NAME>
<RETURNS>BonoboUIXmlError  </RETURNS>
BonoboWindow  *win,const char *path,const char *by_component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_object_set</NAME>
<RETURNS>BonoboUIXmlError  </RETURNS>
BonoboWindow  *win,const char *path,Bonobo_Unknown object,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_object_get</NAME>
<RETURNS>BonoboUIXmlError  </RETURNS>
BonoboWindow  *win,const char *path,Bonobo_Unknown *object,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_get_accel_group</NAME>
<RETURNS>GtkAccelGroup        *</RETURNS>
BonoboWindow  *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_dump</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow  *win,const char *msg
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_register_component</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow     *win,const char    *name,Bonobo_Unknown component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_deregister_component</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow     *win,const char    *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_component_get</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboWindow     *win,const char    *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_add_popup</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow     *win,GtkMenu       *popup,const char    *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_remove_popup</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow     *win,const char    *path
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_WRAPPER</NAME>
#define GNOME_TYPE_WRAPPER            (bonobo_wrapper_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_WRAPPER</NAME>
#define BONOBO_WRAPPER(obj)            (GTK_CHECK_CAST ((obj), GNOME_TYPE_WRAPPER, BonoboWrapper))
</MACRO>
<MACRO>
<NAME>BONOBO_WRAPPER_CLASS</NAME>
#define BONOBO_WRAPPER_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_WRAPPER, BonoboWrapperClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WRAPPER</NAME>
#define BONOBO_IS_WRAPPER(obj)         (GTK_CHECK_TYPE ((obj), GNOME_TYPE_WRAPPER))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WRAPPER_CLASS</NAME>
#define BONOBO_IS_WRAPPER_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GNOME_TYPE_WRAPPER))
</MACRO>
<STRUCT>
<NAME>BonoboWrapper</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWrapperClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWrapperPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWrapper</NAME>
struct BonoboWrapper {
	GtkBin bin;

	/* Private data. */
	BonoboWrapperPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboWrapperClass</NAME>
struct BonoboWrapperClass {
	GtkBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_wrapper_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_wrapper_new</NAME>
<RETURNS>GtkWidget 	*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_wrapper_set_covered</NAME>
<RETURNS>void 	</RETURNS>
BonoboWrapper *wrapper, gboolean covered
</FUNCTION>
<FUNCTION>
<NAME>bonobo_wrapper_is_covered</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboWrapper *wrapper
</FUNCTION>
<FUNCTION>
<NAME>bonobo_wrapper_get_visibility</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboWrapper *wrapper
</FUNCTION>
<FUNCTION>
<NAME>bonobo_wrapper_set_visibility</NAME>
<RETURNS>void 	</RETURNS>
BonoboWrapper *wrapper, gboolean visible
</FUNCTION>
<MACRO>
<NAME>BONOBO_ZOOMABLE_FRAME_TYPE</NAME>
#define BONOBO_ZOOMABLE_FRAME_TYPE		(bonobo_zoomable_frame_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_ZOOMABLE_FRAME</NAME>
#define BONOBO_ZOOMABLE_FRAME(o)		(GTK_CHECK_CAST ((o), BONOBO_ZOOMABLE_FRAME_TYPE, BonoboZoomableFrame))
</MACRO>
<MACRO>
<NAME>BONOBO_ZOOMABLE_FRAME_CLASS</NAME>
#define BONOBO_ZOOMABLE_FRAME_CLASS(k)		(GTK_CHECK_CLASS_CAST((k), BONOBO_ZOOMABLE_FRAME_TYPE, BonoboZoomableFrameClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_ZOOMABLE_FRAME</NAME>
#define BONOBO_IS_ZOOMABLE_FRAME(o)		(GTK_CHECK_TYPE ((o), BONOBO_ZOOMABLE_FRAME_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_ZOOMABLE_FRAME_CLASS</NAME>
#define BONOBO_IS_ZOOMABLE_FRAME_CLASS(k)	(GTK_CHECK_CLASS_TYPE ((k), BONOBO_ZOOMABLE_FRAME_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboZoomableFrame</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboZoomableFramePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboZoomableFrameClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboZoomableFrame</NAME>
struct BonoboZoomableFrame {
        BonoboObject			object;

	BonoboZoomableFramePrivate	*priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboZoomableFrameClass</NAME>
struct BonoboZoomableFrameClass {
	BonoboObjectClass		parent;

	void (*zoom_level_changed)	(BonoboZoomableFrame *zframe,
					 float zoom_level);
	void (*zoom_parameters_changed)	(BonoboZoomableFrame *zframe);
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_zoomable_frame_get_epv</NAME>
<RETURNS>POA_Bonobo_ZoomableFrame__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_corba_object_create</NAME>
<RETURNS>Bonobo_ZoomableFrame 	</RETURNS>
BonoboObject		*object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_new</NAME>
<RETURNS>BonoboZoomableFrame 	*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_construct</NAME>
<RETURNS>BonoboZoomableFrame 	*</RETURNS>
BonoboZoomableFrame	*zframe,Bonobo_ZoomableFrame	 corba_zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_get_zoom_level</NAME>
<RETURNS>float 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_get_min_zoom_level</NAME>
<RETURNS>float 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_get_max_zoom_level</NAME>
<RETURNS>float 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_has_min_zoom_level</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_has_max_zoom_level</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_is_continuous</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_get_preferred_zoom_levels</NAME>
<RETURNS>GList 		*</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_get_preferred_zoom_level_names</NAME>
<RETURNS>GList 		*</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_set_zoom_level</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomableFrame	*zframe,float			 zoom_level
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_zoom_in</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_zoom_out</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_zoom_to_fit</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_zoom_to_default</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_bind_to_zoomable</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomableFrame	*zframe,Bonobo_Zoomable	 zoomable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_get_zoomable</NAME>
<RETURNS>Bonobo_Zoomable 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<MACRO>
<NAME>BONOBO_ZOOMABLE_TYPE</NAME>
#define BONOBO_ZOOMABLE_TYPE		(bonobo_zoomable_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_ZOOMABLE</NAME>
#define BONOBO_ZOOMABLE(o)		(GTK_CHECK_CAST ((o), BONOBO_ZOOMABLE_TYPE, BonoboZoomable))
</MACRO>
<MACRO>
<NAME>BONOBO_ZOOMABLE_CLASS</NAME>
#define BONOBO_ZOOMABLE_CLASS(k)	(GTK_CHECK_CLASS_CAST((k), BONOBO_ZOOMABLE_TYPE, BonoboZoomableClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_ZOOMABLE</NAME>
#define BONOBO_IS_ZOOMABLE(o)		(GTK_CHECK_TYPE ((o), BONOBO_ZOOMABLE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_ZOOMABLE_CLASS</NAME>
#define BONOBO_IS_ZOOMABLE_CLASS(k)	(GTK_CHECK_CLASS_TYPE ((k), BONOBO_ZOOMABLE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboZoomable</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboZoomablePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboZoomableClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboZoomable</NAME>
struct BonoboZoomable {
        BonoboObject		object;

	BonoboZoomablePrivate	*priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboZoomableClass</NAME>
struct BonoboZoomableClass {
	BonoboObjectClass	parent;

	void (*set_frame)	(BonoboZoomable *zoomable);
	void (*set_zoom_level)	(BonoboZoomable *zoomable,
				 float zoom_level);

	void (*zoom_in)		(BonoboZoomable *zoomable);
	void (*zoom_out)	(BonoboZoomable *zoomable);
	void (*zoom_to_fit)	(BonoboZoomable *zoomable);
	void (*zoom_to_default)	(BonoboZoomable *zoomable);
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_zoomable_get_epv</NAME>
<RETURNS>POA_Bonobo_Zoomable__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_corba_object_create</NAME>
<RETURNS>Bonobo_Zoomable 	</RETURNS>
BonoboObject   *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_new</NAME>
<RETURNS>BonoboZoomable 	*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_construct</NAME>
<RETURNS>BonoboZoomable 	*</RETURNS>
BonoboZoomable	*zoomable,Bonobo_Zoomable corba_zoomable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_set_parameters</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomable	*zoomable,float           zoom_level,float		 min_zoom_level,float		 max_zoom_level,gboolean	 has_min_zoom_level,gboolean	 has_max_zoom_level
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_set_parameters_full</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomable	*zoomable,float           zoom_level,float		 min_zoom_level,float		 max_zoom_level,gboolean	 has_min_zoom_level,gboolean	 has_max_zoom_level,gboolean	 is_continuous,float          *preferred_zoom_levels,const gchar   **preferred_zoom_level_names,gint		 num_preferred_zoom_levels
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_report_zoom_level_changed</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomable	*zoomable,float		 new_zoom_level
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_report_zoom_parameters_changed</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomable	*zoomable
</FUNCTION>
