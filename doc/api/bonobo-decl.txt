<MACRO>
<NAME>BONOBO_OBJECT_TYPE</NAME>
#define BONOBO_OBJECT_TYPE        (bonobo_object_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_OBJECT</NAME>
#define BONOBO_OBJECT(o)          (GTK_CHECK_CAST ((o), BONOBO_OBJECT_TYPE, BonoboObject))
</MACRO>
<MACRO>
<NAME>BONOBO_OBJECT_CLASS</NAME>
#define BONOBO_OBJECT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_OBJECT_TYPE, BonoboObjectClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_OBJECT</NAME>
#define BONOBO_IS_OBJECT(o)       (GTK_CHECK_TYPE ((o), BONOBO_OBJECT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_OBJECT_CLASS</NAME>
#define BONOBO_IS_OBJECT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_OBJECT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboObjectServant</NAME>
typedef struct {
	POA_Bonobo_Unknown servant_placeholder;
	gpointer           bonobo_object;
} BonoboObjectServant;
</STRUCT>
<STRUCT>
<NAME>BonoboObjectPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboObject</NAME>
typedef struct {
	GtkObject            base;

	Bonobo_Unknown       corba_objref;
	gpointer             servant;
	BonoboObjectPrivate *priv;
} BonoboObject;
</STRUCT>
<STRUCT>
<NAME>BonoboObjectClass</NAME>
typedef struct {
	GtkObjectClass parent_class;

	/*
	 * signals.  
	 */
	void  (*query_interface) (BonoboObject *object, const char *repo_id,  CORBA_Object      *retval);
	void  (*system_exception)(BonoboObject *object, CORBA_Object cobject, CORBA_Environment *ev);
	void  (*object_gone)     (BonoboObject *object, CORBA_Object cobject, CORBA_Environment *ev);
} BonoboObjectClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_object_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_construct</NAME>
<RETURNS>BonoboObject             *</RETURNS>
BonoboObject           *object,CORBA_Object            corba_object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_new_from_servant</NAME>
<RETURNS>BonoboObject             *</RETURNS>
void                   *servant
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_from_servant</NAME>
<RETURNS>BonoboObject             *</RETURNS>
PortableServer_Servant  servant
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_bind_to_servant</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object,void                   *servant
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_get_servant</NAME>
<RETURNS>PortableServer_Servant  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_activate_servant</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboObject           *object,void                   *servant
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_add_interface</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object,BonoboObject           *newobj
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_query_local_interface</NAME>
<RETURNS>BonoboObject             *</RETURNS>
BonoboObject           *object,const char             *repo_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_query_interface</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboObject           *object,const char             *repo_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_corba_objref</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_dup_ref</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
Bonobo_Unknown          object,CORBA_Environment      *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_release_unref</NAME>
<RETURNS>void  </RETURNS>
Bonobo_Unknown          object,CORBA_Environment      *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_ref</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_unref</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_get_epv</NAME>
<RETURNS>POA_Bonobo_Unknown__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_trace_refs</NAME>
<RETURNS>void  </RETURNS>
BonoboObject *object,const char   *fn,int           line,gboolean      ref
</FUNCTION>
<MACRO>
<NAME>bonobo_object_ref</NAME>
#	define           bonobo_object_ref(o)   G_STMT_START{bonobo_object_trace_refs((o),G_GNUC_PRETTY_FUNCTION,__LINE__,TRUE);}G_STMT_END
</MACRO>
<MACRO>
<NAME>bonobo_object_unref</NAME>
#	define           bonobo_object_unref(o) G_STMT_START{bonobo_object_trace_refs((o),G_GNUC_PRETTY_FUNCTION,__LINE__,FALSE);}G_STMT_END
</MACRO>
<FUNCTION>
<NAME>bonobo_object_dump_interfaces</NAME>
<RETURNS>void  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_check_env</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object,CORBA_Object            corba_object,CORBA_Environment      *ev
</FUNCTION>
<MACRO>
<NAME>BONOBO_OBJECT_CHECK</NAME>
#define BONOBO_OBJECT_CHECK(o,c,e)	\
			G_STMT_START {				\
			if ((e)->_major != CORBA_NO_EXCEPTION)	\
				bonobo_object_check_env(o,c,e);	\
			} G_STMT_END
</MACRO>
<FUNCTION>
<NAME>gnome_unknown_ping</NAME>
<RETURNS>gboolean  </RETURNS>
Bonobo_Unknown object
</FUNCTION>
<STRUCT>
<NAME>BonoboMonikerPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_MONIKER_TYPE</NAME>
#define BONOBO_MONIKER_TYPE        (bonobo_moniker_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_MONIKER</NAME>
#define BONOBO_MONIKER(o)          (GTK_CHECK_CAST ((o), BONOBO_MONIKER_TYPE, BonoboMoniker))
</MACRO>
<MACRO>
<NAME>BONOBO_MONIKER_CLASS</NAME>
#define BONOBO_MONIKER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_MONIKER_TYPE, BonoboMonikerClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_MONIKER</NAME>
#define BONOBO_IS_MONIKER(o)       (GTK_CHECK_TYPE ((o), BONOBO_MONIKER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_MONIKER_CLASS</NAME>
#define BONOBO_IS_MONIKER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_MONIKER_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboMoniker</NAME>
typedef struct {
        BonoboObject          object;
	
	BonoboMonikerPrivate *priv;
} BonoboMoniker;
</STRUCT>
<STRUCT>
<NAME>BonoboMonikerClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * virtual methods
	 */
	Bonobo_Moniker (*get_parent)         (BonoboMoniker               *moniker,
					      CORBA_Environment           *ev);
	void           (*set_parent)         (BonoboMoniker               *moniker,
					      const Bonobo_Moniker         parent,
					      CORBA_Environment           *ev);
	CORBA_char    *(*get_display_name)   (BonoboMoniker               *moniker,
					      CORBA_Environment           *ev);
	Bonobo_Moniker (*parse_display_name) (BonoboMoniker               *moniker,
					      Bonobo_Moniker               parent,
					      const CORBA_char            *name,
					      CORBA_Environment           *ev);
	Bonobo_Unknown (*resolve)            (BonoboMoniker               *moniker,
					      const Bonobo_ResolveOptions *options,
					      const CORBA_char            *requested_interface,
					      CORBA_Environment           *ev);
} BonoboMonikerClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_moniker_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_get_epv</NAME>
<RETURNS>POA_Bonobo_Moniker__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_corba_object_create</NAME>
<RETURNS>Bonobo_Moniker  </RETURNS>
BonoboObject      *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_get_parent</NAME>
<RETURNS>Bonobo_Moniker  </RETURNS>
BonoboMoniker     *moniker,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_set_parent</NAME>
<RETURNS>void  </RETURNS>
BonoboMoniker     *moniker,Bonobo_Moniker     parent,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_get_name</NAME>
<RETURNS>const char               *</RETURNS>
BonoboMoniker     *moniker,int                char_offset
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_set_name</NAME>
<RETURNS>void  </RETURNS>
BonoboMoniker     *moniker,const char        *name,int                num_chars
</FUNCTION>
<MACRO>
<NAME>BONOBO_EX</NAME>
#define BONOBO_EX(ev) ((ev) && (ev)->_major != CORBA_NO_EXCEPTION)
</MACRO>
<MACRO>
<NAME>BONOBO_RET_EX</NAME>
#define BONOBO_RET_EX(ev)		\
	G_STMT_START			\
		if (BONOBO_EX (ev))	\
			return;		\
	G_STMT_END
</MACRO>
<MACRO>
<NAME>BONOBO_RET_VAL_EX</NAME>
#define BONOBO_RET_VAL_EX(ev,v)		\
	G_STMT_START			\
		if (BONOBO_EX (ev))	\
			return (v);	\
	G_STMT_END
</MACRO>
<USER_FUNCTION>
<NAME>BonoboExceptionFn</NAME>
<RETURNS>char *</RETURNS>
CORBA_Environment *ev, gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>bonobo_exception_get_text</NAME>
<RETURNS>char  *</RETURNS>
CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_exception_add_handler_str</NAME>
<RETURNS>void  </RETURNS>
const char *repo_id,const char *str
</FUNCTION>
<FUNCTION>
<NAME>bonobo_exception_add_handler_fn</NAME>
<RETURNS>void  </RETURNS>
const char *repo_id,BonoboExceptionFn fn,gpointer          user_data,GDestroyNotify    destroy_fn
</FUNCTION>
<MACRO>
<NAME>BONOBO_ITEM_CONTAINER_TYPE</NAME>
#define BONOBO_ITEM_CONTAINER_TYPE        (bonobo_item_container_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_ITEM_CONTAINER</NAME>
#define BONOBO_ITEM_CONTAINER(o)          (GTK_CHECK_CAST ((o), BONOBO_ITEM_CONTAINER_TYPE, BonoboItemContainer))
</MACRO>
<MACRO>
<NAME>BONOBO_ITEM_CONTAINER_CLASS</NAME>
#define BONOBO_ITEM_CONTAINER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_ITEM_CONTAINER_TYPE, BonoboItemContainerClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_ITEM_CONTAINER</NAME>
#define BONOBO_IS_ITEM_CONTAINER(o)       (GTK_CHECK_TYPE ((o), BONOBO_ITEM_CONTAINER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_ITEM_CONTAINER_CLASS</NAME>
#define BONOBO_IS_ITEM_CONTAINER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_ITEM_CONTAINER_TYPE))
</MACRO>
<TYPEDEF>
<NAME>BonoboClientSiteList</NAME>
typedef GList BonoboClientSiteList;
</TYPEDEF>
<STRUCT>
<NAME>BonoboItemContainerPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboItemContainer</NAME>
typedef struct {
	BonoboObject base;

	BonoboClientSiteList *client_sites;
	
	BonoboMoniker *moniker;

	BonoboItemContainerPrivate *priv;
} BonoboItemContainer;
</STRUCT>
<STRUCT>
<NAME>BonoboItemContainerClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	Bonobo_Unknown (*get_object) (BonoboItemContainer *item_container,
				      CORBA_char          *item_name,
				      CORBA_boolean        only_if_exists,
				      CORBA_Environment   *ev);
} BonoboItemContainerClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_item_container_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_container_new</NAME>
<RETURNS>BonoboItemContainer  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_container_construct</NAME>
<RETURNS>BonoboItemContainer  *</RETURNS>
BonoboItemContainer *container,Bonobo_ItemContainer container_corba
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_container_get_moniker</NAME>
<RETURNS>BonoboMoniker        *</RETURNS>
BonoboItemContainer *container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_container_add</NAME>
<RETURNS>void  </RETURNS>
BonoboItemContainer *container,BonoboObject    *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_container_remove</NAME>
<RETURNS>void  </RETURNS>
BonoboItemContainer *container,BonoboObject    *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_container_get_epv</NAME>
<RETURNS>POA_Bonobo_ItemContainer__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_OBJECT_CLIENT_TYPE</NAME>
#define BONOBO_OBJECT_CLIENT_TYPE        (bonobo_object_client_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_OBJECT_CLIENT</NAME>
#define BONOBO_OBJECT_CLIENT(o)          (GTK_CHECK_CAST ((o), BONOBO_OBJECT_CLIENT_TYPE, BonoboObjectClient))
</MACRO>
<MACRO>
<NAME>BONOBO_OBJECT_CLIENT_CLASS</NAME>
#define BONOBO_OBJECT_CLIENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_OBJECT_CLIENT_TYPE, BonoboObjectClientClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_OBJECT_CLIENT</NAME>
#define BONOBO_IS_OBJECT_CLIENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_OBJECT_CLIENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_OBJECT_CLIENT_CLASS</NAME>
#define BONOBO_IS_OBJECT_CLIENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_OBJECT_CLIENT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboObjectClient</NAME>
typedef struct {
	BonoboObject parent;
} BonoboObjectClient;
</STRUCT>
<STRUCT>
<NAME>BonoboObjectClientClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;
} BonoboObjectClientClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_object_client_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_from_corba</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
Bonobo_Unknown o
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_construct</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
BonoboObjectClient *object_client,CORBA_Object corba_object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_activate</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
const char *iid,gint        oaf_flags
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_has_interface</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboObjectClient *object,const char *interface_desc,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_query_interface</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboObjectClient *object,const char *interface_desc,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_ref</NAME>
<RETURNS>void  </RETURNS>
BonoboObjectClient *object_client,BonoboObject       *opt_exception_obj
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_unref</NAME>
<RETURNS>void  </RETURNS>
BonoboObjectClient *object_client,BonoboObject       *opt_exception_obj
</FUNCTION>
<FUNCTION>
<NAME>bonobo_get_object</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
const CORBA_char  *name,const char        *interface_name,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_client_new_from_name</NAME>
<RETURNS>Bonobo_Moniker  </RETURNS>
const CORBA_char  *name,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_client_get_name</NAME>
<RETURNS>CORBA_char          *</RETURNS>
Bonobo_Moniker     moniker,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_client_resolve_default</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
Bonobo_Moniker     moniker,const char        *interface_name,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_client_resolve_client_default</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
Bonobo_Moniker     moniker,const char        *interface_name,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_util_new_from_name_full</NAME>
<RETURNS>Bonobo_Moniker  </RETURNS>
Bonobo_Moniker     parent,const CORBA_char  *name,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_util_get_parent_name</NAME>
<RETURNS>CORBA_char     *</RETURNS>
Bonobo_Moniker     moniker,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_util_qi_return</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
Bonobo_Unknown     object,const CORBA_char  *requested_interface,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_util_seek_std_separator</NAME>
<RETURNS>int  </RETURNS>
const CORBA_char  *str,int                min_idx
</FUNCTION>
<STRUCT>
<NAME>BonoboPropertyListener</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_PROPERTY_LISTENER_TYPE</NAME>
#define BONOBO_PROPERTY_LISTENER_TYPE        (bonobo_property_listener_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PROPERTY_LISTENER</NAME>
#define BONOBO_PROPERTY_LISTENER(o)          (GTK_CHECK_CAST ((o), BONOBO_PROPERTY_LISTENER_TYPE, BonoboPropertyListener))
</MACRO>
<MACRO>
<NAME>BONOBO_PROPERTY_LISTENER_CLASS</NAME>
#define BONOBO_PROPERTY_LISTENER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PROPERTY_LISTENER_TYPE, BonoboPropertyListenerClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROPERTY_LISTENER</NAME>
#define BONOBO_IS_PROPERTY_LISTENER(o)       (GTK_CHECK_TYPE ((o), BONOBO_PROPERTY_LISTENER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROPERTY_LISTENER_CLASS</NAME>
#define BONOBO_IS_PROPERTY_LISTENER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PROPERTY_LISTENER_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPropertyListener</NAME>
struct BonoboPropertyListener {
        BonoboObject		object;
};
</STRUCT>
<STRUCT>
<NAME>BonoboPropertyListenerClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/* Signal definition */
	void (* prop_changed) (BonoboPropertyListener *listener, gchar *name, BonoboArg *event_data);
} BonoboPropertyListenerClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_property_listener_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_listener_get_epv</NAME>
<RETURNS>POA_Bonobo_PropertyListener__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_listener_new</NAME>
<RETURNS>BonoboPropertyListener  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_properties</NAME>
<RETURNS>GList 			*</RETURNS>
Bonobo_PropertyBag       pb,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_free_properties</NAME>
<RETURNS>void  </RETURNS>
GList *list
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_property_names</NAME>
<RETURNS>GList 			*</RETURNS>
Bonobo_PropertyBag       pb,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_property</NAME>
<RETURNS>Bonobo_Property 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *property_name,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_persist</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,Bonobo_Stream            stream,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_depersist</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,Bonobo_Stream            stream,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_setv</NAME>
<RETURNS>char                     *</RETURNS>
Bonobo_PropertyBag       pb,CORBA_Environment       *ev,const char              *first_arg,va_list                  var_args
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_getv</NAME>
<RETURNS>char                     *</RETURNS>
Bonobo_PropertyBag       pb,CORBA_Environment       *ev,const char              *first_arg,va_list                  var_args
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_property_type</NAME>
<RETURNS>CORBA_TypeCode  </RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_gboolean</NAME>
<RETURNS>gboolean 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_gint</NAME>
<RETURNS>gint 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_glong</NAME>
<RETURNS>glong 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_gfloat</NAME>
<RETURNS>gfloat 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_gdouble</NAME>
<RETURNS>gdouble 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_string</NAME>
<RETURNS>char 			*</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_any</NAME>
<RETURNS>BonoboArg 		*</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_gboolean</NAME>
<RETURNS>gboolean 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_gint</NAME>
<RETURNS>gint 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_glong</NAME>
<RETURNS>glong 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_gfloat</NAME>
<RETURNS>gfloat 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_gdouble</NAME>
<RETURNS>gdouble 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_string</NAME>
<RETURNS>char 			*</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_any</NAME>
<RETURNS>BonoboArg 		*</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_gboolean</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,gboolean                value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_gint</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,gint                     value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_glong</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,glong                    value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_gfloat</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,gfloat                   value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_gdouble</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,gdouble                  value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_string</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,const char              *value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_any</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,BonoboArg               *value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_docstring</NAME>
<RETURNS>char 			*</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_flags</NAME>
<RETURNS>BonoboPropertyFlags 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<MACRO>
<NAME>BONOBO_CONTROL_TYPE</NAME>
#define BONOBO_CONTROL_TYPE        (bonobo_control_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_CONTROL</NAME>
#define BONOBO_CONTROL(o)          (GTK_CHECK_CAST ((o), BONOBO_CONTROL_TYPE, BonoboControl))
</MACRO>
<MACRO>
<NAME>BONOBO_CONTROL_CLASS</NAME>
#define BONOBO_CONTROL_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_CONTROL_TYPE, BonoboControlClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTROL</NAME>
#define BONOBO_IS_CONTROL(o)       (GTK_CHECK_TYPE ((o), BONOBO_CONTROL_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTROL_CLASS</NAME>
#define BONOBO_IS_CONTROL_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_CONTROL_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboControl</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboControlPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboControlClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboControl</NAME>
struct BonoboControl {
	BonoboObject base;

	BonoboControlPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboControlClass</NAME>
struct BonoboControlClass {
	BonoboObjectClass parent_class;

	/*
	 * Signals.
	 */
	void (*set_frame)           (BonoboControl *control);
	void (*activate)            (BonoboControl *control, gboolean state);
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_control_new</NAME>
<RETURNS>BonoboControl               *</RETURNS>
GtkWidget     *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_widget</NAME>
<RETURNS>GtkWidget                   *</RETURNS>
BonoboControl *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_automerge</NAME>
<RETURNS>void  </RETURNS>
BonoboControl *control,gboolean       automerge
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_automerge</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboControl *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_property</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,const char          *first_prop,...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_property</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,const char          *first_prop,...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_construct</NAME>
<RETURNS>BonoboControl               *</RETURNS>
BonoboControl       *control,Bonobo_Control       corba_control,GtkWidget           *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_corba_object_create</NAME>
<RETURNS>Bonobo_Control  </RETURNS>
BonoboObject        *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_ui_component</NAME>
<RETURNS>BonoboUIComponent           *</RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_ui_component</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,BonoboUIComponent   *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_remote_ui_container</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_control_frame</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,Bonobo_ControlFrame  control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_control_frame</NAME>
<RETURNS>Bonobo_ControlFrame  </RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_property_bag</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,BonoboPropertyBag   *pb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_property_bag</NAME>
<RETURNS>BonoboPropertyBag           *</RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_ambient_properties</NAME>
<RETURNS>Bonobo_PropertyBag  </RETURNS>
BonoboControl       *control,CORBA_Environment   *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_activate_notify</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,gboolean             activated
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_windowid_from_x11</NAME>
<RETURNS>Bonobo_Control_windowid  </RETURNS>
guint32              x11_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_epv</NAME>
<RETURNS>POA_Bonobo_Control__epv     *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_CONTROL_FRAME_TYPE</NAME>
#define BONOBO_CONTROL_FRAME_TYPE        (bonobo_control_frame_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_CONTROL_FRAME</NAME>
#define BONOBO_CONTROL_FRAME(o)          (GTK_CHECK_CAST ((o), BONOBO_CONTROL_FRAME_TYPE, BonoboControlFrame))
</MACRO>
<MACRO>
<NAME>BONOBO_CONTROL_FRAME_CLASS</NAME>
#define BONOBO_CONTROL_FRAME_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_CONTROL_FRAME_TYPE, BonoboControlFrameClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTROL_FRAME</NAME>
#define BONOBO_IS_CONTROL_FRAME(o)       (GTK_CHECK_TYPE ((o), BONOBO_CONTROL_FRAME_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTROL_FRAME_CLASS</NAME>
#define BONOBO_IS_CONTROL_FRAME_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_CONTROL_FRAME_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboControlFramePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboControlFrame</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboControlFrame</NAME>
struct BonoboControlFrame {
	BonoboObject base;
	BonoboControlFramePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboControlFrameClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * Signals.
	 */
	void (*activated)           (BonoboControlFrame *control_frame, gboolean state);
	void (*activate_uri)        (BonoboControlFrame *control_frame, const char *uri, gboolean relative);

} BonoboControlFrameClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_control_frame_new</NAME>
<RETURNS>BonoboControlFrame            *</RETURNS>
Bonobo_UIContainer   uic
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_widget</NAME>
<RETURNS>GtkWidget                     *</RETURNS>
BonoboControlFrame  *frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_control_activate</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_control_deactivate</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_set_autoactivate</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,gboolean             autoactivate
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_autoactivate</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_control_property_bag</NAME>
<RETURNS>Bonobo_PropertyBag  </RETURNS>
BonoboControlFrame  *control_frame,CORBA_Environment   *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_set_propbag</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,BonoboPropertyBag   *propbag
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_propbag</NAME>
<RETURNS>BonoboPropertyBag             *</RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_control_set_state</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,GtkStateType         state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_set_autostate</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,gboolean             autostate
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_autostate</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_bind_to_control</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,Bonobo_Control       control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_control</NAME>
<RETURNS>Bonobo_Control  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_ui_container</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_construct</NAME>
<RETURNS>BonoboControlFrame            *</RETURNS>
BonoboControlFrame  *control_frame,Bonobo_ControlFrame  corba_control_frame,Bonobo_UIContainer   uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_epv</NAME>
<RETURNS>POA_Bonobo_ControlFrame__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_size_request</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame *control_frame,int *desired_width,int *desired_height
</FUNCTION>
<MACRO>
<NAME>BONOBO_VIEW_TYPE</NAME>
#define BONOBO_VIEW_TYPE        (bonobo_view_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_VIEW</NAME>
#define BONOBO_VIEW(o)          (GTK_CHECK_CAST ((o), BONOBO_VIEW_TYPE, BonoboView))
</MACRO>
<MACRO>
<NAME>BONOBO_VIEW_CLASS</NAME>
#define BONOBO_VIEW_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_VIEW_TYPE, BonoboViewClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_VIEW</NAME>
#define BONOBO_IS_VIEW(o)       (GTK_CHECK_TYPE ((o), BONOBO_VIEW_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_VIEW_CLASS</NAME>
#define BONOBO_IS_VIEW_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_VIEW_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboView</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboViewPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboViewClass</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_VIEW_VERB_FUNC</NAME>
#define BONOBO_VIEW_VERB_FUNC(fn) ((BonoboViewVerbFunc)(fn))
</MACRO>
<USER_FUNCTION>
<NAME>BonoboViewVerbFunc</NAME>
<RETURNS>void </RETURNS>
BonoboView *view, const char *verb_name, void *user_data
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboView</NAME>
struct BonoboView {
	BonoboControl base;

	BonoboEmbeddable  *embeddable;
	Bonobo_ViewFrame   view_frame;
	BonoboViewPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboViewClass</NAME>
struct BonoboViewClass {
	BonoboControlClass parent_class;

	/*
	 * Signals
	 */
	void (*do_verb)                  (BonoboView *view,
					  const CORBA_char *verb_name);
	void (*set_zoom_factor)          (BonoboView *view, double zoom);
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_view_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_construct</NAME>
<RETURNS>BonoboView            *</RETURNS>
BonoboView         *view,Bonobo_View         corba_view,GtkWidget          *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_new</NAME>
<RETURNS>BonoboView            *</RETURNS>
GtkWidget          *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_corba_object_create</NAME>
<RETURNS>Bonobo_View  </RETURNS>
BonoboObject       *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_set_embeddable</NAME>
<RETURNS>void  </RETURNS>
BonoboView         *view,BonoboEmbeddable   *embeddable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_embeddable</NAME>
<RETURNS>BonoboEmbeddable      *</RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_set_view_frame</NAME>
<RETURNS>void  </RETURNS>
BonoboView         *view,Bonobo_ViewFrame    view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_view_frame</NAME>
<RETURNS>Bonobo_ViewFrame  </RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_remote_ui_container</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_ui_component</NAME>
<RETURNS>BonoboUIComponent     *</RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_activate_notify</NAME>
<RETURNS>void  </RETURNS>
BonoboView         *view,gboolean            activated
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_epv</NAME>
<RETURNS>POA_Bonobo_View__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_GENERIC_FACTORY_TYPE</NAME>
#define BONOBO_GENERIC_FACTORY_TYPE        (bonobo_generic_factory_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_GENERIC_FACTORY</NAME>
#define BONOBO_GENERIC_FACTORY(o)          (GTK_CHECK_CAST ((o), BONOBO_GENERIC_FACTORY_TYPE, BonoboGenericFactory))
</MACRO>
<MACRO>
<NAME>BONOBO_GENERIC_FACTORY_CLASS</NAME>
#define BONOBO_GENERIC_FACTORY_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_GENERIC_FACTORY_TYPE, BonoboGenericFactoryClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_GENERIC_FACTORY</NAME>
#define BONOBO_IS_GENERIC_FACTORY(o)       (GTK_CHECK_TYPE ((o), BONOBO_GENERIC_FACTORY_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_GENERIC_FACTORY_CLASS</NAME>
#define BONOBO_IS_GENERIC_FACTORY_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_GENERIC_FACTORY_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboGenericFactory</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboGenericFactoryPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboGenericFactoryFn</NAME>
<RETURNS>BonoboObject *</RETURNS>
BonoboGenericFactory *Factory, void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeFactoryCallback</NAME>
<RETURNS>BonoboObject *</RETURNS>
BonoboGenericFactory *factory, const char *goad_id, gpointer closure
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboGenericFactory</NAME>
struct BonoboGenericFactory {
	BonoboObject base;

	/*
	 * The function factory
	 */
	BonoboGenericFactoryFn factory; /* compat reasons only */
	GnomeFactoryCallback factory_cb;
	gpointer factory_closure;

	/*
	 * The goad_id for this generic factory
	 */
	char *goad_id;
};
</STRUCT>
<STRUCT>
<NAME>BonoboGenericFactoryClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * Virtual methods
	 */
	BonoboObject * (*new_generic)(BonoboGenericFactory *c_factory, const char *goad_id);
} BonoboGenericFactoryClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_generic_factory_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_new</NAME>
<RETURNS>BonoboGenericFactory  *</RETURNS>
const char *goad_id,BonoboGenericFactoryFn factory,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_new_multi</NAME>
<RETURNS>BonoboGenericFactory  *</RETURNS>
const char *goad_id,GnomeFactoryCallback factory_cb,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_construct</NAME>
<RETURNS>BonoboGenericFactory  *</RETURNS>
const char *goad_id,BonoboGenericFactory  *c_factory,CORBA_Object          corba_factory,BonoboGenericFactoryFn factory,GnomeFactoryCallback factory_cb,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_set</NAME>
<RETURNS>void  </RETURNS>
BonoboGenericFactory *c_factory,BonoboGenericFactoryFn factory,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_get_epv</NAME>
<RETURNS>POA_GNOME_ObjectFactory__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_TYPE</NAME>
#define BONOBO_EMBEDDABLE_TYPE        (bonobo_embeddable_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_EMBEDDABLE</NAME>
#define BONOBO_EMBEDDABLE(o)          (GTK_CHECK_CAST ((o), BONOBO_EMBEDDABLE_TYPE, BonoboEmbeddable))
</MACRO>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_CLASS</NAME>
#define BONOBO_EMBEDDABLE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_EMBEDDABLE_TYPE, BonoboEmbeddableClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_EMBEDDABLE</NAME>
#define BONOBO_IS_EMBEDDABLE(o)       (GTK_CHECK_TYPE ((o), BONOBO_EMBEDDABLE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_EMBEDDABLE_CLASS</NAME>
#define BONOBO_IS_EMBEDDABLE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_EMBEDDABLE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboEmbeddable</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboEmbeddablePrivate</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_VIEW_FACTORY</NAME>
#define BONOBO_VIEW_FACTORY(fn) ((BonoboViewFactory)(fn))
</MACRO>
<USER_FUNCTION>
<NAME>BonoboViewFactory</NAME>
<RETURNS>BonoboView *</RETURNS>
BonoboEmbeddable *embeddable, const Bonobo_ViewFrame view_frame, void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeItemCreator</NAME>
<RETURNS>BonoboCanvasComponent *</RETURNS>
BonoboEmbeddable *embeddable, GnomeCanvas *canvas, void *user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboEmbeddableForeachViewFn</NAME>
<RETURNS>void </RETURNS>
BonoboView *view, void *data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboEmbeddableForeachItemFn</NAME>
<RETURNS>void </RETURNS>
BonoboCanvasComponent *comp, void *data
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboEmbeddable</NAME>
struct BonoboEmbeddable {
	BonoboObject base;

	char *host_name;
	char *host_appname;
	Bonobo_ClientSite client_site;

	/*
	 * The URI this component represents
	 */
	char *uri;
	
	BonoboEmbeddablePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboEmbeddableClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * Signals
	 */
	void (*host_name_changed)  (BonoboEmbeddable *comp, const char *hostname);
	void (*uri_changed)        (BonoboEmbeddable *comp, const char *uri);
} BonoboEmbeddableClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_embeddable_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_new</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboViewFactory  factory,void              *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_new_canvas_item</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
GnomeItemCreator item_factory,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_construct</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboEmbeddable *embeddable,Bonobo_Embeddable corba_embeddable,BonoboViewFactory factory,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_construct_full</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboEmbeddable *embeddable,Bonobo_Embeddable corba_embeddable,BonoboViewFactory factory,void *factory_data,GnomeItemCreator item_factory,void *item_factory_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_corba_object_create</NAME>
<RETURNS>Bonobo_Embeddable  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_set_view_factory</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,BonoboViewFactory factory,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_get_uri</NAME>
<RETURNS>const char       *</RETURNS>
BonoboEmbeddable *embeddable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_set_uri</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,const char *uri
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_foreach_view</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,BonoboEmbeddableForeachViewFn fn,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_foreach_item</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,BonoboEmbeddableForeachItemFn fn,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_get_epv</NAME>
<RETURNS>POA_Bonobo_Embeddable__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_FACTORY_TYPE</NAME>
#define BONOBO_EMBEDDABLE_FACTORY_TYPE        BONOBO_GENERIC_FACTORY_TYPE
</MACRO>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_FACTORY</NAME>
#define BONOBO_EMBEDDABLE_FACTORY(o)          BONOBO_GENERIC_FACTORY(o)
</MACRO>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_FACTORY_CLASS</NAME>
#define BONOBO_EMBEDDABLE_FACTORY_CLASS(k)    BONOBO_GENERIC_FACTORY_CLASS(k)
</MACRO>
<MACRO>
<NAME>BONOBO_IS_EMBEDDABLE_FACTORY</NAME>
#define BONOBO_IS_EMBEDDABLE_FACTORY(o)       BONOBO_IS_GENERIC_FACTORY(o)
</MACRO>
<MACRO>
<NAME>BONOBO_IS_EMBEDDABLE_FACTORY_CLASS</NAME>
#define BONOBO_IS_EMBEDDABLE_FACTORY_CLASS(k) BONOBO_IS_GENERIC_FACTORY_CLASS(k)
</MACRO>
<TYPEDEF>
<NAME>BonoboEmbeddableFactory</NAME>
typedef BonoboGenericFactory BonoboEmbeddableFactory;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboEmbeddableFactoryClass</NAME>
typedef BonoboGenericFactoryClass BonoboEmbeddableFactoryClass;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboEmbeddableFactoryFn</NAME>
typedef BonoboGenericFactoryFn BonoboEmbeddableFactoryFn;
</TYPEDEF>
<MACRO>
<NAME>bonobo_embeddable_factory_get_type</NAME>
#define bonobo_embeddable_factory_get_type  bonobo_generic_factory_get_type
</MACRO>
<MACRO>
<NAME>bonobo_embeddable_factory_new</NAME>
#define bonobo_embeddable_factory_new       bonobo_generic_factory_new
</MACRO>
<MACRO>
<NAME>bonobo_embeddable_factory_construct</NAME>
#define bonobo_embeddable_factory_construct bonobo_generic_factory_construct
</MACRO>
<MACRO>
<NAME>bonobo_embeddable_factory_set</NAME>
#define bonobo_embeddable_factory_set       bonobo_generic_factory_set
</MACRO>
<FUNCTION>
<NAME>bonobo_init</NAME>
<RETURNS>gboolean 	</RETURNS>
CORBA_ORB orb,PortableServer_POA poa,PortableServer_POAManager manager
</FUNCTION>
<FUNCTION>
<NAME>bonobo_main</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_activate</NAME>
<RETURNS>gboolean 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_setup_x_error_handler</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_orb</NAME>
<RETURNS>CORBA_ORB 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_poa</NAME>
<RETURNS>PortableServer_POA 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_poa_manager</NAME>
<RETURNS>PortableServer_POAManager  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_STREAM_TYPE</NAME>
#define BONOBO_STREAM_TYPE        (bonobo_stream_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM</NAME>
#define BONOBO_STREAM(o)          (GTK_CHECK_CAST ((o), BONOBO_STREAM_TYPE, BonoboStream))
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_CLASS</NAME>
#define BONOBO_STREAM_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_STREAM_TYPE, BonoboStreamClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM</NAME>
#define BONOBO_IS_STREAM(o)       (GTK_CHECK_TYPE ((o), BONOBO_STREAM_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM_CLASS</NAME>
#define BONOBO_IS_STREAM_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_STREAM_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboStream</NAME>
typedef struct {
        BonoboObject object;
} BonoboStream;
</STRUCT>
<STRUCT>
<NAME>BonoboStreamClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * virtual methods
	 */
	CORBA_long    (*write)    (BonoboStream *stream,
				   const Bonobo_Stream_iobuf *buffer,
				   CORBA_Environment *ev);
	void          (*read)     (BonoboStream *stream, CORBA_long count,
				   Bonobo_Stream_iobuf **buffer,
				   CORBA_Environment *ev);
        CORBA_long    (*seek)     (BonoboStream *stream,
				   CORBA_long offset, Bonobo_Stream_SeekType whence,
				   CORBA_Environment *ev);
        void          (*truncate) (BonoboStream *stream,
				   const CORBA_long new_size, 
				   CORBA_Environment *ev);
	void          (*copy_to)  (BonoboStream *stream,
				   const CORBA_char * dest,
				   const CORBA_long bytes,
				   CORBA_long *read,
				   CORBA_long *written,
				   CORBA_Environment *ev);
        void          (*commit)   (BonoboStream *stream,
				   CORBA_Environment *ev);
        void          (*close)    (BonoboStream *stream,
				   CORBA_Environment *ev);
        CORBA_boolean (*eos)      (BonoboStream *stream,
				   CORBA_Environment *ev);
	CORBA_long    (*length)   (BonoboStream *stream,
				   CORBA_Environment *ev);
} BonoboStreamClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_stream_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_get_epv</NAME>
<RETURNS>POA_Bonobo_Stream__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_corba_object_create</NAME>
<RETURNS>Bonobo_Stream  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_write</NAME>
<RETURNS>void  </RETURNS>
const Bonobo_Stream stream,const void        *buffer,const size_t       size,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_write_string</NAME>
<RETURNS>void  </RETURNS>
const Bonobo_Stream stream,const char         *str,const gboolean      terminate,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_printf</NAME>
<RETURNS>void  </RETURNS>
const Bonobo_Stream stream,const gboolean      terminate,CORBA_Environment  *ev,const char         *fmt, ...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_read_string</NAME>
<RETURNS>CORBA_long  </RETURNS>
const Bonobo_Stream stream,char              **str,CORBA_Environment  *ev
</FUNCTION>
<MACRO>
<NAME>BONOBO_STREAM_FS_TYPE</NAME>
#define BONOBO_STREAM_FS_TYPE        (bonobo_stream_fs_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_FS</NAME>
#define BONOBO_STREAM_FS(o)          (GTK_CHECK_CAST ((o), BONOBO_STREAM_FS_TYPE, BonoboStreamFS))
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_FS_CLASS</NAME>
#define BONOBO_STREAM_FS_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_STREAM_FS_TYPE, BonoboStreamFSClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM_FS</NAME>
#define BONOBO_IS_STREAM_FS(o)       (GTK_CHECK_TYPE ((o), BONOBO_STREAM_FS_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM_FS_CLASS</NAME>
#define BONOBO_IS_STREAM_FS_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_STREAM_FS_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboStreamFS</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboStreamFSPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboStreamFS</NAME>
struct BonoboStreamFS {
	BonoboStream stream;
	int fd;
	char *path;

	BonoboStreamFSPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboStreamFSClass</NAME>
typedef struct {
	BonoboStreamClass parent_class;
} BonoboStreamFSClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_stream_fs_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_fs_open</NAME>
<RETURNS>BonoboStream     *</RETURNS>
const CORBA_char *path, Bonobo_Storage_OpenMode mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_fs_create</NAME>
<RETURNS>BonoboStream     *</RETURNS>
const CORBA_char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_fs_construct</NAME>
<RETURNS>BonoboStream     *</RETURNS>
BonoboStreamFS *stream,Bonobo_Stream corba_stream
</FUNCTION>
<MACRO>
<NAME>BONOBO_PERSIST_TYPE</NAME>
#define BONOBO_PERSIST_TYPE        (bonobo_persist_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST</NAME>
#define BONOBO_PERSIST(o)          (GTK_CHECK_CAST ((o), BONOBO_PERSIST_TYPE, BonoboPersist))
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_CLASS</NAME>
#define BONOBO_PERSIST_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PERSIST_TYPE, BonoboPersistClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST</NAME>
#define BONOBO_IS_PERSIST(o)       (GTK_CHECK_TYPE ((o), BONOBO_PERSIST_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_CLASS</NAME>
#define BONOBO_IS_PERSIST_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PERSIST_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPersist</NAME>
typedef struct {
	BonoboObject object;

	BonoboPersistPrivate *priv;
} BonoboPersist;
</STRUCT>
<STRUCT>
<NAME>BonoboPersistClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	Bonobo_Persist_ContentTypeList * (*get_content_types) (BonoboPersist *persist,
							       CORBA_Environment *ev);
} BonoboPersistClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_persist_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_construct</NAME>
<RETURNS>BonoboPersist  *</RETURNS>
BonoboPersist *persist,Bonobo_Persist corba_persist
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_generate_content_types</NAME>
<RETURNS>Bonobo_Persist_ContentTypeList  *</RETURNS>
int num,...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_get_epv</NAME>
<RETURNS>POA_Bonobo_Persist__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_PERSIST_FILE_TYPE</NAME>
#define BONOBO_PERSIST_FILE_TYPE (bonobo_persist_file_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_FILE</NAME>
#define BONOBO_PERSIST_FILE(o)   (GTK_CHECK_CAST ((o), BONOBO_PERSIST_FILE_TYPE, BonoboPersistFile))
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_FILE_CLASS</NAME>
#define BONOBO_PERSIST_FILE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PERSIST_FILE_TYPE, BonoboPersistFileClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_FILE</NAME>
#define BONOBO_IS_PERSIST_FILE(o)       (GTK_CHECK_TYPE ((o), BONOBO_PERSIST_FILE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_FILE_CLASS</NAME>
#define BONOBO_IS_PERSIST_FILE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PERSIST_FILE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPersistFile</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboPersistFilePrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboPersistFileIOFn</NAME>
<RETURNS>int </RETURNS>
BonoboPersistFile *pf, const CORBA_char *filename, void *closure
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboPersistFile</NAME>
struct BonoboPersistFile {
	BonoboPersist persist;

	gboolean     is_dirty;
	char *filename;

	/*
	 * For the sample routines, NULL if we use the ::save and ::load
	 * methods from the class
	 */
	BonoboPersistFileIOFn  save_fn;
	BonoboPersistFileIOFn  load_fn;
	void *closure;

	BonoboPersistFilePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboPersistFileClass</NAME>
typedef struct {
	BonoboPersistClass parent_class;

	/*
	 * methods
	 */
	int        (*load)(BonoboPersistFile *ps, const CORBA_char *filename);
	int        (*save)(BonoboPersistFile *ps, const CORBA_char *filename);
	char*      (*get_current_file)(BonoboPersistFile *ps);	
} BonoboPersistFileClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_persist_file_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_file_set_dirty</NAME>
<RETURNS>void  </RETURNS>
BonoboPersistFile *ps,gboolean dirty
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_file_new</NAME>
<RETURNS>BonoboPersistFile  *</RETURNS>
BonoboPersistFileIOFn load_fn,BonoboPersistFileIOFn save_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_file_construct</NAME>
<RETURNS>BonoboPersistFile  *</RETURNS>
BonoboPersistFile *ps,Bonobo_PersistFile corba_ps,BonoboPersistFileIOFn load_fn,BonoboPersistFileIOFn save_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_file_get_epv</NAME>
<RETURNS>POA_Bonobo_PersistFile__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_PERSIST_STREAM_TYPE</NAME>
#define BONOBO_PERSIST_STREAM_TYPE        (bonobo_persist_stream_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_STREAM</NAME>
#define BONOBO_PERSIST_STREAM(o)          (GTK_CHECK_CAST ((o), BONOBO_PERSIST_STREAM_TYPE, BonoboPersistStream))
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_STREAM_CLASS</NAME>
#define BONOBO_PERSIST_STREAM_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PERSIST_STREAM_TYPE, BonoboPersistStreamClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_STREAM</NAME>
#define BONOBO_IS_PERSIST_STREAM(o)       (GTK_CHECK_TYPE ((o), BONOBO_PERSIST_STREAM_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_STREAM_CLASS</NAME>
#define BONOBO_IS_PERSIST_STREAM_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PERSIST_STREAM_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPersistStream</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboPersistStreamPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboPersistStreamIOFn</NAME>
<RETURNS>void </RETURNS>
BonoboPersistStream         *ps,
					  const Bonobo_Stream         stream,
					  Bonobo_Persist_ContentType  type,
					  void                       *closure,
					  CORBA_Environment          *ev
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboPersistStreamMaxFn</NAME>
<RETURNS>CORBA_long </RETURNS>
BonoboPersistStream *ps,
						void                *closure,
						CORBA_Environment   *ev
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboPersistStreamTypesFn</NAME>
<RETURNS>Bonobo_Persist_ContentTypeList *</RETURNS>
BonoboPersistStream *ps,
									void                *closure,
									CORBA_Environment   *ev
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboPersistStream</NAME>
struct BonoboPersistStream {
	BonoboPersist persist;

	gboolean     is_dirty;

	/*
	 * For the sample routines, NULL if we use the
	 * methods from the class
	 */
	BonoboPersistStreamIOFn    save_fn;
	BonoboPersistStreamIOFn    load_fn;
	BonoboPersistStreamMaxFn   max_fn;
	BonoboPersistStreamTypesFn types_fn;
	
	void *closure;

	BonoboPersistStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboPersistStreamClass</NAME>
typedef struct {
	BonoboPersistClass parent_class;

	/*
	 * methods
	 */
	void       (*load)         (BonoboPersistStream        *ps,
				    Bonobo_Stream              stream,
				    Bonobo_Persist_ContentType type,
				    CORBA_Environment          *ev);
	void       (*save)         (BonoboPersistStream        *ps,
				    Bonobo_Stream              stream,
				    Bonobo_Persist_ContentType type,
				    CORBA_Environment          *ev);
	CORBA_long (*get_size_max) (BonoboPersistStream *ps,
				    CORBA_Environment   *ev);
	Bonobo_Persist_ContentTypeList * (*get_content_types) (BonoboPersistStream *ps,
							       CORBA_Environment   *ev);

} BonoboPersistStreamClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_persist_stream_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_set_dirty</NAME>
<RETURNS>void  </RETURNS>
BonoboPersistStream *ps,gboolean dirty
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_new</NAME>
<RETURNS>BonoboPersistStream  *</RETURNS>
BonoboPersistStreamIOFn load_fn,BonoboPersistStreamIOFn save_fn,BonoboPersistStreamMaxFn max_fn,BonoboPersistStreamTypesFn types_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_construct</NAME>
<RETURNS>BonoboPersistStream  *</RETURNS>
BonoboPersistStream *ps,Bonobo_PersistStream corba_ps,BonoboPersistStreamIOFn load_fn,BonoboPersistStreamIOFn save_fn,BonoboPersistStreamMaxFn max_fn,BonoboPersistStreamTypesFn types_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_get_epv</NAME>
<RETURNS>POA_Bonobo_PersistStream__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_UI_XML_TYPE</NAME>
#define BONOBO_UI_XML_TYPE        (bonobo_ui_xml_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_XML</NAME>
#define BONOBO_UI_XML(o)          (GTK_CHECK_CAST ((o), BONOBO_UI_XML_TYPE, BonoboUIXml))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_XML_CLASS</NAME>
#define BONOBO_UI_XML_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_UI_XML_TYPE, BonoboUIXmlClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_XML</NAME>
#define BONOBO_IS_UI_XML(o)       (GTK_CHECK_TYPE ((o), BONOBO_UI_XML_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_XML_CLASS</NAME>
#define BONOBO_IS_UI_XML_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_UI_XML_TYPE))
</MACRO>
<ENUM>
<NAME>BonoboUIXmlError</NAME>
typedef enum {
	BONOBO_UI_XML_OK,
	BONOBO_UI_XML_BAD_PARAM,
	BONOBO_UI_XML_INVALID_PATH,
	BONOBO_UI_XML_INVALID_XML
} BonoboUIXmlError;
</ENUM>
<STRUCT>
<NAME>BonoboUIXml</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIXmlData</NAME>
typedef struct {
	gpointer id;
	gboolean dirty;
	GSList  *overridden;
} BonoboUIXmlData;
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboUIXmlCompareFn</NAME>
<RETURNS>gboolean </RETURNS>
gpointer         id_a,
						    gpointer         id_b
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboUIXmlDataNewFn</NAME>
<RETURNS>BonoboUIXmlData *</RETURNS>
void
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboUIXmlDataFreeFn</NAME>
<RETURNS>void </RETURNS>
BonoboUIXmlData *data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboUIXmlDumpFn</NAME>
<RETURNS>void </RETURNS>
BonoboUIXml      *tree,
						    BonoboUINode     *node
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboUIXmlAddNode</NAME>
<RETURNS>void </RETURNS>
BonoboUINode     *parent,
						    BonoboUINode     *child
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboUIXml</NAME>
struct BonoboUIXml {
	GtkObject              object;

	BonoboUIXmlCompareFn   compare;
	BonoboUIXmlDataNewFn   data_new;
	BonoboUIXmlDataFreeFn  data_free;
	BonoboUIXmlDumpFn      dump;
	BonoboUIXmlAddNode     add_node;

	BonoboUINode          *root;
	
	gpointer               dummy;
};
</STRUCT>
<STRUCT>
<NAME>BonoboUIXmlClass</NAME>
typedef struct {
	GtkObjectClass         object_klass;

	void                 (*override)          (BonoboUINode *node);
	void                 (*replace_override)  (BonoboUINode *new_node,
						   BonoboUINode *old_node);
	void                 (*reinstate)         (BonoboUINode *node);
	void                 (*rename)            (BonoboUINode *node);
	void                 (*remove)            (BonoboUINode *node);

	gpointer               dummy;
} BonoboUIXmlClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_ui_xml_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_new</NAME>
<RETURNS>BonoboUIXml      *</RETURNS>
BonoboUIXmlCompareFn  compare,BonoboUIXmlDataNewFn  data_new,BonoboUIXmlDataFreeFn data_free,BonoboUIXmlDumpFn     dump,BonoboUIXmlAddNode    add_node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_get_data</NAME>
<RETURNS>gpointer  </RETURNS>
BonoboUIXml  *tree,BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_set_dirty</NAME>
<RETURNS>void  </RETURNS>
BonoboUIXml  *tree,BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_clean</NAME>
<RETURNS>void  </RETURNS>
BonoboUIXml  *tree,BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_get_path</NAME>
<RETURNS>BonoboUINode     *</RETURNS>
BonoboUIXml  *tree,const char   *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_get_path_wildcard</NAME>
<RETURNS>BonoboUINode     *</RETURNS>
BonoboUIXml  *tree,const char   *path,gboolean     *wildcard
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_make_path</NAME>
<RETURNS>char             *</RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_get_parent_path</NAME>
<RETURNS>char             *</RETURNS>
const char   *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_merge</NAME>
<RETURNS>BonoboUIXmlError  </RETURNS>
BonoboUIXml  *tree,const char   *path,BonoboUINode *nodes,gpointer      id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_rm</NAME>
<RETURNS>BonoboUIXmlError  </RETURNS>
BonoboUIXml  *tree,const char   *path,gpointer      id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_dump</NAME>
<RETURNS>void  </RETURNS>
BonoboUIXml  *tree,BonoboUINode *node,const char   *msg
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_xml_strip</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode **node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_build_skeleton</NAME>
<RETURNS>void  </RETURNS>
BonoboUIXml  *xml
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_pixbuf_to_xml</NAME>
<RETURNS>char       *</RETURNS>
GdkPixbuf    *pixbuf
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_to_pixbuf</NAME>
<RETURNS>GdkPixbuf  *</RETURNS>
const char *xml
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_get_icon_pixbuf</NAME>
<RETURNS>GdkPixbuf  *</RETURNS>
BonoboUINode *node, gboolean prepend_menu
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_get_icon_pixmap_widget</NAME>
<RETURNS>GtkWidget  *</RETURNS>
BonoboUINode *node, gboolean prepend_menu
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_set_pixbuf</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode  *node,GdkPixbuf     *pixbuf
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_set_pix_xpm</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode  *node,const char   **xpm
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_set_pix_stock</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode  *node,const char    *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_set_pix_fname</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode  *node,const char    *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_build_help_menu</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent *listener,const char        *app_prefix,const char        *app_name,BonoboUINode      *parent
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_build_accel</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
guint              accelerator_key,GdkModifierType    accelerator_mods,const char        *verb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_new_menu</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
gboolean           submenu,const char        *name,const char        *label,const char        *tip,const char        *verb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_new_placeholder</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
const char        *name,gboolean           top,gboolean           bottom
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_set_radiogroup</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode           *node,const char        *group_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_set_toggle</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode           *node,const char        *id,const char        *init_state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_new_std_toolbar</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
const char        *name,const char        *label,const char        *tip,const char        *verb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_new_toggle_toolbar</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
const char        *name,const char        *label,const char        *tip,const char        *id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_get_ui_fname</NAME>
<RETURNS>char       *</RETURNS>
const char        *component_prefix,const char        *file_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_translate_ui</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode      *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_fixup_help</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent *component,BonoboUINode      *node,const char        *app_prefix,const char        *app_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_new_ui</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
BonoboUIComponent *component,const char        *fname,const char        *app_prefix,const char        *app_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_set_ui</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent *component,const char        *app_prefix,const char        *file_name,const char        *app_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_set_pixbuf</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent *component,const char        *path,GdkPixbuf         *pixbuf
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_accel_name</NAME>
<RETURNS>gchar           *</RETURNS>
guint              accelerator_key,GdkModifierType    accelerator_mods
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_accel_parse</NAME>
<RETURNS>void  </RETURNS>
char              *name,guint             *accelerator_key,GdkModifierType   *accelerator_mods
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_decode_str</NAME>
<RETURNS>char            *</RETURNS>
const char *str, gboolean *err
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_encode_str</NAME>
<RETURNS>char            *</RETURNS>
const char *str
</FUNCTION>
<MACRO>
<NAME>BONOBO_UI_COMPONENT_TYPE</NAME>
#define BONOBO_UI_COMPONENT_TYPE        (bonobo_ui_component_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_COMPONENT</NAME>
#define BONOBO_UI_COMPONENT(o)          (GTK_CHECK_CAST ((o), BONOBO_UI_COMPONENT_TYPE, BonoboUIComponent))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_COMPONENT_CLASS</NAME>
#define BONOBO_UI_COMPONENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_UI_COMPONENT_TYPE, BonoboUIComponentClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_COMPONENT</NAME>
#define BONOBO_IS_UI_COMPONENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_UI_COMPONENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_COMPONENT_CLASS</NAME>
#define BONOBO_IS_UI_COMPONENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_UI_COMPONENT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboUIComponent</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIComponentPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboUIListenerFn</NAME>
<RETURNS>void </RETURNS>
BonoboUIComponent           *component,
				    const char                  *path,
				    Bonobo_UIComponent_EventType type,
				    const char                  *state,
				    gpointer                     user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboUIVerbFn</NAME>
<RETURNS>void </RETURNS>
BonoboUIComponent           *component,
				   gpointer                     user_data,
				   const char                  *cname
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboUIComponent</NAME>
struct BonoboUIComponent {
	BonoboObject              object;
	BonoboUIComponentPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboUIComponentClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * Signals
	 */
	void (*exec_verb) (BonoboUIComponent *comp,
			   const char        *cname);

	void (*ui_event)  (BonoboUIComponent *comp,
			   const char        *path,
			   Bonobo_UIComponent_EventType type,
			   const char        *state);
	/*
	 * Virtual XML Methods
	 */
	void (*freeze)    (BonoboUIComponent *component,
			   CORBA_Environment *opt_ev);

	void (*thaw)      (BonoboUIComponent *component,
			   CORBA_Environment *opt_ev);

	void (*xml_set)   (BonoboUIComponent *component,
			   const char        *path,
			   const char        *xml,
			   CORBA_Environment *ev);

	CORBA_char *(*xml_get) (BonoboUIComponent *component,
				const char        *path,
				gboolean           recurse,
				CORBA_Environment *ev);

	void (*xml_rm)    (BonoboUIComponent *component,
			   const char        *path,
			   CORBA_Environment *ev);

	void (*set_prop)  (BonoboUIComponent *component,
			   const char        *path,
			   const char        *prop,
			   const char        *value,
			   CORBA_Environment *opt_ev);
	
	gchar *(*get_prop) (BonoboUIComponent *component,
			    const char        *path,
			    const char        *prop,
			    CORBA_Environment *opt_ev);

	gboolean (*exists) (BonoboUIComponent *component,
			    const char        *path,
			    CORBA_Environment *ev);
	

	gpointer            dummy;
} BonoboUIComponentClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_ui_component_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_construct</NAME>
<RETURNS>BonoboUIComponent  *</RETURNS>
BonoboUIComponent  *component,Bonobo_UIComponent  corba_ui,const char         *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_new</NAME>
<RETURNS>BonoboUIComponent  *</RETURNS>
const char         *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_new_default</NAME>
<RETURNS>BonoboUIComponent  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_name</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get_name</NAME>
<RETURNS>const char         *</RETURNS>
BonoboUIComponent  *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_container</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,Bonobo_UIContainer  container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_unset_container</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get_container</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboUIComponent  *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_add_verb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *cname,BonoboUIVerbFn      fn,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_add_verb_full</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *cname,BonoboUIVerbFn      fn,gpointer            user_data,GDestroyNotify      destroy_fn
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_add_listener</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *id,BonoboUIListenerFn  fn,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_add_listener_full</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *id,BonoboUIListenerFn  fn,gpointer            user_data,GDestroyNotify      destroy_fn
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,const char         *xml,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_translate</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,const char         *xml,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_tree</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,BonoboUINode       *node,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_rm</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_path_exists</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIComponent  *component,const char         *path,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get</NAME>
<RETURNS>CORBA_char         *</RETURNS>
BonoboUIComponent  *component,const char         *path,gboolean            recurse,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get_tree</NAME>
<RETURNS>BonoboUINode       *</RETURNS>
BonoboUIComponent  *component,const char         *path,gboolean            recurse,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_object_set</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,Bonobo_Unknown      control,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_object_get</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboUIComponent  *component,const char         *path,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_freeze</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_thaw</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_prop</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,const char         *prop,const char         *value,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get_prop</NAME>
<RETURNS>gchar              *</RETURNS>
BonoboUIComponent  *component,const char         *path,const char         *prop,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_status</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *text,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get_epv</NAME>
<RETURNS>POA_Bonobo_UIComponent__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_corba_object_create</NAME>
<RETURNS>Bonobo_UIComponent  </RETURNS>
BonoboObject *object
</FUNCTION>
<STRUCT>
<NAME>BonoboUIVerb</NAME>
typedef struct {
	char          *cname;
	BonoboUIVerbFn cb;
	gpointer       user_data;
	gpointer       dummy;
} BonoboUIVerb;
</STRUCT>
<MACRO>
<NAME>BONOBO_UI_VERB</NAME>
#define BONOBO_UI_VERB(name,cb)                  { (name), (cb), NULL   }
</MACRO>
<MACRO>
<NAME>BONOBO_UI_VERB_DATA</NAME>
#define BONOBO_UI_VERB_DATA(name,cb,data)        { (name), (cb), (data) }
</MACRO>
<MACRO>
<NAME>BONOBO_UI_UNSAFE_VERB</NAME>
#define BONOBO_UI_UNSAFE_VERB(name,cb)           { (name), ((BonoboUIVerbFn)(cb)), NULL   }
</MACRO>
<MACRO>
<NAME>BONOBO_UI_UNSAFE_VERB_DATA</NAME>
#define BONOBO_UI_UNSAFE_VERB_DATA(name,cb,data) { (name), ((BonoboUIVerbFn)(cb)), (data) }
</MACRO>
<MACRO>
<NAME>BONOBO_UI_VERB_END</NAME>
#define BONOBO_UI_VERB_END                       { NULL, NULL, NULL }
</MACRO>
<FUNCTION>
<NAME>bonobo_ui_component_add_verb_list</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,BonoboUIVerb       *list
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_add_verb_list_with_data</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,BonoboUIVerb       *list,gpointer            user_data
</FUNCTION>
<MACRO>
<NAME>BONOBO_UI_CONTAINER_TYPE</NAME>
#define BONOBO_UI_CONTAINER_TYPE        (bonobo_ui_container_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_CONTAINER</NAME>
#define BONOBO_UI_CONTAINER(o)          (GTK_CHECK_CAST ((o), BONOBO_UI_CONTAINER_TYPE, BonoboUIContainer))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_CONTAINER_CLASS</NAME>
#define BONOBO_UI_CONTAINER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_UI_CONTAINER_TYPE, BonoboUIContainerClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_CONTAINER</NAME>
#define BONOBO_IS_UI_CONTAINER(o)       (GTK_CHECK_TYPE ((o), BONOBO_UI_CONTAINER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_CONTAINER_CLASS</NAME>
#define BONOBO_IS_UI_CONTAINER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_UI_CONTAINER_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboUIContainer</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIContainerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIContainer</NAME>
struct BonoboUIContainer {
	BonoboObject base;

	int          flags;
	BonoboWin   *win;
};
</STRUCT>
<STRUCT>
<NAME>BonoboUIContainerClass</NAME>
struct BonoboUIContainerClass {
	BonoboObjectClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_ui_container_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_container_get_epv</NAME>
<RETURNS>POA_Bonobo_UIContainer__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_container_corba_object_create</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboObject       *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_container_construct</NAME>
<RETURNS>BonoboUIContainer            *</RETURNS>
BonoboUIContainer  *container,Bonobo_UIContainer  corba_container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_container_new</NAME>
<RETURNS>BonoboUIContainer            *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_container_set_win</NAME>
<RETURNS>void  </RETURNS>
BonoboUIContainer  *container,BonoboWin          *win
</FUNCTION>
<MACRO>
<NAME>BONOBO_TYPE_WIN</NAME>
#define BONOBO_TYPE_WIN        (bonobo_win_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_WIN</NAME>
#define BONOBO_WIN(o)          (GTK_CHECK_CAST ((o), BONOBO_TYPE_WIN, BonoboWin))
</MACRO>
<MACRO>
<NAME>BONOBO_WIN_CLASS</NAME>
#define BONOBO_WIN_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_TYPE_WIN, BonoboWinClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WIN</NAME>
#define BONOBO_IS_WIN(o)       (GTK_CHECK_TYPE ((o), BONOBO_TYPE_WIN))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WIN_CLASS</NAME>
#define BONOBO_IS_WIN_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_TYPE_WIN))
</MACRO>
<STRUCT>
<NAME>BonoboWin</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWinPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWinClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWin</NAME>
struct BonoboWin {
	GtkWindow          parent;
	
	BonoboWinPrivate  *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboWinClass</NAME>
struct BonoboWinClass {
	GtkWindowClass    parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_win_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_construct</NAME>
<RETURNS>GtkWidget            *</RETURNS>
BonoboWin  *win,const char *win_name,const char *title
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_new</NAME>
<RETURNS>GtkWidget            *</RETURNS>
const char *win_name,const char *title
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_set_contents</NAME>
<RETURNS>void  </RETURNS>
BonoboWin  *win,GtkWidget  *contents
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_get_contents</NAME>
<RETURNS>GtkWidget            *</RETURNS>
BonoboWin  *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_freeze</NAME>
<RETURNS>void  </RETURNS>
BonoboWin *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_thaw</NAME>
<RETURNS>void  </RETURNS>
BonoboWin *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_set_name</NAME>
<RETURNS>void  </RETURNS>
BonoboWin  *win,const char *win_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_get_name</NAME>
<RETURNS>char                 *</RETURNS>
BonoboWin *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_xml_merge</NAME>
<RETURNS>BonoboUIXmlError  </RETURNS>
BonoboWin  *win,const char *path,const char *xml,const char *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_xml_merge_tree</NAME>
<RETURNS>BonoboUIXmlError  </RETURNS>
BonoboWin  *win,const char *path,BonoboUINode    *tree,const char *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_xml_get</NAME>
<RETURNS>char                 *</RETURNS>
BonoboWin  *win,const char *path,gboolean    node_only
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_xml_node_exists</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboWin  *win,const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_xml_rm</NAME>
<RETURNS>BonoboUIXmlError  </RETURNS>
BonoboWin  *win,const char *path,const char *by_component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_object_set</NAME>
<RETURNS>BonoboUIXmlError  </RETURNS>
BonoboWin  *win,const char *path,Bonobo_Unknown object,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_object_get</NAME>
<RETURNS>BonoboUIXmlError  </RETURNS>
BonoboWin  *win,const char *path,Bonobo_Unknown *object,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_get_accel_group</NAME>
<RETURNS>GtkAccelGroup        *</RETURNS>
BonoboWin  *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_dump</NAME>
<RETURNS>void  </RETURNS>
BonoboWin  *win,const char *msg
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_register_component</NAME>
<RETURNS>void  </RETURNS>
BonoboWin     *win,const char    *name,Bonobo_Unknown component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_deregister_component</NAME>
<RETURNS>void  </RETURNS>
BonoboWin     *win,const char    *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_component_get</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboWin     *win,const char    *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_add_popup</NAME>
<RETURNS>void  </RETURNS>
BonoboWin     *win,GtkMenu       *popup,const char    *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_win_remove_popup</NAME>
<RETURNS>void  </RETURNS>
BonoboWin     *win,const char    *path
</FUNCTION>
<ENUM>
<NAME>GnomeIOStatus</NAME>
typedef enum {
	GNOME_IO_OK,
	
	/* Generic error */
	GNOME_IOERR_GENERAL,

	/* PersistStorage interface not supported by object */
	GNOME_IOERR_PERSIST_NOT_SUPPORTED
	
} GnomeIOStatus;
</ENUM>
<FUNCTION>
<NAME>bonobo_persist_stream_save_object_iid</NAME>
<RETURNS>void  </RETURNS>
Bonobo_Stream target,const CORBA_char *object_iid,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_load_object_iid</NAME>
<RETURNS>char            *</RETURNS>
Bonobo_Stream source
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persiststream_save_to_stream</NAME>
<RETURNS>GnomeIOStatus  </RETURNS>
Bonobo_PersistStream pstream,Bonobo_Stream target,const char *object_iid
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_save_to_stream</NAME>
<RETURNS>GnomeIOStatus  </RETURNS>
BonoboObject *object,Bonobo_Stream stream,const char *object_iid
</FUNCTION>
<MACRO>
<NAME>BONOBO_PROGRESSIVE_DATA_SINK_TYPE</NAME>
#define BONOBO_PROGRESSIVE_DATA_SINK_TYPE        (bonobo_progressive_data_sink_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PROGRESSIVE_DATA_SINK</NAME>
#define BONOBO_PROGRESSIVE_DATA_SINK(o)          (GTK_CHECK_CAST ((o), BONOBO_PROGRESSIVE_DATA_SINK_TYPE, BonoboProgressiveDataSink))
</MACRO>
<MACRO>
<NAME>BONOBO_PROGRESSIVE_DATA_SINK_CLASS</NAME>
#define BONOBO_PROGRESSIVE_DATA_SINK_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PROGRESSIVE_DATA_SINK_TYPE, BonoboProgressiveDataSinkClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROGRESSIVE_DATA_SINK</NAME>
#define BONOBO_IS_PROGRESSIVE_DATA_SINK(o)       (GTK_CHECK_TYPE ((o), BONOBO_PROGRESSIVE_DATA_SINK_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROGRESSIVE_DATA_SINK_CLASS</NAME>
#define BONOBO_IS_PROGRESSIVE_DATA_SINK_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PROGRESSIVE_DATA_SINK_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboProgressiveDataSink</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboProgressiveDataSinkPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboProgressiveDataSinkStartFn</NAME>
<RETURNS>int </RETURNS>
BonoboProgressiveDataSink *psink,
						  void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboProgressiveDataSinkEndFn</NAME>
<RETURNS>int </RETURNS>
BonoboProgressiveDataSink *psink, void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboProgressiveDataSinkAddDataFn</NAME>
<RETURNS>int </RETURNS>
BonoboProgressiveDataSink *psink,
						  const Bonobo_ProgressiveDataSink_iobuf *buffer,
						  void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboProgressiveDataSinkSetSizeFn</NAME>
<RETURNS>int </RETURNS>
BonoboProgressiveDataSink *psink,
						  const CORBA_long count, void *closure
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboProgressiveDataSink</NAME>
struct BonoboProgressiveDataSink {
	BonoboObject object;

	/*
	 * These are the callbacks the user can set.  If we use the
	 * default class methods, then these are NULL.
	 */
	BonoboProgressiveDataSinkStartFn start_fn;
	BonoboProgressiveDataSinkEndFn end_fn;
	BonoboProgressiveDataSinkAddDataFn add_data_fn;
	BonoboProgressiveDataSinkSetSizeFn set_size_fn;

	void *closure;

	BonoboProgressiveDataSinkPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboProgressiveDataSinkClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * Methods.
	 */
	int (*start_fn)    (BonoboProgressiveDataSink *psink);
	int (*end_fn)      (BonoboProgressiveDataSink *psink);
	int (*add_data_fn) (BonoboProgressiveDataSink *psink,
			    const Bonobo_ProgressiveDataSink_iobuf *buffer);
	int (*set_size_fn) (BonoboProgressiveDataSink *psink,
			    const CORBA_long count);
			 
} BonoboProgressiveDataSinkClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_progressive_data_sink_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_progressive_data_sink_new</NAME>
<RETURNS>BonoboProgressiveDataSink  *</RETURNS>
BonoboProgressiveDataSinkStartFn start_fn,BonoboProgressiveDataSinkEndFn end_fn,BonoboProgressiveDataSinkAddDataFn add_data_fn,BonoboProgressiveDataSinkSetSizeFn set_size_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_progressive_data_sink_construct</NAME>
<RETURNS>BonoboProgressiveDataSink  *</RETURNS>
BonoboProgressiveDataSink *psink,Bonobo_ProgressiveDataSink corba_psink,BonoboProgressiveDataSinkStartFn start_fn,BonoboProgressiveDataSinkEndFn end_fn,BonoboProgressiveDataSinkAddDataFn add_data_fn,BonoboProgressiveDataSinkSetSizeFn set_size_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_progressive_get_epv</NAME>
<RETURNS>POA_Bonobo_ProgressiveDataSink__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_STORAGE_TYPE</NAME>
#define BONOBO_STORAGE_TYPE        (bonobo_storage_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_STORAGE</NAME>
#define BONOBO_STORAGE(o)          (GTK_CHECK_CAST ((o), BONOBO_STORAGE_TYPE, BonoboStorage))
</MACRO>
<MACRO>
<NAME>BONOBO_STORAGE_CLASS</NAME>
#define BONOBO_STORAGE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_STORAGE_TYPE, BonoboStorageClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STORAGE</NAME>
#define BONOBO_IS_STORAGE(o)       (GTK_CHECK_TYPE ((o), BONOBO_STORAGE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STORAGE_CLASS</NAME>
#define BONOBO_IS_STORAGE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_STORAGE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboStoragePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboStorage</NAME>
typedef struct {
        BonoboObject object;

	BonoboStoragePrivate *priv;
} BonoboStorage;
</STRUCT>
<STRUCT>
<NAME>BonoboStorageClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * virtual methods
	 */
	BonoboStream  *(*create_stream)  (BonoboStorage *storage,
					 const CORBA_char *path,
					 CORBA_Environment *ev);
	BonoboStream  *(*open_stream)    (BonoboStorage *storage,
					 const CORBA_char *path,
					 Bonobo_Storage_OpenMode, CORBA_Environment *ev);
	BonoboStorage *(*create_storage) (BonoboStorage *storage,
					 const CORBA_char *path,
					 CORBA_Environment *ev);
	BonoboStorage *(*open_storage)   (BonoboStorage *storage,
					 const CORBA_char *path,
					 CORBA_Environment *ev);
	void         (*copy_to)         (BonoboStorage *storage, Bonobo_Storage target,
					 CORBA_Environment *ev);
	void         (*rename)          (BonoboStorage *storage,
					 const CORBA_char *path_name,
					 const CORBA_char *new_path_name,
					 CORBA_Environment *ev);
	void         (*commit)          (BonoboStorage *storage,
					 CORBA_Environment *ev);
	Bonobo_Storage_directory_list *
	             (*list_contents)   (BonoboStorage *storage,
					 const CORBA_char *path,
					 CORBA_Environment *ev);
	void         (*erase)          (BonoboStorage *storage,
                                        const CORBA_char *path,
                                        CORBA_Environment *ev);
} BonoboStorageClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_storage_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_construct</NAME>
<RETURNS>BonoboStorage    *</RETURNS>
BonoboStorage *storage,Bonobo_Storage corba_storage
</FUNCTION>
<MACRO>
<NAME>BONOBO_SS_READ</NAME>
#define BONOBO_SS_READ   1
</MACRO>
<MACRO>
<NAME>BONOBO_SS_WRITE</NAME>
#define BONOBO_SS_WRITE  2
</MACRO>
<MACRO>
<NAME>BONOBO_SS_RDWR</NAME>
#define BONOBO_SS_RDWR   3
</MACRO>
<MACRO>
<NAME>BONOBO_SS_CREATE</NAME>
#define BONOBO_SS_CREATE 4
</MACRO>
<MACRO>
<NAME>BONOBO_SS_EXCL</NAME>
#define BONOBO_SS_EXCL   8
</MACRO>
<FUNCTION>
<NAME>bonobo_storage_open</NAME>
<RETURNS>BonoboStorage    *</RETURNS>
const char *driver,const char *path,gint flags,gint mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_corba_object_create</NAME>
<RETURNS>Bonobo_Storage  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_storage_open</NAME>
<RETURNS>BonoboStorage    *</RETURNS>
BonoboStorage *storage,const char *path,const char *open_mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_storage_open</NAME>
<RETURNS>BonoboStream     *</RETURNS>
BonoboStorage *storage,const char *path,const char *open_mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_write_class_id</NAME>
<RETURNS>void  </RETURNS>
BonoboStorage *storage,char *class_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_write_class_id</NAME>
<RETURNS>void  </RETURNS>
BonoboStream *stream,char *class_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_get_epv</NAME>
<RETURNS>POA_Bonobo_Storage__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_driver_open</NAME>
<RETURNS>BonoboStorage  *</RETURNS>
const char *path, gint flags, gint mode
</FUNCTION>
<MACRO>
<NAME>BONOBO_SELECTOR</NAME>
#define BONOBO_SELECTOR(obj)	GTK_CHECK_CAST(obj, bonobo_selector_get_type (), BonoboSelector)
</MACRO>
<MACRO>
<NAME>BONOBO_SELECTOR_CLASS</NAME>
#define BONOBO_SELECTOR_CLASS	GTK_CHECK_CLASS_CAST (klass, bonobo_selector_get_type (), BonoboSelectorClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_BONOBO_SELECTOR</NAME>
#define GNOME_IS_BONOBO_SELECTOR(obj)	GTK_CHECK_TYPE (obj, bonobo_selector_get_type ())
</MACRO>
<STRUCT>
<NAME>BonoboSelector</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboSelectorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboSelectorPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboSelectorClass</NAME>
struct BonoboSelectorClass
{
	GnomeDialogClass parent_class;
	
	void (* ok)	(BonoboSelector *sel);
	void (* cancel)	(BonoboSelector *sel);
};
</STRUCT>
<STRUCT>
<NAME>BonoboSelector</NAME>
struct BonoboSelector
{
	GnomeDialog dialog;
		
	BonoboSelectorPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_selector_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar *title,const gchar **interfaces_required
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_get_selected_id</NAME>
<RETURNS>gchar 	  *</RETURNS>
BonoboSelector *sel
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_get_selected_name</NAME>
<RETURNS>gchar      *</RETURNS>
BonoboSelector *sel
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_get_selected_description</NAME>
<RETURNS>gchar      *</RETURNS>
BonoboSelector *sel
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_select_id</NAME>
<RETURNS>gchar 	  *</RETURNS>
const gchar *title,const gchar **interfaces_required
</FUNCTION>
<MACRO>
<NAME>BONOBO_WIDGET_TYPE</NAME>
#define BONOBO_WIDGET_TYPE        (bonobo_widget_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_WIDGET</NAME>
#define BONOBO_WIDGET(o)          (GTK_CHECK_CAST ((o), BONOBO_WIDGET_TYPE, BonoboWidget))
</MACRO>
<MACRO>
<NAME>BONOBO_WIDGET_CLASS</NAME>
#define BONOBO_WIDGET_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_WIDGET_TYPE, BonoboWidgetClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WIDGET</NAME>
#define BONOBO_IS_WIDGET(o)       (GTK_CHECK_TYPE ((o), BONOBO_WIDGET_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WIDGET_CLASS</NAME>
#define BONOBO_IS_WIDGET_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_WIDGET_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboWidget</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWidgetPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWidget</NAME>
struct BonoboWidget {
	GtkBin		          bin;

	BonoboWidgetPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboWidgetClass</NAME>
typedef struct {
	GtkBinClass	 bin_class;
} BonoboWidgetClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_widget_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_server</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
BonoboWidget     *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_new_control</NAME>
<RETURNS>GtkWidget           *</RETURNS>
const char        *goad_id,Bonobo_UIContainer uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_new_control_from_objref</NAME>
<RETURNS>GtkWidget           *</RETURNS>
Bonobo_Control     control,Bonobo_UIContainer uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_control_frame</NAME>
<RETURNS>BonoboControlFrame  *</RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_new_subdoc</NAME>
<RETURNS>GtkWidget            *</RETURNS>
const char        *object_desc,Bonobo_UIContainer uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_container</NAME>
<RETURNS>BonoboItemContainer  *</RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_client_site</NAME>
<RETURNS>BonoboClientSite     *</RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_view_frame</NAME>
<RETURNS>BonoboViewFrame      *</RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_uih</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_set_property</NAME>
<RETURNS>void  </RETURNS>
BonoboWidget       *control,const char         *first_prop,...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_property</NAME>
<RETURNS>void  </RETURNS>
BonoboWidget       *control,const char         *first_prop,...
</FUNCTION>
<MACRO>
<NAME>BONOBO_PRINT_TYPE</NAME>
#define BONOBO_PRINT_TYPE        (bonobo_print_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT</NAME>
#define BONOBO_PRINT(o)          (GTK_CHECK_CAST ((o), BONOBO_PRINT_TYPE, BonoboPrint))
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT_CLASS</NAME>
#define BONOBO_PRINT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PRINT_TYPE, BonoboPrintClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PRINT</NAME>
#define BONOBO_IS_PRINT(o)       (GTK_CHECK_TYPE ((o), BONOBO_PRINT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PRINT_CLASS</NAME>
#define BONOBO_IS_PRINT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PRINT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPrint</NAME>
typedef struct {
        BonoboObject         object;

	BonoboPrintRenderFn *render;
	gpointer             user_data;
} BonoboPrint;
</STRUCT>
<STRUCT>
<NAME>BonoboPrintClass</NAME>
typedef struct {
	BonoboObjectClass    parent;
	BonoboPrintRenderFn *render;
} BonoboPrintClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_print_get_epv</NAME>
<RETURNS>POA_Bonobo_Print__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_corba_object_create</NAME>
<RETURNS>Bonobo_Print  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_construct</NAME>
<RETURNS>BonoboPrint     *</RETURNS>
BonoboPrint         *p,Bonobo_Print         corba_p,BonoboPrintRenderFn *render,gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_new</NAME>
<RETURNS>BonoboPrint     *</RETURNS>
BonoboPrintRenderFn *render,gpointer             user_data
</FUNCTION>
<MACRO>
<NAME>BONOBO_PRINT_CLIENT_TYPE</NAME>
#define BONOBO_PRINT_CLIENT_TYPE        (bonobo_print_client_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT_CLIENT</NAME>
#define BONOBO_PRINT_CLIENT(o)          (GTK_CHECK_CAST ((o), BONOBO_PRINT_CLIENT_TYPE, BonoboPrintClient))
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT_CLIENT_CLASS</NAME>
#define BONOBO_PRINT_CLIENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PRINT_CLIENT_TYPE, BonoboPrintClientClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PRINT_CLIENT</NAME>
#define BONOBO_IS_PRINT_CLIENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_PRINT_CLIENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PRINT_CLIENT_CLASS</NAME>
#define BONOBO_IS_PRINT_CLIENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PRINT_CLIENT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPrintClient</NAME>
typedef struct {
	GtkObject    parent;
	Bonobo_Print corba_print;
} BonoboPrintClient;
</STRUCT>
<STRUCT>
<NAME>BonoboPrintClientClass</NAME>
typedef struct {
	GtkObjectClass			parent;
} BonoboPrintClientClass;
</STRUCT>
<STRUCT>
<NAME>BonoboPrintData</NAME>
typedef struct {
	double width;
	double height;
	
	double width_first_page;
	double width_per_page;
	double height_first_page;
	double height_per_page;

	GnomePrintMeta *meta_data;
} BonoboPrintData;
</STRUCT>
<FUNCTION>
<NAME>bonobo_print_client_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_client_new</NAME>
<RETURNS>BonoboPrintClient   *</RETURNS>
Bonobo_Print         corba_print
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_client_get</NAME>
<RETURNS>BonoboPrintClient   *</RETURNS>
BonoboObjectClient  *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_client_render</NAME>
<RETURNS>void  </RETURNS>
BonoboPrintClient   *client,BonoboPrintData     *pd
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_new</NAME>
<RETURNS>BonoboPrintData     *</RETURNS>
double               width,double               height
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_new_full</NAME>
<RETURNS>BonoboPrintData     *</RETURNS>
double               width,double               height,double               width_first_page,double               width_per_page,double               height_first_page,double               height_per_page
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_free</NAME>
<RETURNS>void  </RETURNS>
BonoboPrintData     *pd
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_get_meta</NAME>
<RETURNS>GnomePrintMeta      *</RETURNS>
BonoboPrintData     *pd
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_render</NAME>
<RETURNS>void  </RETURNS>
GnomePrintContext   *pc,double               x,double               y,BonoboPrintData     *pd,double               meta_x,double               meta_y
</FUNCTION>
