<MACRO>
<NAME>HAVE_ALLOCA</NAME>
#define HAVE_ALLOCA 1
</MACRO>
<MACRO>
<NAME>HAVE_ALLOCA_H</NAME>
#define HAVE_ALLOCA_H 1
</MACRO>
<MACRO>
<NAME>HAVE_MMAP</NAME>
#define HAVE_MMAP 1
</MACRO>
<MACRO>
<NAME>STDC_HEADERS</NAME>
#define STDC_HEADERS 1
</MACRO>
<MACRO>
<NAME>PACKAGE</NAME>
#define PACKAGE "bonobo"
</MACRO>
<MACRO>
<NAME>VERSION</NAME>
#define VERSION "0.14"
</MACRO>
<MACRO>
<NAME>HAVE_LIBSM</NAME>
#define HAVE_LIBSM 1
</MACRO>
<MACRO>
<NAME>ENABLE_NLS</NAME>
#define ENABLE_NLS 1
</MACRO>
<MACRO>
<NAME>HAVE_GETTEXT</NAME>
#define HAVE_GETTEXT 1
</MACRO>
<MACRO>
<NAME>HAVE_LC_MESSAGES</NAME>
#define HAVE_LC_MESSAGES 1
</MACRO>
<MACRO>
<NAME>HAVE_STPCPY</NAME>
#define HAVE_STPCPY 1
</MACRO>
<MACRO>
<NAME>USING_OAF</NAME>
#define USING_OAF 1
</MACRO>
<MACRO>
<NAME>HAVE___ARGZ_COUNT</NAME>
#define HAVE___ARGZ_COUNT 1
</MACRO>
<MACRO>
<NAME>HAVE___ARGZ_NEXT</NAME>
#define HAVE___ARGZ_NEXT 1
</MACRO>
<MACRO>
<NAME>HAVE___ARGZ_STRINGIFY</NAME>
#define HAVE___ARGZ_STRINGIFY 1
</MACRO>
<MACRO>
<NAME>HAVE_DCGETTEXT</NAME>
#define HAVE_DCGETTEXT 1
</MACRO>
<MACRO>
<NAME>HAVE_GETCWD</NAME>
#define HAVE_GETCWD 1
</MACRO>
<MACRO>
<NAME>HAVE_GETPAGESIZE</NAME>
#define HAVE_GETPAGESIZE 1
</MACRO>
<MACRO>
<NAME>HAVE_MUNMAP</NAME>
#define HAVE_MUNMAP 1
</MACRO>
<MACRO>
<NAME>HAVE_PUTENV</NAME>
#define HAVE_PUTENV 1
</MACRO>
<MACRO>
<NAME>HAVE_SETENV</NAME>
#define HAVE_SETENV 1
</MACRO>
<MACRO>
<NAME>HAVE_SETLOCALE</NAME>
#define HAVE_SETLOCALE 1
</MACRO>
<MACRO>
<NAME>HAVE_STPCPY</NAME>
#define HAVE_STPCPY 1
</MACRO>
<MACRO>
<NAME>HAVE_STRCASECMP</NAME>
#define HAVE_STRCASECMP 1
</MACRO>
<MACRO>
<NAME>HAVE_STRCHR</NAME>
#define HAVE_STRCHR 1
</MACRO>
<MACRO>
<NAME>HAVE_STRDUP</NAME>
#define HAVE_STRDUP 1
</MACRO>
<MACRO>
<NAME>HAVE_X11_SM_SMLIB_H</NAME>
#define HAVE_X11_SM_SMLIB_H 1
</MACRO>
<MACRO>
<NAME>HAVE_ARGZ_H</NAME>
#define HAVE_ARGZ_H 1
</MACRO>
<MACRO>
<NAME>HAVE_LIMITS_H</NAME>
#define HAVE_LIMITS_H 1
</MACRO>
<MACRO>
<NAME>HAVE_LOCALE_H</NAME>
#define HAVE_LOCALE_H 1
</MACRO>
<MACRO>
<NAME>HAVE_MALLOC_H</NAME>
#define HAVE_MALLOC_H 1
</MACRO>
<MACRO>
<NAME>HAVE_NL_TYPES_H</NAME>
#define HAVE_NL_TYPES_H 1
</MACRO>
<MACRO>
<NAME>HAVE_STRING_H</NAME>
#define HAVE_STRING_H 1
</MACRO>
<MACRO>
<NAME>HAVE_SYS_PARAM_H</NAME>
#define HAVE_SYS_PARAM_H 1
</MACRO>
<MACRO>
<NAME>HAVE_UNISTD_H</NAME>
#define HAVE_UNISTD_H 1
</MACRO>
<MACRO>
<NAME>PACKAGE</NAME>
#define PACKAGE "bonobo"
</MACRO>
<MACRO>
<NAME>VERSION</NAME>
#define VERSION "0.14"
</MACRO>
<MACRO>
<NAME>MO_REVISION_NUMBER</NAME>
#define MO_REVISION_NUMBER 0
</MACRO>
<MACRO>
<NAME>UINT_MAX_32_BITS</NAME>
# define UINT_MAX_32_BITS 4294967295U
</MACRO>
<MACRO>
<NAME>UINT_MAX_32_BITS</NAME>
# define UINT_MAX_32_BITS 0xFFFFFFFF
</MACRO>
<MACRO>
<NAME>UINT_MAX</NAME>
# define UINT_MAX UINT_MAX_32_BITS
</MACRO>
<TYPEDEF>
<NAME>nls_uint32</NAME>
typedef unsigned nls_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>nls_uint32</NAME>
typedef unsigned short nls_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>nls_uint32</NAME>
typedef unsigned long nls_uint32;
</TYPEDEF>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) args
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) ()
</MACRO>
<MACRO>
<NAME>internal_function</NAME>
# define internal_function
</MACRO>
<MACRO>
<NAME>W</NAME>
# define W(flag, data) ((flag) ? SWAP (data) : (data))
</MACRO>
<MACRO>
<NAME>SWAP</NAME>
# define SWAP(i) bswap_32 (i)
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(Args) Args
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(Args) ()
</MACRO>
<MACRO>
<NAME>HASHWORDBITS</NAME>
#define HASHWORDBITS 32
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) args
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) ()
</MACRO>
<MACRO>
<NAME>NULL</NAME>
#  define NULL ((void *) 0)
</MACRO>
<MACRO>
<NAME>NULL</NAME>
#  define NULL (0)
</MACRO>
<MACRO>
<NAME>LC_MESSAGES</NAME>
# define LC_MESSAGES (-1)
</MACRO>
<STRUCT>
<NAME>msg_ent</NAME>
struct msg_ent
{
  const char *_msg;
  int _msg_number;
};
</STRUCT>
<MACRO>
<NAME>gettext_noop</NAME>
#define gettext_noop(Str) (Str)
</MACRO>
<MACRO>
<NAME>gettext</NAME>
#  define gettext(Msgid)						      \
     dgettext (NULL, Msgid)
</MACRO>
<MACRO>
<NAME>dgettext</NAME>
#  define dgettext(Domainname, Msgid)					      \
     dcgettext (Domainname, Msgid, LC_MESSAGES)
</MACRO>
<MACRO>
<NAME>dcgettext</NAME>
#   define dcgettext(Domainname, Msgid, Category)			      \
  (__extension__							      \
   ({									      \
     char *__result;							      \
     if (__builtin_constant_p (Msgid))					      \
       {								      \
	 static char *__translation__;					      \
	 static int __catalog_counter__;				      \
	 if (! __translation__ || __catalog_counter__ != _nl_msg_cat_cntr)    \
	   {								      \
	     __translation__ =						      \
	       dcgettext__ (Domainname, Msgid, Category);		      \
	     __catalog_counter__ = _nl_msg_cat_cntr;			      \
	   }								      \
	 __result = __translation__;					      \
       }								      \
     else								      \
       __result = dcgettext__ (Domainname, Msgid, Category);		      \
     __result;								      \
    }))
</MACRO>
<MACRO>
<NAME>gettext</NAME>
# define gettext(Msgid) (Msgid)
</MACRO>
<MACRO>
<NAME>dgettext</NAME>
# define dgettext(Domainname, Msgid) (Msgid)
</MACRO>
<MACRO>
<NAME>dcgettext</NAME>
# define dcgettext(Domainname, Msgid, Category) (Msgid)
</MACRO>
<MACRO>
<NAME>textdomain</NAME>
# define textdomain(Domainname) ((char *) Domainname)
</MACRO>
<MACRO>
<NAME>bindtextdomain</NAME>
# define bindtextdomain(Domainname, Dirname) ((char *) Dirname)
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) args
</MACRO>
<MACRO>
<NAME>PARAMS</NAME>
#  define PARAMS(args) ()
</MACRO>
<MACRO>
<NAME>CEN_REVISION</NAME>
#define CEN_REVISION		1
</MACRO>
<MACRO>
<NAME>CEN_SPONSOR</NAME>
#define CEN_SPONSOR		2
</MACRO>
<MACRO>
<NAME>CEN_SPECIAL</NAME>
#define CEN_SPECIAL		4
</MACRO>
<MACRO>
<NAME>XPG_NORM_CODESET</NAME>
#define XPG_NORM_CODESET	8
</MACRO>
<MACRO>
<NAME>XPG_CODESET</NAME>
#define XPG_CODESET		16
</MACRO>
<MACRO>
<NAME>TERRITORY</NAME>
#define TERRITORY		32
</MACRO>
<MACRO>
<NAME>CEN_AUDIENCE</NAME>
#define CEN_AUDIENCE		64
</MACRO>
<MACRO>
<NAME>XPG_MODIFIER</NAME>
#define XPG_MODIFIER		128
</MACRO>
<MACRO>
<NAME>CEN_SPECIFIC</NAME>
#define CEN_SPECIFIC	(CEN_REVISION|CEN_SPONSOR|CEN_SPECIAL|CEN_AUDIENCE)
</MACRO>
<MACRO>
<NAME>XPG_SPECIFIC</NAME>
#define XPG_SPECIFIC	(XPG_CODESET|XPG_NORM_CODESET|XPG_MODIFIER)
</MACRO>
<FUNCTION>
<NAME>PARAMS</NAME>
<RETURNS>_nl_make_l10nflist  </RETURNS>
(struct loaded_l10nfile **l10nfile_list,const char *dirlist, size_t dirlist_len, int mask,const char *language, const char *territory,const char *codeset,const char *normalized_codeset,const char *modifier, const char *special,const char *sponsor, const char *revision,const char *filename, int do_allocate)
</FUNCTION>
<STRUCT>
<NAME>Frame</NAME>
typedef struct {
	BonoboUIHandler  *uih;
	GtkWidget	*app;
	GtkWidget	*vbox;
	BonoboViewFrame *active_view_frame;
	GList           *view_list;
} Frame;
</STRUCT>
<STRUCT>
<NAME>Buffer</NAME>
typedef struct {
	BonoboClientSite   *client_site;
	BonoboObjectClient *server;
	gchar *name;
	gint menu_id;
} Buffer;
</STRUCT>
<STRUCT>
<NAME>Application</NAME>
typedef struct {
	BonoboContainer  *container;
	GList *frame_list;
	GList *buffer_list;
	GtkFileSelection *fs;
} Application;
</STRUCT>
<VARIABLE>
<NAME>app</NAME>
extern Application app;
</VARIABLE>
<FUNCTION>
<NAME>file_menu_kill_cb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler *uih, void *data, char *path
</FUNCTION>
<FUNCTION>
<NAME>view_menu_new_window_cb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler *uih, void *data, char *path
</FUNCTION>
<FUNCTION>
<NAME>view_menu_delete_window_cb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler *uih, void *data, char *path
</FUNCTION>
<FUNCTION>
<NAME>view_menu_split_window_cb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler *uih, void *data, char *path
</FUNCTION>
<FUNCTION>
<NAME>view_menu_one_window_cb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler *uih, void *data, char *path
</FUNCTION>
<FUNCTION>
<NAME>file_menu_exit_cb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler *uih, void *data, char *path
</FUNCTION>
<FUNCTION>
<NAME>edit_menu_preferences_cb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler *uih, void *data, char *path
</FUNCTION>
<FUNCTION>
<NAME>help_menu_about_cb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler *uih, void *data, char *path
</FUNCTION>
<FUNCTION>
<NAME>help_menu_help_gnome_cb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler *uih, void *data, char *path
</FUNCTION>
<FUNCTION>
<NAME>get_active_frame</NAME>
<RETURNS>Frame           *</RETURNS>
GtkWidget *widget
</FUNCTION>
<FUNCTION>
<NAME>get_active_view_frame</NAME>
<RETURNS>BonoboViewFrame  *</RETURNS>
Frame *frame
</FUNCTION>
<FUNCTION>
<NAME>buffer_create</NAME>
<RETURNS>Buffer          *</RETURNS>
const char *component_goad_id
</FUNCTION>
<FUNCTION>
<NAME>view_remove</NAME>
<RETURNS>gint  </RETURNS>
Frame *frame,BonoboViewFrame *view_frame
</FUNCTION>
<FUNCTION>
<NAME>buffer_add_view</NAME>
<RETURNS>void  </RETURNS>
Buffer *buffer,Frame *frame,gint pos
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_has_interface</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboObject *obj,char *interface
</FUNCTION>
<FUNCTION>
<NAME>set_buffer_cb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler *uih,void *buffer,const char *path
</FUNCTION>
<FUNCTION>
<NAME>open_files</NAME>
<RETURNS>void  </RETURNS>
Frame *frame,int argc, char **argv
</FUNCTION>
<FUNCTION>
<NAME>file_open</NAME>
<RETURNS>void  </RETURNS>
Frame *frame, char *name
</FUNCTION>
<FUNCTION>
<NAME>file_menu_open_cb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler *uih, void *data, char *path
</FUNCTION>
<FUNCTION>
<NAME>file_menu_save_as_cb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler *uih, void *data, char *path
</FUNCTION>
<FUNCTION>
<NAME>file_menu_save_cb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler *uih, void *data, char *path
</FUNCTION>
<FUNCTION>
<NAME>set_file_menu_state</NAME>
<RETURNS>void  </RETURNS>
Frame *frame, gboolean state
</FUNCTION>
<FUNCTION>
<NAME>set_edit_menu_state</NAME>
<RETURNS>void  </RETURNS>
Frame *frame, gboolean state
</FUNCTION>
<FUNCTION>
<NAME>frame_create_menus</NAME>
<RETURNS>void  </RETURNS>
Frame *frame
</FUNCTION>
<FUNCTION>
<NAME>frame_create_toolbar</NAME>
<RETURNS>void  </RETURNS>
Frame *frame
</FUNCTION>
<FUNCTION>
<NAME>update_buffer_menu</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>show_property_dialog</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame *cf
</FUNCTION>
<MACRO>
<NAME>GNOME_BIND_CONTEXT_TYPE</NAME>
#define GNOME_BIND_CONTEXT_TYPE        (gnome_bind_context_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_BIND_CONTEXT</NAME>
#define GNOME_BIND_CONTEXT(o)          (GTK_CHECK_CAST ((o), GNOME_BIND_CONTEXT_TYPE, GnomeBindContext))
</MACRO>
<MACRO>
<NAME>GNOME_BIND_CONTEXT_CLASS</NAME>
#define GNOME_BIND_CONTEXT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), GNOME_BIND_CONTEXT_TYPE, GnomeBindContextClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_BIND_CONTEXT</NAME>
#define GNOME_IS_BIND_CONTEXT(o)       (GTK_CHECK_TYPE ((o), GNOME_BIND_CONTEXT_TYPE))
</MACRO>
<MACRO>
<NAME>GNOME_IS_BIND_CONTEXT_CLASS</NAME>
#define GNOME_IS_BIND_CONTEXT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), GNOME_BIND_CONTEXT_TYPE))
</MACRO>
<STRUCT>
<NAME>GnomeBindContext</NAME>
typedef struct {
	BonoboObject base;
	GHashTable  *table;
} GnomeBindContext;
</STRUCT>
<FUNCTION>
<NAME>gnome_bind_context_new</NAME>
<RETURNS>GnomeBindContext  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_bind_context_construct</NAME>
<RETURNS>GnomeBindContext  *</RETURNS>
GnomeBindContext *bindctx,Bonobo_BindContext corba_bindctx
</FUNCTION>
<FUNCTION>
<NAME>gnome_bind_context_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_CANVAS_COMPONENT_TYPE</NAME>
#define BONOBO_CANVAS_COMPONENT_TYPE        (bonobo_canvas_component_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_CANVAS_COMPONENT</NAME>
#define BONOBO_CANVAS_COMPONENT(o)          (GTK_CHECK_CAST ((o), BONOBO_CANVAS_COMPONENT_TYPE, BonoboCanvasComponent))
</MACRO>
<MACRO>
<NAME>BONOBO_CANVAS_COMPONENT_CLASS</NAME>
#define BONOBO_CANVAS_COMPONENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_CANVAS_COMPONENT__TYPE, BonoboCanvasComponentClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CANVAS_COMPONENT</NAME>
#define BONOBO_IS_CANVAS_COMPONENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_CANVAS_COMPONENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CANVAS_COMPONENT_CLASS</NAME>
#define BONOBO_IS_CANVAS_COMPONENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_CANVAS_COMPONENT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboCanvasComponent</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboCanvasComponentPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboCanvasComponentClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboCanvasComponent</NAME>
struct BonoboCanvasComponent {
	BonoboObject base;
	BonoboCanvasComponentPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboCanvasComponentClass</NAME>
struct BonoboCanvasComponentClass {
	BonoboObjectClass parent_class;

	/*
	 * Signals
	 */
	 void (*set_bounds) (BonoboCanvasComponent *component, Bonobo_Canvas_DRect *bbox, CORBA_Environment *ev);
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_canvas_component_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_object_create</NAME>
<RETURNS>Bonobo_Canvas_Component  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_set_proxy</NAME>
<RETURNS>void  </RETURNS>
BonoboCanvasComponent *comp,Bonobo_Canvas_ComponentProxy proxy
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_construct</NAME>
<RETURNS>BonoboCanvasComponent  *</RETURNS>
BonoboCanvasComponent *comp,Bonobo_Canvas_Component    ccomp,GnomeCanvasItem     *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_new</NAME>
<RETURNS>BonoboCanvasComponent  *</RETURNS>
GnomeCanvasItem *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_get_item</NAME>
<RETURNS>GnomeCanvasItem       *</RETURNS>
BonoboCanvasComponent *comp
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_get_epv</NAME>
<RETURNS>POA_Bonobo_Canvas_Component__epv  *</RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>bonobo_canvas_component_vepv</NAME>
extern POA_Bonobo_Canvas_Component__vepv bonobo_canvas_component_vepv;
</VARIABLE>
<MACRO>
<NAME>BONOBO_CANVAS_ITEM</NAME>
#define BONOBO_CANVAS_ITEM(obj)          (GTK_CHECK_CAST((obj), bonobo_canvas_item_get_type (), BonoboCanvasItem))
</MACRO>
<MACRO>
<NAME>BONOBO_CANVAS_ITEM_CLASS</NAME>
#define BONOBO_CANVAS_ITEM_CLASS(k)      (GTK_CHECK_CLASS_CAST ((k), gnome_bonobo_get_type (), BonoboCanvasItemClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CANVAS_ITEM</NAME>
#define BONOBO_IS_CANVAS_ITEM(o)         (GTK_CHECK_TYPE((o), gnome_bonobo_get_type ()))
</MACRO>
<STRUCT>
<NAME>BonoboCanvasItemPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboCanvasItem</NAME>
typedef struct {
	GnomeCanvasItem         canvas_item;
	BonoboEmbeddable        *embeddable;
	BonoboCanvasItemPrivate *priv;
} BonoboCanvasItem;
</STRUCT>
<STRUCT>
<NAME>BonoboCanvasItemClass</NAME>
typedef struct {
	GnomeCanvasItemClass parent_class;
} BonoboCanvasItemClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_canvas_item_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_item_new</NAME>
<RETURNS>GnomeCanvasItem  *</RETURNS>
GnomeCanvasGroup  *parent,BonoboObjectClient *embeddable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_item_set_bounds</NAME>
<RETURNS>void 	</RETURNS>
BonoboCanvasItem *item, double x1, double y1, double x2, double y2
</FUNCTION>
<MACRO>
<NAME>BONOBO_CLIENT_SITE_TYPE</NAME>
#define BONOBO_CLIENT_SITE_TYPE        (bonobo_client_site_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_CLIENT_SITE</NAME>
#define BONOBO_CLIENT_SITE(o)          (GTK_CHECK_CAST ((o), BONOBO_CLIENT_SITE_TYPE, BonoboClientSite))
</MACRO>
<MACRO>
<NAME>BONOBO_CLIENT_SITE_CLASS</NAME>
#define BONOBO_CLIENT_SITE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_CLIENT_SITE_TYPE, BonoboClientSiteClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CLIENT_SITE</NAME>
#define BONOBO_IS_CLIENT_SITE(o)       (GTK_CHECK_TYPE ((o), BONOBO_CLIENT_SITE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CLIENT_SITE_CLASS</NAME>
#define BONOBO_IS_CLIENT_SITE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_CLIENT_SITE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboClientSite</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboClientSitePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboClientSite</NAME>
struct BonoboClientSite {
	BonoboObject base;

	BonoboContainer    *container;
	BonoboObjectClient *bound_object;
	GList		  *view_frames;
	GList             *canvas_items;
	int               child_shown:1;

	BonoboClientSitePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboClientSiteClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	void (*show_window)  (BonoboClientSite *, CORBA_boolean shown);
	void (*queue_resize) (BonoboClientSite *);
	void (*save_object)  (BonoboClientSite *, Bonobo_Persist_Status *status);
} BonoboClientSiteClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_client_site_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_new</NAME>
<RETURNS>BonoboClientSite            *</RETURNS>
BonoboContainer    *container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_construct</NAME>
<RETURNS>BonoboClientSite            *</RETURNS>
BonoboClientSite   *client_site,Bonobo_ClientSite   corba_client_site,BonoboContainer    *container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_bind_embeddable</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboClientSite   *client_site,BonoboObjectClient *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_get_embeddable</NAME>
<RETURNS>BonoboObjectClient          *</RETURNS>
BonoboClientSite   *client_site
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_new_view_full</NAME>
<RETURNS>BonoboViewFrame             *</RETURNS>
BonoboClientSite   *client_site,Bonobo_UIHandler    uih,gboolean            visible_cover,gboolean            active_view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_new_view</NAME>
<RETURNS>BonoboViewFrame             *</RETURNS>
BonoboClientSite   *client_site,Bonobo_UIHandler    uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_new_item</NAME>
<RETURNS>GnomeCanvasItem             *</RETURNS>
BonoboClientSite   *client_site,GnomeCanvasGroup   *group
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_get_verbs</NAME>
<RETURNS>GList                       *</RETURNS>
BonoboClientSite   *client_site
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_free_verbs</NAME>
<RETURNS>void  </RETURNS>
GList              *verb_list
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_get_epv</NAME>
<RETURNS>POA_Bonobo_ClientSite__epv  *</RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>bonobo_client_site_vepv</NAME>
extern POA_Bonobo_ClientSite__vepv bonobo_client_site_vepv;
</VARIABLE>
<ENUM>
<NAME>GnomeComponentFunctionality</NAME>
typedef enum {
	COMPONENT_FUNCTION_DISPLAY = 1 << 0,
	COMPONENT_FUNCTION_EDIT = 1 << 1,
	COMPONENT_FUNCTION_PRINT = 1 << 2,
	COMPONENT_FUNCTION_INPLACE = 1 << 3
} GnomeComponentFunctionality;
</ENUM>
<STRUCT>
<NAME>GnomeComponentDirectoryEntry</NAME>
typedef struct {
	char *goad_id;
	char **mime_types;
	GnomeComponentFunctionality functionality;
} GnomeComponentDirectoryEntry;
</STRUCT>
<STRUCT>
<NAME>GnomeComponentDirectory</NAME>
typedef struct {
	/* value is a BonoboDirectoryEntry pointer */
	GSList *list;
	/* value is a BonoboDirectoryEntry pointer */
	GHashTable *by_id;
	/* value is a GSList pointer */
	GHashTable *by_mime_type;
} GnomeComponentDirectory;
</STRUCT>
<FUNCTION>
<NAME>gnome_component_activate</NAME>
<RETURNS>CORBA_Object  </RETURNS>
GoadServerList *slist,GnomeComponentDirectoryEntry *entry
</FUNCTION>
<FUNCTION>
<NAME>gnome_component_activate_for_type</NAME>
<RETURNS>CORBA_Object  </RETURNS>
GoadServerList *slist,GnomeComponentDirectory *dir,const char *mime_type,GnomeComponentFunctionality required_functionality
</FUNCTION>
<FUNCTION>
<NAME>gnome_component_activate_for_url</NAME>
<RETURNS>CORBA_Object  </RETURNS>
GoadServerList *slist,GnomeComponentDirectory *dir,const char *url,GnomeComponentFunctionality required_functionality
</FUNCTION>
<FUNCTION>
<NAME>gnome_component_directory_get</NAME>
<RETURNS>GnomeComponentDirectory  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_component_directory_free</NAME>
<RETURNS>void  </RETURNS>
GnomeComponentDirectory *dir
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_load</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboStorage *storage,const char *interface,BonoboClientSite *client_site
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_save</NAME>
<RETURNS>int  </RETURNS>
BonoboEmbeddable *bonobo_object,BonoboStorage   *storage,gboolean       same_as_loaded
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_load_from_stream</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboStream *stream,const char *interface
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_save_to_stream</NAME>
<RETURNS>int  </RETURNS>
BonoboEmbeddable *bonobo_object,BonoboStream    *stream
</FUNCTION>
<FUNCTION>
<NAME>gnome_get_class_id_from_file</NAME>
<RETURNS>char               *</RETURNS>
const char *filename
</FUNCTION>
<STRUCT>
<NAME>GnomeCompositeMoniker</NAME>
typedef struct {
	BonoboMoniker moniker;
} GnomeCompositeMoniker;
</STRUCT>
<FUNCTION>
<NAME>gnome_composite_moniker_new</NAME>
<RETURNS>GnomeCompositeMoniker  *</RETURNS>
BonoboMoniker *head,BonoboMoniker *tail
</FUNCTION>
<MACRO>
<NAME>BONOBO_CONTAINER_TYPE</NAME>
#define BONOBO_CONTAINER_TYPE        (bonobo_container_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_CONTAINER</NAME>
#define BONOBO_CONTAINER(o)          (GTK_CHECK_CAST ((o), BONOBO_CONTAINER_TYPE, BonoboContainer))
</MACRO>
<MACRO>
<NAME>BONOBO_CONTAINER_CLASS</NAME>
#define BONOBO_CONTAINER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_CONTAINER_TYPE, BonoboContainerClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTAINER</NAME>
#define BONOBO_IS_CONTAINER(o)       (GTK_CHECK_TYPE ((o), BONOBO_CONTAINER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTAINER_CLASS</NAME>
#define BONOBO_IS_CONTAINER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_CONTAINER_TYPE))
</MACRO>
<TYPEDEF>
<NAME>BonoboClientSiteList</NAME>
typedef GList BonoboClientSiteList;
</TYPEDEF>
<STRUCT>
<NAME>BonoboContainerPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboContainer</NAME>
typedef struct {
	BonoboObject base;

	BonoboClientSiteList *client_sites;
	
	BonoboMoniker *moniker;

	BonoboContainerPrivate *priv;
} BonoboContainer;
</STRUCT>
<STRUCT>
<NAME>BonoboContainerClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	Bonobo_Unknown (*get_object) (BonoboContainer *item_container,
				      CORBA_char *item_name,
				      CORBA_boolean *only_if_exists,
				      CORBA_Environment *ev);
} BonoboContainerClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_container_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_container_new</NAME>
<RETURNS>BonoboContainer   *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_container_construct</NAME>
<RETURNS>BonoboContainer   *</RETURNS>
BonoboContainer *container,Bonobo_Container container_corba
</FUNCTION>
<FUNCTION>
<NAME>bonobo_container_get_moniker</NAME>
<RETURNS>BonoboMoniker     *</RETURNS>
BonoboContainer *container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_container_add</NAME>
<RETURNS>void  </RETURNS>
BonoboContainer *container,BonoboObject    *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_container_remove</NAME>
<RETURNS>void  </RETURNS>
BonoboContainer *container,BonoboObject    *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_container_get_epv</NAME>
<RETURNS>POA_Bonobo_Container__epv  *</RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>bonobo_container_epv</NAME>
extern POA_Bonobo_Container__epv bonobo_container_epv;
</VARIABLE>
<VARIABLE>
<NAME>bonobo_container_vepv</NAME>
extern POA_Bonobo_Container__vepv bonobo_container_vepv;
</VARIABLE>
<MACRO>
<NAME>BONOBO_CONTROL_FRAME_TYPE</NAME>
#define BONOBO_CONTROL_FRAME_TYPE        (bonobo_control_frame_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_CONTROL_FRAME</NAME>
#define BONOBO_CONTROL_FRAME(o)          (GTK_CHECK_CAST ((o), BONOBO_CONTROL_FRAME_TYPE, BonoboControlFrame))
</MACRO>
<MACRO>
<NAME>BONOBO_CONTROL_FRAME_CLASS</NAME>
#define BONOBO_CONTROL_FRAME_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_CONTROL_FRAME_TYPE, BonoboControlFrameClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTROL_FRAME</NAME>
#define BONOBO_IS_CONTROL_FRAME(o)       (GTK_CHECK_TYPE ((o), BONOBO_CONTROL_FRAME_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTROL_FRAME_CLASS</NAME>
#define BONOBO_IS_CONTROL_FRAME_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_CONTROL_FRAME_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboControlFramePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboControlFrame</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboControlFrame</NAME>
struct BonoboControlFrame {
	BonoboObject base;
	BonoboControlFramePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboControlFrameClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * Signals.
	 */
	void (*activated)           (BonoboControlFrame *control_frame, gboolean state);
	void (*activate_uri)        (BonoboControlFrame *control_frame, const char *uri, gboolean relative);
	void (*undo_last_operation) (BonoboControlFrame *view_frame);

} BonoboControlFrameClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_control_frame_new</NAME>
<RETURNS>BonoboControlFrame            *</RETURNS>
Bonobo_UIHandler     uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_widget</NAME>
<RETURNS>GtkWidget                     *</RETURNS>
BonoboControlFrame  *frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_control_activate</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_control_deactivate</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_set_autoactivate</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,gboolean             autoactivate
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_autoactivate</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_control_property_bag</NAME>
<RETURNS>BonoboPropertyBagClient       *</RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_set_propbag</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,BonoboPropertyBag   *propbag
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_propbag</NAME>
<RETURNS>BonoboPropertyBag             *</RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_control_set_state</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,GtkStateType         state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_set_autostate</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,gboolean             autostate
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_autostate</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_bind_to_control</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,Bonobo_Control       control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_control</NAME>
<RETURNS>Bonobo_Control  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_ui_handler</NAME>
<RETURNS>Bonobo_UIHandler  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_construct</NAME>
<RETURNS>BonoboControlFrame            *</RETURNS>
BonoboControlFrame  *control_frame,Bonobo_ControlFrame  corba_control_frame,Bonobo_UIHandler     uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_epv</NAME>
<RETURNS>POA_Bonobo_ControlFrame__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_size_request</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame *control_frame,int *desired_width,int *desired_height
</FUNCTION>
<VARIABLE>
<NAME>bonobo_control_frame_epv</NAME>
extern POA_Bonobo_ControlFrame__epv  bonobo_control_frame_epv;
</VARIABLE>
<VARIABLE>
<NAME>bonobo_control_frame_vepv</NAME>
extern POA_Bonobo_ControlFrame__vepv bonobo_control_frame_vepv;
</VARIABLE>
<MACRO>
<NAME>BONOBO_CONTROL_TYPE</NAME>
#define BONOBO_CONTROL_TYPE        (bonobo_control_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_CONTROL</NAME>
#define BONOBO_CONTROL(o)          (GTK_CHECK_CAST ((o), BONOBO_CONTROL_TYPE, BonoboControl))
</MACRO>
<MACRO>
<NAME>BONOBO_CONTROL_CLASS</NAME>
#define BONOBO_CONTROL_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_CONTROL_TYPE, BonoboControlClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTROL</NAME>
#define BONOBO_IS_CONTROL(o)       (GTK_CHECK_TYPE ((o), BONOBO_CONTROL_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTROL_CLASS</NAME>
#define BONOBO_IS_CONTROL_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_CONTROL_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboControl</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboControlPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboControlClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboControl</NAME>
struct BonoboControl {
	BonoboObject base;

	BonoboControlPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboControlClass</NAME>
struct BonoboControlClass {
	BonoboObjectClass parent_class;

	/*
	 * Signals.
	 */
	void (*set_frame)           (BonoboControl *control);
	void (*activate)            (BonoboControl *control, gboolean state);
	void (*undo_last_operation) (BonoboControl *control);
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_control_new</NAME>
<RETURNS>BonoboControl               *</RETURNS>
GtkWidget     *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_widget</NAME>
<RETURNS>GtkWidget                   *</RETURNS>
BonoboControl *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_automerge</NAME>
<RETURNS>void  </RETURNS>
BonoboControl *control,gboolean       automerge
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_automerge</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboControl *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_menus</NAME>
<RETURNS>void  </RETURNS>
BonoboControl *control,GnomeUIInfo   *menus
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_menus_with_data</NAME>
<RETURNS>void  </RETURNS>
BonoboControl *control,GnomeUIInfo   *menus,gpointer       closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_menus</NAME>
<RETURNS>BonoboUIHandlerMenuItem     *</RETURNS>
BonoboControl *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_toolbars</NAME>
<RETURNS>void  </RETURNS>
BonoboControl *control,GnomeUIInfo   *toolbars
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_toolbars_with_data</NAME>
<RETURNS>void  </RETURNS>
BonoboControl *control,GnomeUIInfo   *toolbars,gpointer       closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_toolbars</NAME>
<RETURNS>BonoboUIHandlerToolbarItem  *</RETURNS>
BonoboControl *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_property</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,const char          *first_prop,...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_property</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,const char          *first_prop,...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_construct</NAME>
<RETURNS>BonoboControl               *</RETURNS>
BonoboControl       *control,Bonobo_Control       corba_control,GtkWidget           *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_corba_object_create</NAME>
<RETURNS>Bonobo_Control  </RETURNS>
BonoboObject        *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_control_frame</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,Bonobo_ControlFrame  control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_control_frame</NAME>
<RETURNS>Bonobo_ControlFrame  </RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_ui_handler</NAME>
<RETURNS>BonoboUIHandler             *</RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_property_bag</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,BonoboPropertyBag   *pb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_property_bag</NAME>
<RETURNS>BonoboPropertyBag           *</RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_remote_ui_handler</NAME>
<RETURNS>Bonobo_UIHandler  </RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_ambient_properties</NAME>
<RETURNS>BonoboPropertyBagClient     *</RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_activate_notify</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,gboolean             activated
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_windowid_from_x11</NAME>
<RETURNS>Bonobo_Control_windowid  </RETURNS>
guint32              x11_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_epv</NAME>
<RETURNS>POA_Bonobo_Control__epv     *</RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>bonobo_control_epv</NAME>
extern POA_Bonobo_Control__epv bonobo_control_epv;
</VARIABLE>
<VARIABLE>
<NAME>bonobo_control_vepv</NAME>
extern POA_Bonobo_Control__vepv bonobo_control_vepv;
</VARIABLE>
<MACRO>
<NAME>BONOBO_DESKTOP_WINDOW_TYPE</NAME>
#define BONOBO_DESKTOP_WINDOW_TYPE        (bonobo_desktop_window_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_DESKTOP_WINDOW</NAME>
#define BONOBO_DESKTOP_WINDOW(o)          (GTK_CHECK_CAST ((o), BONOBO_DESKTOP_WINDOW_TYPE, BonoboDesktopWindow))
</MACRO>
<MACRO>
<NAME>BONOBO_DESKTOP_WINDOW_CLASS</NAME>
#define BONOBO_DESKTOP_WINDOW_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_DESKTOP_WINDOW_TYPE, BonoboDesktopWindowClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_DESKTOP_WINDOW</NAME>
#define BONOBO_IS_DESKTOP_WINDOW(o)       (GTK_CHECK_TYPE ((o), BONOBO_DESKTOP_WINDOW_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_DESKTOP_WINDOW_CLASS</NAME>
#define BONOBO_IS_DESKTOP_WINDOW_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_DESKTOP_WINDOW_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboDesktopWindow</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboDesktopWindowPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboDesktopWindowClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboDesktopWindow</NAME>
struct BonoboDesktopWindow {
	BonoboObject base;
	GtkWindow   *window;
	BonoboDesktopWindowPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboDesktopWindowClass</NAME>
struct BonoboDesktopWindowClass {
	BonoboObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_desktop_window_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_desktop_window_construct</NAME>
<RETURNS>BonoboDesktopWindow  *</RETURNS>
BonoboDesktopWindow *desktop_window,Bonobo_Desktop_Window corba_desktop_window,GtkWindow *toplevel
</FUNCTION>
<FUNCTION>
<NAME>bonobo_desktop_window_new</NAME>
<RETURNS>BonoboDesktopWindow  *</RETURNS>
GtkWindow *toplevel
</FUNCTION>
<FUNCTION>
<NAME>bonobo_desktop_window_control</NAME>
<RETURNS>void  </RETURNS>
BonoboObject *object,GtkWindow *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_desktop_window_corba_object_create</NAME>
<RETURNS>Bonobo_Desktop_Window  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_desktop_window_get_epv</NAME>
<RETURNS>POA_Bonobo_Desktop_Window__epv  *</RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>bonobo_desktop_window_vepv</NAME>
extern POA_Bonobo_Desktop_Window__vepv bonobo_desktop_window_vepv;
</VARIABLE>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_FACTORY_TYPE</NAME>
#define BONOBO_EMBEDDABLE_FACTORY_TYPE        BONOBO_GENERIC_FACTORY_TYPE
</MACRO>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_FACTORY</NAME>
#define BONOBO_EMBEDDABLE_FACTORY(o)          BONOBO_GENERIC_FACTORY(o)
</MACRO>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_FACTORY_CLASS</NAME>
#define BONOBO_EMBEDDABLE_FACTORY_CLASS(k)    BONOBO_GENERIC_FACTORY_CLASS(k)
</MACRO>
<MACRO>
<NAME>BONOBO_IS_EMBEDDABLE_FACTORY</NAME>
#define BONOBO_IS_EMBEDDABLE_FACTORY(o)       BONOBO_IS_GENERIC_FACTORY(o)
</MACRO>
<MACRO>
<NAME>BONOBO_IS_EMBEDDABLE_FACTORY_CLASS</NAME>
#define BONOBO_IS_EMBEDDABLE_FACTORY_CLASS(k) BONOBO_IS_GENERIC_FACTORY_CLASS(k)
</MACRO>
<TYPEDEF>
<NAME>BonoboEmbeddableFactory</NAME>
typedef BonoboGenericFactory BonoboEmbeddableFactory;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboEmbeddableFactoryClass</NAME>
typedef BonoboGenericFactoryClass BonoboEmbeddableFactoryClass;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboEmbeddableFactoryFn</NAME>
typedef BonoboGenericFactoryFn BonoboEmbeddableFactoryFn;
</TYPEDEF>
<MACRO>
<NAME>bonobo_embeddable_factory_get_type</NAME>
#define bonobo_embeddable_factory_get_type  bonobo_generic_factory_get_type
</MACRO>
<MACRO>
<NAME>bonobo_embeddable_factory_new</NAME>
#define bonobo_embeddable_factory_new       bonobo_generic_factory_new
</MACRO>
<MACRO>
<NAME>bonobo_embeddable_factory_construct</NAME>
#define bonobo_embeddable_factory_construct bonobo_generic_factory_construct
</MACRO>
<MACRO>
<NAME>bonobo_embeddable_factory_set</NAME>
#define bonobo_embeddable_factory_set       bonobo_generic_factory_set
</MACRO>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_TYPE</NAME>
#define BONOBO_EMBEDDABLE_TYPE        (bonobo_embeddable_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_EMBEDDABLE</NAME>
#define BONOBO_EMBEDDABLE(o)          (GTK_CHECK_CAST ((o), BONOBO_EMBEDDABLE_TYPE, BonoboEmbeddable))
</MACRO>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_CLASS</NAME>
#define BONOBO_EMBEDDABLE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_EMBEDDABLE_TYPE, BonoboEmbeddableClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_EMBEDDABLE</NAME>
#define BONOBO_IS_EMBEDDABLE(o)       (GTK_CHECK_TYPE ((o), BONOBO_EMBEDDABLE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_EMBEDDABLE_CLASS</NAME>
#define BONOBO_IS_EMBEDDABLE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_EMBEDDABLE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboEmbeddable</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboEmbeddablePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeVerb</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_VIEW_FACTORY</NAME>
#define BONOBO_VIEW_FACTORY(fn) ((BonoboViewFactory)(fn))
</MACRO>
<USER_FUNCTION>
<NAME>BonoboViewFactory</NAME>
<RETURNS>BonoboView *</RETURNS>
BonoboEmbeddable *embeddable, const Bonobo_ViewFrame view_frame, void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeItemCreator</NAME>
<RETURNS>BonoboCanvasComponent *</RETURNS>
BonoboEmbeddable *embeddable, GnomeCanvas *canvas, void *user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboEmbeddableForeachViewFn</NAME>
<RETURNS>void </RETURNS>
BonoboView *view, void *data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboEmbeddableForeachItemFn</NAME>
<RETURNS>void </RETURNS>
BonoboCanvasComponent *comp, void *data
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboEmbeddable</NAME>
struct BonoboEmbeddable {
	BonoboObject base;

	char *host_name;
	char *host_appname;
	Bonobo_ClientSite client_site;

	/*
	 * A list of GnomeVerb structures for the verbs supported by
	 * this component.
	 */
	GList *verbs;

	/*
	 * The URI this component represents
	 */
	char *uri;
	
	BonoboEmbeddablePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboEmbeddableClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * Signals
	 */
	void (*host_name_changed)  (BonoboEmbeddable *comp, const char *hostname);
	void (*uri_changed)        (BonoboEmbeddable *comp, const char *uri);
} BonoboEmbeddableClass;
</STRUCT>
<STRUCT>
<NAME>GnomeVerb</NAME>
struct GnomeVerb {
	/*
	 * A unique string which identifies this verb.  This is the
	 * string which is used to activate the verb.
	 *
	 * Example: "next_page"
	 */
	char *name;

	/*
	 * A string which specifies the action the verb performs.
	 * This verb may be translated to the locale of the user
	 * and used as an entry in a popup menu.
	 *
	 * Example: "_Next Page"
	 */
	char *label;

	/*
	 * A string which gives a slightly more verbose description of
	 * the verb, for use in tooltips or status bars.  This string
	 * may be translated to the user's locale.
	 *
	 * Example: "Turn to the next page"
	 */
	char *hint;
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_embeddable_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_new</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboViewFactory  factory,void              *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_new_canvas_item</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
GnomeItemCreator item_factory,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_construct</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboEmbeddable *embeddable,Bonobo_Embeddable corba_embeddable,BonoboViewFactory factory,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_construct_full</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboEmbeddable *embeddable,Bonobo_Embeddable corba_embeddable,BonoboViewFactory factory,void *factory_data,GnomeItemCreator item_factory,void *item_factory_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_corba_object_create</NAME>
<RETURNS>Bonobo_Embeddable  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_add_verb</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,const char *verb_name,const char *verb_label,const char *verb_hint
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_add_verbs</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,const GnomeVerb *verbs
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_remove_verb</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,const char *verb_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_set_view_factory</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,BonoboViewFactory factory,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_get_verbs</NAME>
<RETURNS>const GList 	*</RETURNS>
BonoboEmbeddable *embeddable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_get_uri</NAME>
<RETURNS>const char       *</RETURNS>
BonoboEmbeddable *embeddable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_set_uri</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,const char *uri
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_foreach_view</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,BonoboEmbeddableForeachViewFn fn,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_foreach_item</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,BonoboEmbeddableForeachItemFn fn,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_get_epv</NAME>
<RETURNS>POA_Bonobo_Embeddable__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GNOME_FILE_MONIKER_TYPE</NAME>
#define GNOME_FILE_MONIKER_TYPE        (gnome_file_moniker_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_FILE_MONIKER</NAME>
#define GNOME_FILE_MONIKER(o)          (GTK_CHECK_CAST ((o), GNOME_FILE_MONIKER_TYPE, GnomeFileMoniker))
</MACRO>
<MACRO>
<NAME>GNOME_FILE_MONIKER_CLASS</NAME>
#define GNOME_FILE_MONIKER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), GNOME_FILE_MONIKER_TYPE, GnomeFileMonikerClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_FILE_MONIKER</NAME>
#define GNOME_IS_FILE_MONIKER(o)       (GTK_CHECK_TYPE ((o), GNOME_FILE_MONIKER_TYPE))
</MACRO>
<MACRO>
<NAME>GNOME_IS_FILE_MONIKER_CLASS</NAME>
#define GNOME_IS_FILE_MONIKER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), GNOME_FILE_MONIKER_TYPE))
</MACRO>
<MACRO>
<NAME>GNOME_FILE_MONIKER_GOAD_ID</NAME>
#define GNOME_FILE_MONIKER_GOAD_ID "GOAD:GNOME:Moniker:File:1.0"
</MACRO>
<STRUCT>
<NAME>GnomeFileMoniker</NAME>
typedef struct {
	BonoboMoniker moniker;
	char *goad_id;
	char *filename;
} GnomeFileMoniker;
</STRUCT>
<FUNCTION>
<NAME>gnome_file_moniker_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_file_moniker_new</NAME>
<RETURNS>GnomeFileMoniker  *</RETURNS>
const char *filename,const char *goad_id
</FUNCTION>
<FUNCTION>
<NAME>gnome_file_moniker_construct</NAME>
<RETURNS>GnomeFileMoniker  *</RETURNS>
GnomeFileMoniker *gfm,Bonobo_Moniker gfm_corba,const char *filename,const char *goad_id
</FUNCTION>
<MACRO>
<NAME>BONOBO_GENERIC_FACTORY_TYPE</NAME>
#define BONOBO_GENERIC_FACTORY_TYPE        (bonobo_generic_factory_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_GENERIC_FACTORY</NAME>
#define BONOBO_GENERIC_FACTORY(o)          (GTK_CHECK_CAST ((o), BONOBO_GENERIC_FACTORY_TYPE, BonoboGenericFactory))
</MACRO>
<MACRO>
<NAME>BONOBO_GENERIC_FACTORY_CLASS</NAME>
#define BONOBO_GENERIC_FACTORY_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_GENERIC_FACTORY_TYPE, BonoboGenericFactoryClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_GENERIC_FACTORY</NAME>
#define BONOBO_IS_GENERIC_FACTORY(o)       (GTK_CHECK_TYPE ((o), BONOBO_GENERIC_FACTORY_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_GENERIC_FACTORY_CLASS</NAME>
#define BONOBO_IS_GENERIC_FACTORY_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_GENERIC_FACTORY_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboGenericFactory</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboGenericFactoryPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboGenericFactoryFn</NAME>
<RETURNS>BonoboObject *</RETURNS>
BonoboGenericFactory *Factory, void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeFactoryCallback</NAME>
<RETURNS>BonoboObject *</RETURNS>
BonoboGenericFactory *factory, const char *goad_id, gpointer closure
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboGenericFactory</NAME>
struct BonoboGenericFactory {
	BonoboObject base;

	/*
	 * The function factory
	 */
	BonoboGenericFactoryFn factory; /* compat reasons only */
	GnomeFactoryCallback factory_cb;
	gpointer factory_closure;

	/*
	 * The goad_id for this generic factory
	 */
	char *goad_id;
};
</STRUCT>
<STRUCT>
<NAME>BonoboGenericFactoryClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * Virtual methods
	 */
	BonoboObject * (*new_generic)(BonoboGenericFactory *c_factory, const char *goad_id);
} BonoboGenericFactoryClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_generic_factory_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_new</NAME>
<RETURNS>BonoboGenericFactory  *</RETURNS>
const char *goad_id,BonoboGenericFactoryFn factory,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_new_multi</NAME>
<RETURNS>BonoboGenericFactory  *</RETURNS>
const char *goad_id,GnomeFactoryCallback factory_cb,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_construct</NAME>
<RETURNS>BonoboGenericFactory  *</RETURNS>
const char *goad_id,BonoboGenericFactory  *c_factory,CORBA_Object          corba_factory,BonoboGenericFactoryFn factory,GnomeFactoryCallback factory_cb,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_set</NAME>
<RETURNS>void  </RETURNS>
BonoboGenericFactory *c_factory,BonoboGenericFactoryFn factory,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_get_epv</NAME>
<RETURNS>POA_Bonobo_GenericFactory__epv  *</RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>bonobo_generic_factory_vepv</NAME>
extern POA_Bonobo_GenericFactory__vepv bonobo_generic_factory_vepv;
</VARIABLE>
<MACRO>
<NAME>GNOME_ITEM_MONIKER_TYPE</NAME>
#define GNOME_ITEM_MONIKER_TYPE        (gnome_item_moniker_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_ITEM_MONIKER</NAME>
#define GNOME_ITEM_MONIKER(o)          (GTK_CHECK_CAST ((o), GNOME_ITEM_MONIKER_TYPE, GnomeItemMoniker))
</MACRO>
<MACRO>
<NAME>GNOME_ITEM_MONIKER_CLASS</NAME>
#define GNOME_ITEM_MONIKER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), GNOME_ITEM_MONIKER_TYPE, GnomeItemMonikerClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_ITEM_MONIKER</NAME>
#define GNOME_IS_ITEM_MONIKER(o)       (GTK_CHECK_TYPE ((o), GNOME_ITEM_MONIKER_TYPE))
</MACRO>
<MACRO>
<NAME>GNOME_IS_ITEM_MONIKER_CLASS</NAME>
#define GNOME_IS_ITEM_MONIKER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), GNOME_ITEM_MONIKER_TYPE))
</MACRO>
<MACRO>
<NAME>GNOME_ITEM_MONIKER_GOAD_ID</NAME>
#define GNOME_ITEM_MONIKER_GOAD_ID "GOAD:GNOME:Moniker:Item:1.0"
</MACRO>
<STRUCT>
<NAME>GnomeItemMoniker</NAME>
typedef struct {
	BonoboMoniker moniker;

	char  delimited;
	char *item_name;
} GnomeItemMoniker;
</STRUCT>
<FUNCTION>
<NAME>gnome_item_moniker_new</NAME>
<RETURNS>GnomeItemMoniker  *</RETURNS>
char delimiter,const char *item_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_init</NAME>
<RETURNS>gboolean 	</RETURNS>
CORBA_ORB orb,PortableServer_POA poa,PortableServer_POAManager manager
</FUNCTION>
<FUNCTION>
<NAME>bonobo_main</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_activate</NAME>
<RETURNS>gboolean 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_setup_x_error_handler</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_orb</NAME>
<RETURNS>CORBA_ORB 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_poa</NAME>
<RETURNS>PortableServer_POA 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_poa_manager</NAME>
<RETURNS>PortableServer_POAManager  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_find_in_naming_service</NAME>
<RETURNS>CORBA_Object  </RETURNS>
const char *name,const char *goad_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_register</NAME>
<RETURNS>void  </RETURNS>
BonoboMoniker *moniker,const char   *name,const char   *goad_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_unregister</NAME>
<RETURNS>void  </RETURNS>
BonoboMoniker *moniker
</FUNCTION>
<MACRO>
<NAME>BONOBO_MONIKER_TYPE</NAME>
#define BONOBO_MONIKER_TYPE        (bonobo_moniker_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_MONIKER</NAME>
#define BONOBO_MONIKER(o)          (GTK_CHECK_CAST ((o), BONOBO_MONIKER_TYPE, BonoboMoniker))
</MACRO>
<MACRO>
<NAME>BONOBO_MONIKER_CLASS</NAME>
#define BONOBO_MONIKER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_MONIKER_TYPE, BonoboMonikerClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_MONIKER</NAME>
#define BONOBO_IS_MONIKER(o)       (GTK_CHECK_TYPE ((o), BONOBO_MONIKER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_MONIKER_CLASS</NAME>
#define BONOBO_IS_MONIKER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_MONIKER_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboMoniker</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboMonikerPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboMoniker</NAME>
struct BonoboMoniker {
	GtkObject parent;

	char *goadid, *url;
	GList *items;
	BonoboMonikerPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboMonikerClass</NAME>
typedef struct {
	GtkObjectClass parent_class;
} BonoboMonikerClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_moniker_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_new</NAME>
<RETURNS>BonoboMoniker 	 *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_set_server</NAME>
<RETURNS>void  </RETURNS>
BonoboMoniker *moniker,const char *goad_id,const char *filename
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_append_item_name</NAME>
<RETURNS>void  </RETURNS>
BonoboMoniker *moniker,const char *item_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_get_as_string</NAME>
<RETURNS>char              *</RETURNS>
BonoboMoniker *moniker
</FUNCTION>
<MACRO>
<NAME>BONOBO_OBJECT_CLIENT_TYPE</NAME>
#define BONOBO_OBJECT_CLIENT_TYPE        (bonobo_object_client_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_OBJECT_CLIENT</NAME>
#define BONOBO_OBJECT_CLIENT(o)          (GTK_CHECK_CAST ((o), BONOBO_OBJECT_CLIENT_TYPE, BonoboObjectClient))
</MACRO>
<MACRO>
<NAME>BONOBO_OBJECT_CLIENT_CLASS</NAME>
#define BONOBO_OBJECT_CLIENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_OBJECT_CLIENT_TYPE, BonoboObjectClientClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_OBJECT_CLIENT</NAME>
#define BONOBO_IS_OBJECT_CLIENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_OBJECT_CLIENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_OBJECT_CLIENT_CLASS</NAME>
#define BONOBO_IS_OBJECT_CLIENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_OBJECT_CLIENT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboObjectClient</NAME>
typedef struct {
	BonoboObject parent;
} BonoboObjectClient;
</STRUCT>
<STRUCT>
<NAME>BonoboObjectClientClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;
} BonoboObjectClientClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_object_client_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_from_corba</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
Bonobo_Unknown o
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_construct</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
BonoboObjectClient *object_client,CORBA_Object corba_object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_activate</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
const char *object_desc,gint oaf_or_goad_flags
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_activate_with_goad_id</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
gpointer dummy,const char *goad_id,gint        goad_flags,const char **params
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_activate_with_oaf_id</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
const char *oaf_id,gint flags
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_restore_from_url</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
const char *goad_id,const char *url
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_has_interface</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboObjectClient *object,const char *interface_desc,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_query_interface</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboObjectClient *object,const char *interface_desc,CORBA_Environment *opt_ev
</FUNCTION>
<STRUCT>
<NAME>ODServerInfo</NAME>
</STRUCT>
<ENUM>
<NAME>ODRegistrationResult</NAME>
typedef enum {
        OD_REG_SUCCESS,
        OD_REG_NOT_LISTED,
        OD_REG_ALREADY_ACTIVE,
        OD_REG_ERROR
} ODRegistrationResult;
</ENUM>
<FUNCTION>
<NAME>od_get_orb</NAME>
<RETURNS>CORBA_ORB  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>od_server_info_new</NAME>
<RETURNS>ODServerInfo         *</RETURNS>
const gchar       *iid,const gchar       *name,const gchar       *desc
</FUNCTION>
<FUNCTION>
<NAME>od_server_info_get_id</NAME>
<RETURNS>const gchar          *</RETURNS>
ODServerInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>od_server_info_get_name</NAME>
<RETURNS>const gchar          *</RETURNS>
ODServerInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>od_server_info_get_description</NAME>
<RETURNS>const gchar          *</RETURNS>
ODServerInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>od_server_info_ref</NAME>
<RETURNS>void  </RETURNS>
ODServerInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>od_server_info_unref</NAME>
<RETURNS>void  </RETURNS>
ODServerInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>od_get_server_list</NAME>
<RETURNS>GList                *</RETURNS>
const gchar      **required_ids
</FUNCTION>
<FUNCTION>
<NAME>od_server_list_free</NAME>
<RETURNS>void  </RETURNS>
GList             *list
</FUNCTION>
<FUNCTION>
<NAME>od_server_activate_with_id</NAME>
<RETURNS>CORBA_Object  </RETURNS>
const gchar       *iid,gint               flags,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>od_server_register</NAME>
<RETURNS>ODRegistrationResult  </RETURNS>
CORBA_Object       objref,const gchar       *iid
</FUNCTION>
<FUNCTION>
<NAME>od_server_unregister</NAME>
<RETURNS>ODRegistrationResult  </RETURNS>
CORBA_Object       objref,const gchar       *iid
</FUNCTION>
<FUNCTION>
<NAME>od_assert_using_goad</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>od_assert_using_oaf</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>od_name_service_get</NAME>
<RETURNS>CORBA_Object  </RETURNS>
CORBA_Environment *ev
</FUNCTION>
<ENUM>
<NAME>GnomeIOStatus</NAME>
typedef enum {
	GNOME_IO_OK,
	
	/* Generic error */
	GNOME_IOERR_GENERAL,

	/* PersistStorage interface not supported by object */
	GNOME_IOERR_PERSIST_NOT_SUPPORTED
	
} GnomeIOStatus;
</ENUM>
<FUNCTION>
<NAME>bonobo_persist_stream_save_goad_id</NAME>
<RETURNS>void  </RETURNS>
Bonobo_Stream target,const CORBA_char *goad_id,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_load_goad_id</NAME>
<RETURNS>char            *</RETURNS>
Bonobo_Stream source
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persiststream_save_to_stream</NAME>
<RETURNS>GnomeIOStatus  </RETURNS>
Bonobo_PersistStream pstream,Bonobo_Stream target,const char *goad_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_save_to_stream</NAME>
<RETURNS>GnomeIOStatus  </RETURNS>
BonoboObject *object,Bonobo_Stream stream,const char *goad_id
</FUNCTION>
<MACRO>
<NAME>BONOBO_OBJECT_TYPE</NAME>
#define BONOBO_OBJECT_TYPE        (bonobo_object_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_OBJECT</NAME>
#define BONOBO_OBJECT(o)          (GTK_CHECK_CAST ((o), BONOBO_OBJECT_TYPE, BonoboObject))
</MACRO>
<MACRO>
<NAME>BONOBO_OBJECT_CLASS</NAME>
#define BONOBO_OBJECT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_OBJECT_TYPE, BonoboObjectClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_OBJECT</NAME>
#define BONOBO_IS_OBJECT(o)       (GTK_CHECK_TYPE ((o), BONOBO_OBJECT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_OBJECT_CLASS</NAME>
#define BONOBO_IS_OBJECT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_OBJECT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboObjectServant</NAME>
typedef struct {
	POA_Bonobo_Unknown servant_placeholder;
	gpointer bonobo_object;
} BonoboObjectServant;
</STRUCT>
<STRUCT>
<NAME>BonoboObjectPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboObject</NAME>
typedef struct {
	GtkObject base;

	CORBA_Object          corba_objref;
	gpointer              servant;
	BonoboObjectPrivate   *priv;
} BonoboObject;
</STRUCT>
<STRUCT>
<NAME>BonoboObjectClass</NAME>
typedef struct {
	GtkObjectClass parent_class;

	/*
	 * signals.  
	 */
	void  (*query_interface) (BonoboObject *object, const char *repo_id,  CORBA_Object      *retval);
	void  (*system_exception)(BonoboObject *object, CORBA_Object cobject, CORBA_Environment *ev);
	void  (*object_gone)     (BonoboObject *object, CORBA_Object cobject, CORBA_Environment *ev);
} BonoboObjectClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_object_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_construct</NAME>
<RETURNS>BonoboObject             *</RETURNS>
BonoboObject           *object,CORBA_Object            corba_object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_new_from_servant</NAME>
<RETURNS>BonoboObject             *</RETURNS>
void                   *servant
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_from_servant</NAME>
<RETURNS>BonoboObject             *</RETURNS>
PortableServer_Servant  servant
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_bind_to_servant</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object,void                   *servant
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_get_servant</NAME>
<RETURNS>PortableServer_Servant  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_activate_servant</NAME>
<RETURNS>CORBA_Object  </RETURNS>
BonoboObject           *object,void                   *servant
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_add_interface</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object,BonoboObject           *newobj
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_query_local_interface</NAME>
<RETURNS>BonoboObject             *</RETURNS>
BonoboObject           *object,const char             *repo_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_query_interface</NAME>
<RETURNS>CORBA_Object  </RETURNS>
BonoboObject           *object,const char             *repo_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_corba_objref</NAME>
<RETURNS>CORBA_Object  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_ref</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_unref</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_destroy</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_get_epv</NAME>
<RETURNS>POA_Bonobo_Unknown__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_check_env</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object,CORBA_Object            corba_object,CORBA_Environment      *ev
</FUNCTION>
<MACRO>
<NAME>BONOBO_OBJECT_CHECK</NAME>
#define BONOBO_OBJECT_CHECK(o,c,e) do { \
                                        if ((e)->_major != CORBA_NO_EXCEPTION) { \
                                        	bonobo_object_check_env(o,c,e);     \
			        } while (0)
</MACRO>
<FUNCTION>
<NAME>gnome_unknown_ping</NAME>
<RETURNS>gboolean  </RETURNS>
Bonobo_Unknown object
</FUNCTION>
<VARIABLE>
<NAME>bonobo_object_vepv</NAME>
extern POA_Bonobo_Unknown__vepv          bonobo_object_vepv;
</VARIABLE>
<MACRO>
<NAME>BONOBO_PERSIST_FILE_TYPE</NAME>
#define BONOBO_PERSIST_FILE_TYPE (bonobo_persist_file_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_FILE</NAME>
#define BONOBO_PERSIST_FILE(o)   (GTK_CHECK_CAST ((o), BONOBO_PERSIST_FILE_TYPE, BonoboPersistFile))
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_FILE_CLASS</NAME>
#define BONOBO_PERSIST_FILE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PERSIST_FILE_TYPE, BonoboPersistFileClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_FILE</NAME>
#define BONOBO_IS_PERSIST_FILE(o)       (GTK_CHECK_TYPE ((o), BONOBO_PERSIST_FILE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_FILE_CLASS</NAME>
#define BONOBO_IS_PERSIST_FILE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PERSIST_FILE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPersistFile</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboPersistFilePrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboPersistFileIOFn</NAME>
<RETURNS>int </RETURNS>
BonoboPersistFile *pf, const CORBA_char *filename, void *closure
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboPersistFile</NAME>
struct BonoboPersistFile {
	BonoboPersist persist;

	gboolean     is_dirty;
	char *filename;

	/*
	 * For the sample routines, NULL if we use the ::save and ::load
	 * methods from the class
	 */
	BonoboPersistFileIOFn  save_fn;
	BonoboPersistFileIOFn  load_fn;
	void *closure;

	BonoboPersistFilePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboPersistFileClass</NAME>
typedef struct {
	BonoboPersistClass parent_class;

	/*
	 * methods
	 */
	int        (*load)(BonoboPersistFile *ps, const CORBA_char *filename);
	int        (*save)(BonoboPersistFile *ps, const CORBA_char *filename);
	char*      (*get_current_file)(BonoboPersistFile *ps);	
} BonoboPersistFileClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_persist_file_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_file_set_dirty</NAME>
<RETURNS>void  </RETURNS>
BonoboPersistFile *ps,gboolean dirty
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_file_new</NAME>
<RETURNS>BonoboPersistFile  *</RETURNS>
BonoboPersistFileIOFn load_fn,BonoboPersistFileIOFn save_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_file_construct</NAME>
<RETURNS>BonoboPersistFile  *</RETURNS>
BonoboPersistFile *ps,Bonobo_PersistFile corba_ps,BonoboPersistFileIOFn load_fn,BonoboPersistFileIOFn save_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_file_get_epv</NAME>
<RETURNS>POA_Bonobo_PersistFile__epv  *</RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>bonobo_persist_file_vepv</NAME>
extern POA_Bonobo_PersistFile__vepv bonobo_persist_file_vepv;
</VARIABLE>
<MACRO>
<NAME>BONOBO_PERSIST_STREAM_TYPE</NAME>
#define BONOBO_PERSIST_STREAM_TYPE        (bonobo_persist_stream_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_STREAM</NAME>
#define BONOBO_PERSIST_STREAM(o)          (GTK_CHECK_CAST ((o), BONOBO_PERSIST_STREAM_TYPE, BonoboPersistStream))
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_STREAM_CLASS</NAME>
#define BONOBO_PERSIST_STREAM_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PERSIST_STREAM_TYPE, BonoboPersistStreamClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_STREAM</NAME>
#define BONOBO_IS_PERSIST_STREAM(o)       (GTK_CHECK_TYPE ((o), BONOBO_PERSIST_STREAM_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_STREAM_CLASS</NAME>
#define BONOBO_IS_PERSIST_STREAM_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PERSIST_STREAM_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPersistStream</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboPersistStreamPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboPersistStreamIOFn</NAME>
<RETURNS>void </RETURNS>
BonoboPersistStream         *ps,
					  const Bonobo_Stream         stream,
					  Bonobo_Persist_ContentType  type,
					  void                       *closure,
					  CORBA_Environment          *ev
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboPersistStreamMaxFn</NAME>
<RETURNS>CORBA_long </RETURNS>
BonoboPersistStream *ps,
						void                *closure,
						CORBA_Environment   *ev
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboPersistStreamTypesFn</NAME>
<RETURNS>Bonobo_Persist_ContentTypeList *</RETURNS>
BonoboPersistStream *ps,
									void                *closure,
									CORBA_Environment   *ev
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboPersistStream</NAME>
struct BonoboPersistStream {
	BonoboPersist persist;

	gboolean     is_dirty;

	/*
	 * For the sample routines, NULL if we use the
	 * methods from the class
	 */
	BonoboPersistStreamIOFn    save_fn;
	BonoboPersistStreamIOFn    load_fn;
	BonoboPersistStreamMaxFn   max_fn;
	BonoboPersistStreamTypesFn types_fn;
	
	void *closure;

	BonoboPersistStreamPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboPersistStreamClass</NAME>
typedef struct {
	BonoboPersistClass parent_class;

	/*
	 * methods
	 */
	void       (*load)         (BonoboPersistStream        *ps,
				    Bonobo_Stream              stream,
				    Bonobo_Persist_ContentType type,
				    CORBA_Environment          *ev);
	void       (*save)         (BonoboPersistStream        *ps,
				    Bonobo_Stream              stream,
				    Bonobo_Persist_ContentType type,
				    CORBA_Environment          *ev);
	CORBA_long (*get_size_max) (BonoboPersistStream *ps,
				    CORBA_Environment   *ev);
	Bonobo_Persist_ContentTypeList * (*get_content_types) (BonoboPersistStream *ps,
							       CORBA_Environment   *ev);

} BonoboPersistStreamClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_persist_stream_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_set_dirty</NAME>
<RETURNS>void  </RETURNS>
BonoboPersistStream *ps,gboolean dirty
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_new</NAME>
<RETURNS>BonoboPersistStream  *</RETURNS>
BonoboPersistStreamIOFn load_fn,BonoboPersistStreamIOFn save_fn,BonoboPersistStreamMaxFn max_fn,BonoboPersistStreamTypesFn types_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_construct</NAME>
<RETURNS>BonoboPersistStream  *</RETURNS>
BonoboPersistStream *ps,Bonobo_PersistStream corba_ps,BonoboPersistStreamIOFn load_fn,BonoboPersistStreamIOFn save_fn,BonoboPersistStreamMaxFn max_fn,BonoboPersistStreamTypesFn types_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_get_epv</NAME>
<RETURNS>POA_Bonobo_PersistStream__epv  *</RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>bonobo_persist_stream_vepv</NAME>
extern POA_Bonobo_PersistStream__vepv bonobo_persist_stream_vepv;
</VARIABLE>
<MACRO>
<NAME>BONOBO_PERSIST_TYPE</NAME>
#define BONOBO_PERSIST_TYPE        (bonobo_persist_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST</NAME>
#define BONOBO_PERSIST(o)          (GTK_CHECK_CAST ((o), BONOBO_PERSIST_TYPE, BonoboPersist))
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_CLASS</NAME>
#define BONOBO_PERSIST_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PERSIST_TYPE, BonoboPersistClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST</NAME>
#define BONOBO_IS_PERSIST(o)       (GTK_CHECK_TYPE ((o), BONOBO_PERSIST_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_CLASS</NAME>
#define BONOBO_IS_PERSIST_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PERSIST_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPersist</NAME>
typedef struct {
	BonoboObject object;

	BonoboPersistPrivate *priv;
} BonoboPersist;
</STRUCT>
<STRUCT>
<NAME>BonoboPersistClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	Bonobo_Persist_ContentTypeList * (*get_content_types) (BonoboPersist *persist,
							       CORBA_Environment *ev);
} BonoboPersistClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_persist_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_construct</NAME>
<RETURNS>BonoboPersist  *</RETURNS>
BonoboPersist *persist,Bonobo_Persist corba_persist
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_generate_content_types</NAME>
<RETURNS>Bonobo_Persist_ContentTypeList  *</RETURNS>
int num,...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_get_epv</NAME>
<RETURNS>POA_Bonobo_Persist__epv  *</RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>bonobo_persist_vepv</NAME>
extern POA_Bonobo_Persist__vepv bonobo_persist_vepv;
</VARIABLE>
<MACRO>
<NAME>BONOBO_PROGRESSIVE_DATA_SINK_TYPE</NAME>
#define BONOBO_PROGRESSIVE_DATA_SINK_TYPE        (bonobo_progressive_data_sink_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PROGRESSIVE_DATA_SINK</NAME>
#define BONOBO_PROGRESSIVE_DATA_SINK(o)          (GTK_CHECK_CAST ((o), BONOBO_PROGRESSIVE_DATA_SINK_TYPE, BonoboProgressiveDataSink))
</MACRO>
<MACRO>
<NAME>BONOBO_PROGRESSIVE_DATA_SINK_CLASS</NAME>
#define BONOBO_PROGRESSIVE_DATA_SINK_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PROGRESSIVE_DATA_SINK_TYPE, BonoboProgressiveDataSinkClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROGRESSIVE_DATA_SINK</NAME>
#define BONOBO_IS_PROGRESSIVE_DATA_SINK(o)       (GTK_CHECK_TYPE ((o), BONOBO_PROGRESSIVE_DATA_SINK_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROGRESSIVE_DATA_SINK_CLASS</NAME>
#define BONOBO_IS_PROGRESSIVE_DATA_SINK_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PROGRESSIVE_DATA_SINK_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboProgressiveDataSink</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboProgressiveDataSinkPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboProgressiveDataSinkStartFn</NAME>
<RETURNS>int </RETURNS>
BonoboProgressiveDataSink *psink,
						  void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboProgressiveDataSinkEndFn</NAME>
<RETURNS>int </RETURNS>
BonoboProgressiveDataSink *psink, void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboProgressiveDataSinkAddDataFn</NAME>
<RETURNS>int </RETURNS>
BonoboProgressiveDataSink *psink,
						  const Bonobo_ProgressiveDataSink_iobuf *buffer,
						  void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboProgressiveDataSinkSetSizeFn</NAME>
<RETURNS>int </RETURNS>
BonoboProgressiveDataSink *psink,
						  const CORBA_long count, void *closure
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboProgressiveDataSink</NAME>
struct BonoboProgressiveDataSink {
	BonoboObject object;

	/*
	 * These are the callbacks the user can set.  If we use the
	 * default class methods, then these are NULL.
	 */
	BonoboProgressiveDataSinkStartFn start_fn;
	BonoboProgressiveDataSinkEndFn end_fn;
	BonoboProgressiveDataSinkAddDataFn add_data_fn;
	BonoboProgressiveDataSinkSetSizeFn set_size_fn;

	void *closure;

	BonoboProgressiveDataSinkPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboProgressiveDataSinkClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * Methods.
	 */
	int (*start_fn)    (BonoboProgressiveDataSink *psink);
	int (*end_fn)      (BonoboProgressiveDataSink *psink);
	int (*add_data_fn) (BonoboProgressiveDataSink *psink,
			    const Bonobo_ProgressiveDataSink_iobuf *buffer);
	int (*set_size_fn) (BonoboProgressiveDataSink *psink,
			    const CORBA_long count);
			 
} BonoboProgressiveDataSinkClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_progressive_data_sink_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_progressive_data_sink_new</NAME>
<RETURNS>BonoboProgressiveDataSink  *</RETURNS>
BonoboProgressiveDataSinkStartFn start_fn,BonoboProgressiveDataSinkEndFn end_fn,BonoboProgressiveDataSinkAddDataFn add_data_fn,BonoboProgressiveDataSinkSetSizeFn set_size_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_progressive_data_sink_construct</NAME>
<RETURNS>BonoboProgressiveDataSink  *</RETURNS>
BonoboProgressiveDataSink *psink,Bonobo_ProgressiveDataSink corba_psink,BonoboProgressiveDataSinkStartFn start_fn,BonoboProgressiveDataSinkEndFn end_fn,BonoboProgressiveDataSinkAddDataFn add_data_fn,BonoboProgressiveDataSinkSetSizeFn set_size_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_progressive_get_epv</NAME>
<RETURNS>POA_Bonobo_ProgressiveDataSink__epv  *</RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>bonobo_progressive_data_sink_vepv</NAME>
extern POA_Bonobo_ProgressiveDataSink__vepv bonobo_progressive_data_sink_vepv;
</VARIABLE>
<STRUCT>
<NAME>BonoboPropertyBagClient</NAME>
typedef struct {
	GtkObject		        parent;
	Bonobo_PropertyBag		corba_pb;
} BonoboPropertyBagClient;
</STRUCT>
<STRUCT>
<NAME>BonoboPropertyBagClientClass</NAME>
typedef struct {
	GtkObjectClass			parent;
} BonoboPropertyBagClientClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_property_bag_client_new</NAME>
<RETURNS>BonoboPropertyBagClient  *</RETURNS>
Bonobo_PropertyBag corba_property_bag
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_properties</NAME>
<RETURNS>GList 			*</RETURNS>
BonoboPropertyBagClient *pbc
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_free_properties</NAME>
<RETURNS>void  </RETURNS>
GList *list
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_property_names</NAME>
<RETURNS>GList 			*</RETURNS>
BonoboPropertyBagClient *pbc
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_property</NAME>
<RETURNS>Bonobo_Property 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *property_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_persist</NAME>
<RETURNS>void 	</RETURNS>
BonoboPropertyBagClient *pbc,Bonobo_Stream stream
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_depersist</NAME>
<RETURNS>void 	</RETURNS>
BonoboPropertyBagClient *pbc,Bonobo_Stream stream
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_setv</NAME>
<RETURNS>char                     *</RETURNS>
BonoboPropertyBagClient *pb,const char              *first_arg,va_list                  var_args
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_getv</NAME>
<RETURNS>char                     *</RETURNS>
BonoboPropertyBagClient *pb,const char              *first_arg,va_list                  var_args
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_property_type</NAME>
<RETURNS>CORBA_TypeCode  </RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_gboolean</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_gint</NAME>
<RETURNS>gint 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_glong</NAME>
<RETURNS>glong 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_gfloat</NAME>
<RETURNS>gfloat 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_gdouble</NAME>
<RETURNS>gdouble 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_string</NAME>
<RETURNS>char 			*</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_any</NAME>
<RETURNS>BonoboArg 		*</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_gboolean</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_gint</NAME>
<RETURNS>gint 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_glong</NAME>
<RETURNS>glong 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_gfloat</NAME>
<RETURNS>gfloat 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_gdouble</NAME>
<RETURNS>gdouble 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_string</NAME>
<RETURNS>char 			*</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_any</NAME>
<RETURNS>BonoboArg 		*</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_gboolean</NAME>
<RETURNS>void 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname,gboolean value
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_gint</NAME>
<RETURNS>void 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname,gint value
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_glong</NAME>
<RETURNS>void 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname,glong value
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_gfloat</NAME>
<RETURNS>void 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname,gfloat value
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_gdouble</NAME>
<RETURNS>void 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname,gdouble value
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_string</NAME>
<RETURNS>void 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname,const char *value
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_any</NAME>
<RETURNS>void 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname,BonoboArg  *value
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_docstring</NAME>
<RETURNS>char 			*</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_flags</NAME>
<RETURNS>BonoboPropertyFlags 	</RETURNS>
BonoboPropertyBagClient *pbc,const char *propname
</FUNCTION>
<MACRO>
<NAME>BONOBO_PROPERTY_BAG_CLIENT_TYPE</NAME>
#define BONOBO_PROPERTY_BAG_CLIENT_TYPE        (bonobo_property_bag_client_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PROPERTY_BAG_CLIENT</NAME>
#define BONOBO_PROPERTY_BAG_CLIENT(o)          (GTK_CHECK_CAST ((o), BONOBO_PROPERTY_BAG_CLIENT_TYPE, BonoboPropertyBagClient))
</MACRO>
<MACRO>
<NAME>BONOBO_PROPERTY_BAG_CLIENT_CLASS</NAME>
#define BONOBO_PROPERTY_BAG_CLIENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PROPERTY_BAG_CLIENT_TYPE, BonoboPropertyBagClientClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROPERTY_BAG_CLIENT</NAME>
#define BONOBO_IS_PROPERTY_BAG_CLIENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_PROPERTY_BAG_CLIENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROPERTY_BAG_CLIENT_CLASS</NAME>
#define BONOBO_IS_PROPERTY_BAG_CLIENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PROPERTY_BAG_CLIENT_TYPE))
</MACRO>
<USER_FUNCTION>
<NAME>BonoboPropertyBagValueToXMLStringFn</NAME>
<RETURNS>char *</RETURNS>
const char *type, gpointer value, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboPropertyBagValueFromXMLStringFn</NAME>
<RETURNS>gpointer </RETURNS>
const char *type, const char *str, gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_xml_register</NAME>
<RETURNS>void  </RETURNS>
BonoboPropertyBag *pb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_xml_persist</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboPropertyBag *pb, const Bonobo_Stream stream,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_xml_depersist</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboPropertyBag *pb, const Bonobo_Stream stream,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_xml_add_type</NAME>
<RETURNS>void  </RETURNS>
BonoboPropertyBag *pb, const char *type,BonoboPropertyBagValueToXMLStringFn   to_string,BonoboPropertyBagValueFromXMLStringFn from_string,gpointer user_data
</FUNCTION>
<STRUCT>
<NAME>BonoboPropertyBagPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboPropertyBag</NAME>
</STRUCT>
<ENUM>
<NAME>BonoboPropertyFlags</NAME>
typedef enum {
	BONOBO_PROPERTY_UNSTORED        = 1,
	BONOBO_PROPERTY_READABLE        = 2,
	BONOBO_PROPERTY_WRITEABLE       = 4,
	BONOBO_PROPERTY_USE_DEFAULT_OPT = 8
} BonoboPropertyFlags;
</ENUM>
<USER_FUNCTION>
<NAME>BonoboPropertyGetFn</NAME>
<RETURNS>void </RETURNS>
BonoboPropertyBag *bag,
				     BonoboArg         *arg,
				     guint              arg_id,
				     gpointer           user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboPropertySetFn</NAME>
<RETURNS>void </RETURNS>
BonoboPropertyBag *bag,
				     const BonoboArg   *arg,
				     guint              arg_id,
				     gpointer           user_data
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboPropertyBag</NAME>
struct BonoboPropertyBag {
	BonoboObject              parent;
	BonoboPropertyBagPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboPropertyBagClass</NAME>
typedef struct {
	BonoboObjectClass   parent;
} BonoboPropertyBagClass;
</STRUCT>
<MACRO>
<NAME>BONOBO_PROPERTY_BAG_TYPE</NAME>
#define BONOBO_PROPERTY_BAG_TYPE                (bonobo_property_bag_get_gtk_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PROPERTY_BAG</NAME>
#define BONOBO_PROPERTY_BAG(o)		        (GTK_CHECK_CAST ((o), BONOBO_PROPERTY_BAG_TYPE, BonoboPropertyBag))
</MACRO>
<MACRO>
<NAME>BONOBO_PROPERTY_BAG_CLASS</NAME>
#define BONOBO_PROPERTY_BAG_CLASS(k)		(GTK_CHECK_CLASS_CAST((k), BONOBO_PROPERTY_BAG_TYPE, BonoboPropertyBagClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROPERTY_BAG</NAME>
#define BONOBO_IS_PROPERTY_BAG(o)		(GTK_CHECK_TYPE ((o), BONOBO_PROPERTY_BAG_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROPERTY_BAG_CLASS</NAME>
#define BONOBO_IS_PROPERTY_BAG_CLASS(k)		(GTK_CHECK_CLASS_TYPE ((k), BONOBO_PROPERTY_BAG_TYPE))
</MACRO>
<FUNCTION>
<NAME>bonobo_property_bag_get_gtk_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_new</NAME>
<RETURNS>BonoboPropertyBag 	 *</RETURNS>
BonoboPropertyGetFn get_prop,BonoboPropertySetFn set_prop,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_add</NAME>
<RETURNS>void  </RETURNS>
BonoboPropertyBag  *pb,const char         *name,int                 idx,BonoboArgType       type,BonoboArg          *default_value,const char         *docstring,BonoboPropertyFlags flags
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_add_full</NAME>
<RETURNS>void  </RETURNS>
BonoboPropertyBag  *pb,const char         *name,int                 idx,BonoboArgType       type,BonoboArg          *default_value,const char         *docstring,BonoboPropertyFlags flags,BonoboPropertyGetFn get_prop,BonoboPropertySetFn set_prop,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_add_gtk_args</NAME>
<RETURNS>void  </RETURNS>
BonoboPropertyBag  *pb,GtkObject          *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_type</NAME>
<RETURNS>BonoboArgType  </RETURNS>
BonoboPropertyBag *pb, const char *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_set_value</NAME>
<RETURNS>void 	</RETURNS>
BonoboPropertyBag *pb, const char *name,const BonoboArg   *value
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_value</NAME>
<RETURNS>BonoboArg                 *</RETURNS>
BonoboPropertyBag *pb, const char *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_default</NAME>
<RETURNS>BonoboArg                 *</RETURNS>
BonoboPropertyBag *pb, const char *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_docstring</NAME>
<RETURNS>const char 	         *</RETURNS>
BonoboPropertyBag *pb, const char *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_flags</NAME>
<RETURNS>const BonoboPropertyFlags  </RETURNS>
BonoboPropertyBag *pb, const char *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_has_property</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboPropertyBag *pb, const char *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_prop_list</NAME>
<RETURNS>GList                     *</RETURNS>
BonoboPropertyBag *pb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_epv</NAME>
<RETURNS>POA_Bonobo_PropertyBag__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_marshal_boolean</NAME>
<RETURNS>CORBA_any  *</RETURNS>
const char *type, gconstpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_marshal_string</NAME>
<RETURNS>CORBA_any  *</RETURNS>
const char *type, gconstpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_marshal_short</NAME>
<RETURNS>CORBA_any  *</RETURNS>
const char *type, gconstpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_marshal_ushort</NAME>
<RETURNS>CORBA_any  *</RETURNS>
const char *type, gconstpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_marshal_long</NAME>
<RETURNS>CORBA_any  *</RETURNS>
const char *type, gconstpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_marshal_ulong</NAME>
<RETURNS>CORBA_any  *</RETURNS>
const char *type, gconstpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_marshal_float</NAME>
<RETURNS>CORBA_any  *</RETURNS>
const char *type, gconstpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_marshal_double</NAME>
<RETURNS>CORBA_any  *</RETURNS>
const char *type, gconstpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_demarshal_boolean</NAME>
<RETURNS>gpointer  </RETURNS>
const char *type, const CORBA_any *any,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_demarshal_string</NAME>
<RETURNS>gpointer  </RETURNS>
const char *type, const CORBA_any *any,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_demarshal_short</NAME>
<RETURNS>gpointer  </RETURNS>
const char *type, const CORBA_any *any,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_demarshal_ushort</NAME>
<RETURNS>gpointer  </RETURNS>
const char *type, const CORBA_any *any,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_demarshal_long</NAME>
<RETURNS>gpointer  </RETURNS>
const char *type, const CORBA_any *any,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_demarshal_ulong</NAME>
<RETURNS>gpointer  </RETURNS>
const char *type, const CORBA_any *any,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_demarshal_float</NAME>
<RETURNS>gpointer  </RETURNS>
const char *type, const CORBA_any *any,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_demarshal_double</NAME>
<RETURNS>gpointer  </RETURNS>
const char *type, const CORBA_any *any,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_compare_boolean</NAME>
<RETURNS>gboolean  </RETURNS>
const char *type, gpointer value1,gpointer value2,  gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_compare_string</NAME>
<RETURNS>gboolean  </RETURNS>
const char *type, gpointer value1,gpointer value2,  gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_compare_short</NAME>
<RETURNS>gboolean  </RETURNS>
const char *type, gpointer value1,gpointer value2,  gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_compare_ushort</NAME>
<RETURNS>gboolean  </RETURNS>
const char *type, gpointer value1,gpointer value2,  gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_compare_long</NAME>
<RETURNS>gboolean  </RETURNS>
const char *type, gpointer value1,gpointer value2,  gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_compare_ulong</NAME>
<RETURNS>gboolean  </RETURNS>
const char *type, gpointer value1,gpointer value2,  gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_compare_float</NAME>
<RETURNS>gboolean  </RETURNS>
const char *type, gpointer value1,gpointer value2,  gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_compare_double</NAME>
<RETURNS>gboolean  </RETURNS>
const char *type, gpointer value1,gpointer value2,  gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_generic_releaser</NAME>
<RETURNS>void 	</RETURNS>
const char *type, gpointer value,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_servant_new</NAME>
<RETURNS>PortableServer_Servant  </RETURNS>
PortableServer_POA adapter, BonoboPropertyBag *pb,char *property_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_servant_destroy</NAME>
<RETURNS>void 	</RETURNS>
PortableServer_Servant servant
</FUNCTION>
<STRUCT>
<NAME>BonoboProperty</NAME>
typedef struct {
	char			*name;
	int                      idx;
	BonoboArgType            type;
	BonoboArg               *default_value;
	char			*docstring;
	BonoboPropertyFlags	 flags;

	BonoboPropertyGetFn      get_prop;
	BonoboPropertySetFn      set_prop;
	gpointer                 user_data;
} BonoboProperty;
</STRUCT>
<MACRO>
<NAME>BONOBO_SELECTOR</NAME>
#define BONOBO_SELECTOR(obj)	GTK_CHECK_CAST(obj, bonobo_selector_get_type (), BonoboSelector)
</MACRO>
<MACRO>
<NAME>BONOBO_SELECTOR_CLASS</NAME>
#define BONOBO_SELECTOR_CLASS	GTK_CHECK_CLASS_CAST (klass, bonobo_selector_get_type (), BonoboSelectorClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_BONOBO_SELECTOR</NAME>
#define GNOME_IS_BONOBO_SELECTOR(obj)	GTK_CHECK_TYPE (obj, bonobo_selector_get_type ())
</MACRO>
<STRUCT>
<NAME>BonoboSelector</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboSelectorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboSelectorPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboSelectorClass</NAME>
struct BonoboSelectorClass
{
	GnomeDialogClass parent_class;
	
	void (* ok)	(BonoboSelector *sel);
	void (* cancel)	(BonoboSelector *sel);
};
</STRUCT>
<STRUCT>
<NAME>BonoboSelector</NAME>
struct BonoboSelector
{
	GnomeDialog dialog;
		
	BonoboSelectorPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_selector_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_new</NAME>
<RETURNS>GtkWidget   *</RETURNS>
const gchar *title,const gchar **interfaces_required
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_get_selected_id</NAME>
<RETURNS>gchar 	   *</RETURNS>
BonoboSelector *sel
</FUNCTION>
<FUNCTION>
<NAME>gnome_bonobo_select_id</NAME>
<RETURNS>gchar 	   *</RETURNS>
const gchar *title,const gchar **interfaces_required
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_get_selected_goad_id</NAME>
<RETURNS>gchar 	   *</RETURNS>
BonoboSelector *sel
</FUNCTION>
<FUNCTION>
<NAME>gnome_bonobo_select_goad_id</NAME>
<RETURNS>gchar 	   *</RETURNS>
const gchar *title,const gchar **interfaces_required
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_get_selected_oaf_id</NAME>
<RETURNS>gchar 	   *</RETURNS>
BonoboSelector *sel
</FUNCTION>
<FUNCTION>
<NAME>gnome_bonobo_select_oaf_id</NAME>
<RETURNS>gchar 	   *</RETURNS>
const gchar *title,const gchar **interfaces_required
</FUNCTION>
<MACRO>
<NAME>GNOME_SIMPLE_DATA_SOURCE_TYPE</NAME>
#define GNOME_SIMPLE_DATA_SOURCE_TYPE        (gnome_simple_data_source_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_SIMPLE_DATA_SOURCE</NAME>
#define GNOME_SIMPLE_DATA_SOURCE(o)          (GTK_CHECK_CAST ((o), GNOME_SIMPLE_DATA_SOURCE_TYPE, GnomeSimpleDataSource))
</MACRO>
<MACRO>
<NAME>GNOME_SIMPLE_DATA_SOURCE_CLASS</NAME>
#define GNOME_SIMPLE_DATA_SOURCE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), GNOME_SIMPLE_DATA_SOURCE_TYPE, GnomeSimpleDataSourceClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_SIMPLE_DATA_SOURCE</NAME>
#define GNOME_IS_SIMPLE_DATA_SOURCE(o)       (GTK_CHECK_TYPE ((o), GNOME_SIMPLE_DATA_SOURCE_TYPE))
</MACRO>
<MACRO>
<NAME>GNOME_IS_SIMPLE_DATA_SOURCE_CLASS</NAME>
#define GNOME_IS_SIMPLE_DATA_SOURCE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), GNOME_SIMPLE_DATA_SOURCE_TYPE))
</MACRO>
<STRUCT>
<NAME>GnomeSimpleDataSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeSimpleDataSourcePrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GnomeSimpleDataSourcePopDataFn</NAME>
<RETURNS>int </RETURNS>
GnomeSimpleDataSource *ssource,
								 const CORBA_long count,
								 GNOME_SimpleDataSource_iobuf **buffer,
								 void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeSimpleDataSourceRemainingDataFn</NAME>
<RETURNS>CORBA_long </RETURNS>
GnomeSimpleDataSource *ssource,
								 void *closure
</USER_FUNCTION>
<STRUCT>
<NAME>GnomeSimpleDataSource</NAME>
struct GnomeSimpleDataSource {
	BonoboObject object;

	/*
	 * These are the callbacks the user can set.  If we use the
	 * default class methods, then these are NULL.
	 */
	GnomeSimpleDataSourcePopDataFn pop_data_fn;
	GnomeSimpleDataSourceRemainingDataFn remaining_data_fn;

	void *closure;

	GnomeSimpleDataSourcePrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_simple_data_source_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_simple_data_source_new</NAME>
<RETURNS>GnomeSimpleDataSource  *</RETURNS>
GnomeSimpleDataSourcePopDataFn pop_data_fn,GnomeSimpleDataSourceRemainingDataFn remaining_data_fn,void *closure
</FUNCTION>
<FUNCTION>
<NAME>gnome_simple_data_source_construct</NAME>
<RETURNS>GnomeSimpleDataSource  *</RETURNS>
GnomeSimpleDataSource *ssource,GNOME_SimpleDataSource corba_ssource,GnomeSimpleDataSourcePopDataFn pop_data_fn,GnomeSimpleDataSourceRemainingDataFn remaining_data_fn,void *closure
</FUNCTION>
<VARIABLE>
<NAME>gnome_simple_data_source_epv</NAME>
extern POA_GNOME_SimpleDataSource__epv gnome_simple_data_source_epv;
</VARIABLE>
<STRUCT>
<NAME>BonoboStorageDriver</NAME>
typedef struct {
	
} BonoboStorageDriver;
</STRUCT>
<FUNCTION>
<NAME>bonobo_storage_driver_new</NAME>
<RETURNS>BonoboStorageDriver  *</RETURNS>
char *type, char *path, char *open_mode
</FUNCTION>
<STRUCT>
<NAME>StorageDriver</NAME>
struct StorageDriver {
	
};
</STRUCT>
<STRUCT>
<NAME>BonoboStoragePrivate</NAME>
struct BonoboStoragePrivate {
	StorageDriver driver;
};
</STRUCT>
<MACRO>
<NAME>BONOBO_STORAGE_TYPE</NAME>
#define BONOBO_STORAGE_TYPE        (bonobo_storage_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_STORAGE</NAME>
#define BONOBO_STORAGE(o)          (GTK_CHECK_CAST ((o), BONOBO_STORAGE_TYPE, BonoboStorage))
</MACRO>
<MACRO>
<NAME>BONOBO_STORAGE_CLASS</NAME>
#define BONOBO_STORAGE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_STORAGE_TYPE, BonoboStorageClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STORAGE</NAME>
#define BONOBO_IS_STORAGE(o)       (GTK_CHECK_TYPE ((o), BONOBO_STORAGE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STORAGE_CLASS</NAME>
#define BONOBO_IS_STORAGE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_STORAGE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboStoragePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboStorage</NAME>
typedef struct {
        BonoboObject object;

	BonoboStoragePrivate *priv;
} BonoboStorage;
</STRUCT>
<STRUCT>
<NAME>BonoboStorageClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * virtual methods
	 */
	BonoboStream  *(*create_stream)  (BonoboStorage *storage,
					 const CORBA_char *path,
					 CORBA_Environment *ev);
	BonoboStream  *(*open_stream)    (BonoboStorage *storage,
					 const CORBA_char *path,
					 Bonobo_Storage_OpenMode, CORBA_Environment *ev);
	BonoboStorage *(*create_storage) (BonoboStorage *storage,
					 const CORBA_char *path,
					 CORBA_Environment *ev);
	BonoboStorage *(*open_storage)   (BonoboStorage *storage,
					 const CORBA_char *path,
					 CORBA_Environment *ev);
	void         (*copy_to)         (BonoboStorage *storage, Bonobo_Storage target,
					 CORBA_Environment *ev);
	void         (*rename)          (BonoboStorage *storage,
					 const CORBA_char *path_name,
					 const CORBA_char *new_path_name,
					 CORBA_Environment *ev);
	void         (*commit)          (BonoboStorage *storage,
					 CORBA_Environment *ev);
	Bonobo_Storage_directory_list *
	             (*list_contents)   (BonoboStorage *storage,
					 const CORBA_char *path,
					 CORBA_Environment *ev);
	void         (*erase)          (BonoboStorage *storage,
                                        const CORBA_char *path,
                                        CORBA_Environment *ev);
} BonoboStorageClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_storage_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_construct</NAME>
<RETURNS>BonoboStorage    *</RETURNS>
BonoboStorage *storage,Bonobo_Storage corba_storage
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_open</NAME>
<RETURNS>BonoboStorage    *</RETURNS>
const char *driver,const char *path,gint flags,gint mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_storage_open</NAME>
<RETURNS>BonoboStorage    *</RETURNS>
BonoboStorage *storage,const char *path,const char *open_mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_storage_open</NAME>
<RETURNS>BonoboStream     *</RETURNS>
BonoboStorage *storage,const char *path,const char *open_mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_write_class_id</NAME>
<RETURNS>void  </RETURNS>
BonoboStorage *storage,char *class_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_write_class_id</NAME>
<RETURNS>void  </RETURNS>
BonoboStream *stream,char *class_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_get_epv</NAME>
<RETURNS>POA_Bonobo_Storage__epv  *</RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>bonobo_storage_vepv</NAME>
extern POA_Bonobo_Storage__vepv bonobo_storage_vepv;
</VARIABLE>
<MACRO>
<NAME>BONOBO_SS_READ</NAME>
#define BONOBO_SS_READ   1
</MACRO>
<MACRO>
<NAME>BONOBO_SS_WRITE</NAME>
#define BONOBO_SS_WRITE  2
</MACRO>
<MACRO>
<NAME>BONOBO_SS_RDWR</NAME>
#define BONOBO_SS_RDWR   3
</MACRO>
<MACRO>
<NAME>BONOBO_SS_CREATE</NAME>
#define BONOBO_SS_CREATE 4
</MACRO>
<MACRO>
<NAME>BONOBO_SS_EXCL</NAME>
#define BONOBO_SS_EXCL   8
</MACRO>
<FUNCTION>
<NAME>bonobo_storage_driver_open</NAME>
<RETURNS>BonoboStorage  *</RETURNS>
const char *path, gint flags, gint mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_write</NAME>
<RETURNS>CORBA_long  </RETURNS>
const Bonobo_Stream stream,const void *buffer,const size_t size,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_write_string</NAME>
<RETURNS>CORBA_long  </RETURNS>
const Bonobo_Stream stream,const char *str,const gboolean terminate,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_printf</NAME>
<RETURNS>CORBA_long  </RETURNS>
const Bonobo_Stream stream,const gboolean terminate,CORBA_Environment *ev,const char *fmt, ...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_read_string</NAME>
<RETURNS>CORBA_long  </RETURNS>
const Bonobo_Stream stream, char **str,CORBA_Environment *ev
</FUNCTION>
<STRUCT>
<NAME>BonoboStreamFS</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboStorageFS</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_STREAM_FS_TYPE</NAME>
#define BONOBO_STREAM_FS_TYPE        (bonobo_stream_fs_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_FS</NAME>
#define BONOBO_STREAM_FS(o)          (GTK_CHECK_CAST ((o), BONOBO_STREAM_FS_TYPE, BonoboStreamFS))
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_FS_CLASS</NAME>
#define BONOBO_STREAM_FS_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_STREAM_FS_TYPE, BonoboStreamFSClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM_FS</NAME>
#define BONOBO_IS_STREAM_FS(o)       (GTK_CHECK_TYPE ((o), BONOBO_STREAM_FS_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM_FS_CLASS</NAME>
#define BONOBO_IS_STREAM_FS_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_STREAM_FS_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboStreamFSPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboStreamFS</NAME>
struct BonoboStreamFS {
	BonoboStream stream;
	int fd;
	char *path;

	BonoboStreamFSPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboStreamFSClass</NAME>
typedef struct {
	BonoboStreamClass parent_class;
} BonoboStreamFSClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_stream_fs_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_fs_open</NAME>
<RETURNS>BonoboStream     *</RETURNS>
const CORBA_char *path, Bonobo_Storage_OpenMode mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_fs_create</NAME>
<RETURNS>BonoboStream     *</RETURNS>
const CORBA_char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_fs_construct</NAME>
<RETURNS>BonoboStream     *</RETURNS>
BonoboStreamFS *stream,Bonobo_Stream corba_stream
</FUNCTION>
<STRUCT>
<NAME>BonoboStreamMem</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboStreamMemPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboStorageMem</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_STREAM_MEM_TYPE</NAME>
#define BONOBO_STREAM_MEM_TYPE        (bonobo_stream_mem_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_MEM</NAME>
#define BONOBO_STREAM_MEM(o)          (GTK_CHECK_CAST ((o), BONOBO_STREAM_MEM_TYPE, BonoboStreamMem))
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_MEM_CLASS</NAME>
#define BONOBO_STREAM_MEM_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_STREAM_MEM_TYPE, BonoboStreamMemClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM_MEM</NAME>
#define BONOBO_IS_STREAM_MEM(o)       (GTK_CHECK_TYPE ((o), BONOBO_STREAM_MEM_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM_MEM_CLASS</NAME>
#define BONOBO_IS_STREAM_MEM_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_STREAM_MEM_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboStreamMem</NAME>
struct BonoboStreamMem {
	BonoboStream  stream;

	char        *buffer;
	size_t       size;
	long         pos;
	gboolean     read_only;
	gboolean     resizable;

	BonoboStreamMemPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboStreamMemClass</NAME>
typedef struct {
	BonoboStreamClass parent_class;
} BonoboStreamMemClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_stream_mem_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_mem_create</NAME>
<RETURNS>BonoboStream    *</RETURNS>
char *buffer, size_t size,gboolean read_only,gboolean resizable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_mem_get_buffer</NAME>
<RETURNS>const char      *</RETURNS>
BonoboStreamMem *stream_mem
</FUNCTION>
<MACRO>
<NAME>BONOBO_STREAM_TYPE</NAME>
#define BONOBO_STREAM_TYPE        (bonobo_stream_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM</NAME>
#define BONOBO_STREAM(o)          (GTK_CHECK_CAST ((o), BONOBO_STREAM_TYPE, BonoboStream))
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_CLASS</NAME>
#define BONOBO_STREAM_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_STREAM_TYPE, BonoboStreamClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM</NAME>
#define BONOBO_IS_STREAM(o)       (GTK_CHECK_TYPE ((o), BONOBO_STREAM_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM_CLASS</NAME>
#define BONOBO_IS_STREAM_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_STREAM_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboStream</NAME>
typedef struct {
        BonoboObject object;
} BonoboStream;
</STRUCT>
<STRUCT>
<NAME>BonoboStreamClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * virtual methods
	 */
	CORBA_long    (*write)    (BonoboStream *stream,
				   const Bonobo_Stream_iobuf *buffer,
				   CORBA_Environment *ev);
	CORBA_long    (*read)     (BonoboStream *stream, CORBA_long count,
				   Bonobo_Stream_iobuf **buffer,
				   CORBA_Environment *ev);
        CORBA_long    (*seek)     (BonoboStream *stream,
				   CORBA_long offset, Bonobo_Stream_SeekType whence,
				   CORBA_Environment *ev);
        void          (*truncate) (BonoboStream *stream,
				   const CORBA_long new_size, 
				   CORBA_Environment *ev);
	void          (*copy_to)  (BonoboStream *stream,
				   const CORBA_char * dest,
				   const CORBA_long bytes,
				   CORBA_long *read,
				   CORBA_long *written,
				   CORBA_Environment *ev);
        void          (*commit)   (BonoboStream *stream,
				   CORBA_Environment *ev);
        void          (*close)    (BonoboStream *stream,
				   CORBA_Environment *ev);
        CORBA_boolean (*eos)      (BonoboStream *stream,
				   CORBA_Environment *ev);
	CORBA_long    (*length)   (BonoboStream *stream,
				   CORBA_Environment *ev);
} BonoboStreamClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_stream_get_epv</NAME>
<RETURNS>POA_Bonobo_Stream__epv  *</RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>bonobo_stream_vepv</NAME>
extern POA_Bonobo_Stream__vepv bonobo_stream_vepv;
</VARIABLE>
<FUNCTION>
<NAME>bonobo_stream_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_UI_HANDLER_TYPE</NAME>
#define BONOBO_UI_HANDLER_TYPE        (bonobo_ui_handler_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_HANDLER</NAME>
#define BONOBO_UI_HANDLER(o)          (GTK_CHECK_CAST ((o), BONOBO_UI_HANDLER_TYPE, BonoboUIHandler))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_HANDLER_CLASS</NAME>
#define BONOBO_UI_HANDLER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_UI_HANDLER_TYPE, BonoboUIHandlerClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_HANDLER</NAME>
#define BONOBO_IS_UI_HANDLER(o)       (GTK_CHECK_TYPE ((o), BONOBO_UI_HANDLER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_HANDLER_CLASS</NAME>
#define BONOBO_IS_UI_HANDLER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_UI_HANDLER_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboUIHandler</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIHandlerPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIHandlerTopLevelData</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIHandlerMenuItem</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIHandlerToolbarItem</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboUIHandlerCallbackFunc</NAME>
<RETURNS>void </RETURNS>
BonoboUIHandler *uih, void *user_data, const char *path
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboUIHandler</NAME>
struct BonoboUIHandler {
	BonoboObject			 base;

	/*
	 * If this UIHandler is for an object which is embedded in a
	 * container, then this field points to the top-level
	 * container's Bonobo::UIHandler CORBA interface.  The
	 * top-level container (the container which is not itself a
	 * containee) manages the actual menu and toolbar item
	 * GtkWidgets.
	 */
	Bonobo_UIHandler		 top_level_uih;

	/*
	 * The callback data for the menu items.
	 */
	GHashTable			*path_to_menu_callback;

	/*
	 * The callback data for the toolbar items.
	 */
	GHashTable			*path_to_toolbar_callback;
	GHashTable			*path_to_toolbar_toolbar;
	
	/*
	 * The top-level BonoboUIHandler must manage a lot of extra
	 * data (e.g. the actual menu/toolbar widgets, an internal
	 * representation of every menu/toolbar item, etc.).  This
	 * information is stored here.
	 */
	BonoboUIHandlerTopLevelData	*top;

	BonoboUIHandlerPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboUIHandlerClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * Signals.
	 */
	void (*menu_item_activated)	(BonoboUIHandler *uih, char *path, void *item_data);
	void (*menu_item_removed)	(BonoboUIHandler *uih, char *path, void *item_data);
	void (*menu_item_overridden)	(BonoboUIHandler *uih, char *path, void *item_data);
	void (*menu_item_reinstated)	(BonoboUIHandler *uih, char *path, void *item_data);

	void (*toolbar_item_activated)	(BonoboUIHandler *uih, char *path, void *item_data);
	void (*toolbar_item_removed)	(BonoboUIHandler *uih, char *path, void *item_data);
	void (*toolbar_item_overridden)	(BonoboUIHandler *uih, char *path, void *item_data);
	void (*toolbar_item_reinstated)	(BonoboUIHandler *uih, char *path, void *item_data);
} BonoboUIHandlerClass;
</STRUCT>
<ENUM>
<NAME>BonoboUIHandlerPixmapType</NAME>
typedef enum {
	BONOBO_UI_HANDLER_PIXMAP_NONE,
	BONOBO_UI_HANDLER_PIXMAP_STOCK,
	BONOBO_UI_HANDLER_PIXMAP_FILENAME,
	BONOBO_UI_HANDLER_PIXMAP_XPM_DATA,
	BONOBO_UI_HANDLER_PIXMAP_PIXBUF_DATA
} BonoboUIHandlerPixmapType;
</ENUM>
<ENUM>
<NAME>BonoboUIHandlerMenuItemType</NAME>
typedef enum {
	BONOBO_UI_HANDLER_MENU_END,
	BONOBO_UI_HANDLER_MENU_ITEM,
	BONOBO_UI_HANDLER_MENU_SUBTREE,
	BONOBO_UI_HANDLER_MENU_RADIOITEM,
	BONOBO_UI_HANDLER_MENU_RADIOGROUP,
	BONOBO_UI_HANDLER_MENU_TOGGLEITEM,
	BONOBO_UI_HANDLER_MENU_SEPARATOR
} BonoboUIHandlerMenuItemType;
</ENUM>
<STRUCT>
<NAME>BonoboUIHandlerMenuItem</NAME>
struct BonoboUIHandlerMenuItem {
	char			        *path;

	BonoboUIHandlerMenuItemType	 type;
	char			        *label;
	char			        *hint;

	int				 pos;

	/*
	 * If this item is a subtree, then this field can point to a
	 * NULL-terminated array of BonoboUIHandlerMenuItems in the
	 * subtree.  If this item is a radio item, then this list
	 * contains the items in the radio group.
	 */
	BonoboUIHandlerMenuItem		*children;

	BonoboUIHandlerPixmapType	 pixmap_type;
	gpointer			 pixmap_data;

	guint				 accelerator_key;
	GdkModifierType			 ac_mods;

	/*
	 * The callback function and closure.
	 */
	BonoboUIHandlerCallbackFunc	 callback;
	gpointer			 callback_data;
};
</STRUCT>
<ENUM>
<NAME>BonoboUIHandlerToolbarItemType</NAME>
typedef enum {
	BONOBO_UI_HANDLER_TOOLBAR_END,
	BONOBO_UI_HANDLER_TOOLBAR_ITEM,
	BONOBO_UI_HANDLER_TOOLBAR_RADIOITEM,
	BONOBO_UI_HANDLER_TOOLBAR_RADIOGROUP,
	BONOBO_UI_HANDLER_TOOLBAR_TOGGLEITEM,
	BONOBO_UI_HANDLER_TOOLBAR_SEPARATOR,
	BONOBO_UI_HANDLER_TOOLBAR_CONTROL
} BonoboUIHandlerToolbarItemType;
</ENUM>
<STRUCT>
<NAME>BonoboUIHandlerToolbarItem</NAME>
struct BonoboUIHandlerToolbarItem {
	char				*path;

	BonoboUIHandlerToolbarItemType	 type;

	char				*label;
	char				*hint;

	int				 pos;

	Bonobo_Control			 control;

	BonoboUIHandlerToolbarItem	*children;

	BonoboUIHandlerPixmapType	 pixmap_type;
	gpointer			 pixmap_data;

	guint				 accelerator_key;
	GdkModifierType			 ac_mods;

	/*
	 * The callback function and closure.
	 */
	BonoboUIHandlerCallbackFunc	 callback;
	gpointer			 callback_data;
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_ui_handler_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_construct</NAME>
<RETURNS>BonoboUIHandler 		*</RETURNS>
BonoboUIHandler *ui_handler,Bonobo_UIHandler corba_uihandler
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_new</NAME>
<RETURNS>BonoboUIHandler 		*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_set_container</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih,Bonobo_UIHandler container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_unset_container</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_add_containee</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih,Bonobo_UIHandler containee
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_remove_containee</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih,Bonobo_UIHandler containee
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_set_accelgroup</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih,GtkAccelGroup *accelgroup
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_get_accelgroup</NAME>
<RETURNS>GtkAccelGroup 		*</RETURNS>
BonoboUIHandler *uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_build_path</NAME>
<RETURNS>char 			*</RETURNS>
const char *base, ...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_build_path_v</NAME>
<RETURNS>char 			*</RETURNS>
const char *base, va_list path_components
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_set_app</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, GnomeApp *app
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_get_app</NAME>
<RETURNS>GnomeApp                 *</RETURNS>
BonoboUIHandler *uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_set_statusbar</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, GtkWidget *statusbar
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_get_statusbar</NAME>
<RETURNS>GtkWidget 		*</RETURNS>
BonoboUIHandler *uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_set_menubar</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, GtkWidget *menubar
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_get_menubar</NAME>
<RETURNS>GtkWidget 		*</RETURNS>
BonoboUIHandler *uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_create_menubar</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_create_popup_menu</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_do_popup_menu</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_set_toolbar</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *name,GtkWidget *toolbar
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_new</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,BonoboUIHandlerMenuItemType type,const char *label, const char *hint,int pos, BonoboUIHandlerPixmapType pixmap_type,gpointer pixmap_data,guint accelerator_key, GdkModifierType ac_mods,BonoboUIHandlerCallbackFunc callback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_new_item</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,const char *label, const char *hint,int pos, BonoboUIHandlerPixmapType pixmap_type,gpointer pixmap_data,guint accelerator_key, GdkModifierType ac_mods,BonoboUIHandlerCallbackFunc callback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_new_subtree</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,const char *label, const char *hint, int pos,BonoboUIHandlerPixmapType pixmap_type,gpointer pixmap_data, guint accelerator_key,GdkModifierType ac_mods
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_new_separator</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path, int pos
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_new_radiogroup</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_new_radioitem</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,const char *label, const char *hint, int pos,guint accelerator_key, GdkModifierType ac_mods,BonoboUIHandlerCallbackFunc callback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_new_toggleitem</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,const char *label, const char *hint, int pos,guint accelerator_key, GdkModifierType ac_mods,BonoboUIHandlerCallbackFunc callback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_add_one</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *parent_path,BonoboUIHandlerMenuItem *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_add_list</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *parent_path,BonoboUIHandlerMenuItem *array
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_add_tree</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *parent_path,BonoboUIHandlerMenuItem *tree
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_remove</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_fetch_one</NAME>
<RETURNS>BonoboUIHandlerMenuItem 	*</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_fetch_list</NAME>
<RETURNS>BonoboUIHandlerMenuItem 	*</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_fetch_tree</NAME>
<RETURNS>BonoboUIHandlerMenuItem 	*</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_free_one</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandlerMenuItem *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_free_list</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandlerMenuItem *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_free_tree</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandlerMenuItem *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_fetch_by_callback</NAME>
<RETURNS>GList 			*</RETURNS>
BonoboUIHandler *uih,BonoboUIHandlerCallbackFunc callback
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_fetch_by_callback_data</NAME>
<RETURNS>GList 			*</RETURNS>
BonoboUIHandler *uih, gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_get_child_paths</NAME>
<RETURNS>GList 			*</RETURNS>
BonoboUIHandler *uih, const char *parent_path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_parse_uiinfo_one</NAME>
<RETURNS>BonoboUIHandlerMenuItem 	*</RETURNS>
GnomeUIInfo *uii
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_parse_uiinfo_list</NAME>
<RETURNS>BonoboUIHandlerMenuItem 	*</RETURNS>
GnomeUIInfo *uii
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_parse_uiinfo_tree</NAME>
<RETURNS>BonoboUIHandlerMenuItem 	*</RETURNS>
GnomeUIInfo *uii
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_parse_uiinfo_one_with_data</NAME>
<RETURNS>BonoboUIHandlerMenuItem 	*</RETURNS>
GnomeUIInfo *uii, void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_parse_uiinfo_list_with_data</NAME>
<RETURNS>BonoboUIHandlerMenuItem 	*</RETURNS>
GnomeUIInfo *uii, void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_parse_uiinfo_tree_with_data</NAME>
<RETURNS>BonoboUIHandlerMenuItem 	*</RETURNS>
GnomeUIInfo *uii, void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_get_pos</NAME>
<RETURNS>int 	</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_set_sensitivity</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,gboolean sensitive
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_get_sensitivity</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_set_label</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,const gchar *label
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_get_label</NAME>
<RETURNS>gchar 			*</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_set_hint</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,const gchar *hint
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_get_hint</NAME>
<RETURNS>gchar 			*</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_set_pixmap</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,BonoboUIHandlerPixmapType type, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_get_pixmap</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,BonoboUIHandlerPixmapType *type, gpointer *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_set_accel</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,guint accelerator_key, GdkModifierType ac_mods
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_get_accel</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,guint *accelerator_key, GdkModifierType *ac_mods
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_set_callback</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,BonoboUIHandlerCallbackFunc callback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_get_callback</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,BonoboUIHandlerCallbackFunc *callback,gpointer *callback_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_set_toggle_state</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,gboolean state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_get_toggle_state</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_set_radio_state</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,gboolean state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_get_radio_state</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_get_radio_group_selection</NAME>
<RETURNS>char 			*</RETURNS>
BonoboUIHandler *uih, const char *rg_path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_create_toolbar</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_remove_toolbar</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_get_toolbar_list</NAME>
<RETURNS>GList 				*</RETURNS>
BonoboUIHandler *uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_new</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,BonoboUIHandlerToolbarItemType type,const char *label, const char *hint,int pos, const Bonobo_Control control,BonoboUIHandlerPixmapType pixmap_type,gpointer pixmap_data, guint accelerator_key,GdkModifierType ac_mods,BonoboUIHandlerCallbackFunc callback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_new_control</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,int pos, Bonobo_Control control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_new_item</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,const char *label, const char *hint, int pos,BonoboUIHandlerPixmapType pixmap_type,gpointer pixmap_data,guint accelerator_key, GdkModifierType ac_mods,BonoboUIHandlerCallbackFunc callback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_new_separator</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path, int pos
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_new_radiogroup</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_new_radioitem</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,const char *label, const char *hint, int pos,BonoboUIHandlerPixmapType pixmap_type,gpointer pixmap_data,guint accelerator_key, GdkModifierType ac_mods,BonoboUIHandlerCallbackFunc callback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_new_toggleitem</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,const char *label, const char *hint, int pos,BonoboUIHandlerPixmapType pixmap_type,gpointer pixmap_data,guint accelerator_key, GdkModifierType ac_mods,BonoboUIHandlerCallbackFunc callback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_add_one</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *parent_path,BonoboUIHandlerToolbarItem *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_add_list</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *parent_path,BonoboUIHandlerToolbarItem *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_add_tree</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *parent_path,BonoboUIHandlerToolbarItem *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_remove</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_fetch_one</NAME>
<RETURNS>BonoboUIHandlerToolbarItem 	*</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_fetch_list</NAME>
<RETURNS>BonoboUIHandlerToolbarItem 	*</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_fetch_tree</NAME>
<RETURNS>BonoboUIHandlerToolbarItem 	*</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_fetch_by_callback</NAME>
<RETURNS>GList 				*</RETURNS>
BonoboUIHandler *uih,BonoboUIHandlerCallbackFunc callback
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_fetch_by_callback_data</NAME>
<RETURNS>GList 				*</RETURNS>
BonoboUIHandler *uih,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_get_child_paths</NAME>
<RETURNS>GList 				*</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_parse_uiinfo_one</NAME>
<RETURNS>BonoboUIHandlerToolbarItem 	*</RETURNS>
GnomeUIInfo *uii
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_parse_uiinfo_list</NAME>
<RETURNS>BonoboUIHandlerToolbarItem 	*</RETURNS>
GnomeUIInfo *uii
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_parse_uiinfo_tree</NAME>
<RETURNS>BonoboUIHandlerToolbarItem 	*</RETURNS>
GnomeUIInfo *uii
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_parse_uiinfo_one_with_data</NAME>
<RETURNS>BonoboUIHandlerToolbarItem 	*</RETURNS>
GnomeUIInfo *uii, void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_parse_uiinfo_list_with_data</NAME>
<RETURNS>BonoboUIHandlerToolbarItem 	*</RETURNS>
GnomeUIInfo *uii, void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_parse_uiinfo_tree_with_data</NAME>
<RETURNS>BonoboUIHandlerToolbarItem 	*</RETURNS>
GnomeUIInfo *uii, void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_free_one</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandlerToolbarItem *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_free_list</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandlerToolbarItem *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_free_tree</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandlerToolbarItem *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_get_pos</NAME>
<RETURNS>int 	</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_set_pos</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,int pos
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_set_sensitivity</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,gboolean sensitive
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_get_sensitivity</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_set_label</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,gchar *label
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_get_label</NAME>
<RETURNS>gchar 				*</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_set_hint</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,gchar *hint
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_get_hint</NAME>
<RETURNS>gchar 				*</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_set_pixmap</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,BonoboUIHandlerPixmapType type, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_get_pixmap</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,BonoboUIHandlerPixmapType *type, gpointer *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_set_accel</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,guint accelerator_key, GdkModifierType ac_mods
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_get_accel</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,guint *aaccelerator_key, GdkModifierType *ac_mods
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_set_callback</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,BonoboUIHandlerCallbackFunc callback,gpointer callback_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_get_callback</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path,BonoboUIHandlerCallbackFunc *callback,gpointer *callback_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_toggle_set_state</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path, gboolean state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_toggle_get_state</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_radio_get_state</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_item_radio_set_state</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIHandler *uih, const char *path, gboolean state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_set_orientation</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler *uih, const char *path,GtkOrientation orientation
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_get_orientation</NAME>
<RETURNS>GtkOrientation  </RETURNS>
BonoboUIHandler *uih, const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_dock_add</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIHandler       *uih,const char            *name,Bonobo_Control         control,GnomeDockItemBehavior  behavior,GnomeDockPlacement     placement,gint                   band_num,gint                   band_position,gint                   offset
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_dock_remove</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIHandler       *uih,const char            *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_dock_set_sensitive</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIHandler       *uih,const char            *name,gboolean               sensitivity
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_dock_get_sensitive</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIHandler       *uih,const char            *name
</FUNCTION>
<VARIABLE>
<NAME>bonobo_ui_handler_vepv</NAME>
extern POA_Bonobo_UIHandler__vepv bonobo_ui_handler_vepv;
</VARIABLE>
<FUNCTION>
<NAME>bonobo_ui_handler_get_epv</NAME>
<RETURNS>POA_Bonobo_UIHandler__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_VIEW_FRAME_TYPE</NAME>
#define BONOBO_VIEW_FRAME_TYPE        (bonobo_view_frame_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_VIEW_FRAME</NAME>
#define BONOBO_VIEW_FRAME(o)          (GTK_CHECK_CAST ((o), BONOBO_VIEW_FRAME_TYPE, BonoboViewFrame))
</MACRO>
<MACRO>
<NAME>BONOBO_VIEW_FRAME_CLASS</NAME>
#define BONOBO_VIEW_FRAME_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_VIEW_FRAME_TYPE, BonoboViewFrameClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_VIEW_FRAME</NAME>
#define BONOBO_IS_VIEW_FRAME(o)       (GTK_CHECK_TYPE ((o), BONOBO_VIEW_FRAME_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_VIEW_FRAME_CLASS</NAME>
#define BONOBO_IS_VIEW_FRAME_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_VIEW_FRAME_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboViewFramePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboViewFrame</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboViewFrame</NAME>
struct BonoboViewFrame {
	BonoboControlFrame	 base;
	BonoboViewFramePrivate	*priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboViewFrameClass</NAME>
typedef struct {
	BonoboControlFrameClass parent_class;

	/*
	 * Signals.
	 */
	void (*user_activate)       (BonoboViewFrame *view_frame);
	void (*user_context)        (BonoboViewFrame *view_frame);
} BonoboViewFrameClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_view_frame_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_construct</NAME>
<RETURNS>BonoboViewFrame            *</RETURNS>
BonoboViewFrame  *view_frame,Bonobo_ViewFrame  corba_view_frame,BonoboClientSite *client_site,Bonobo_UIHandler  uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_new</NAME>
<RETURNS>BonoboViewFrame            *</RETURNS>
BonoboClientSite *client_site,Bonobo_UIHandler  uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_bind_to_view</NAME>
<RETURNS>void  </RETURNS>
BonoboViewFrame  *view_frame,Bonobo_View       view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_get_view</NAME>
<RETURNS>Bonobo_View  </RETURNS>
BonoboViewFrame  *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_get_client_site</NAME>
<RETURNS>BonoboClientSite           *</RETURNS>
BonoboViewFrame  *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_get_wrapper</NAME>
<RETURNS>GtkWidget                  *</RETURNS>
BonoboViewFrame  *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_popup_verbs</NAME>
<RETURNS>char                       *</RETURNS>
BonoboViewFrame  *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_set_covered</NAME>
<RETURNS>void  </RETURNS>
BonoboViewFrame  *view_frame,gboolean          covered
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_get_ui_handler</NAME>
<RETURNS>Bonobo_UIHandler  </RETURNS>
BonoboViewFrame *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_view_activate</NAME>
<RETURNS>void  </RETURNS>
BonoboViewFrame  *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_view_deactivate</NAME>
<RETURNS>void  </RETURNS>
BonoboViewFrame  *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_view_do_verb</NAME>
<RETURNS>void  </RETURNS>
BonoboViewFrame  *view_frame,const char       *verb_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_set_zoom_factor</NAME>
<RETURNS>void  </RETURNS>
BonoboViewFrame  *view_frame,double            zoom
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_get_epv</NAME>
<RETURNS>POA_Bonobo_ViewFrame__epv  *</RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>bonobo_view_frame_vepv</NAME>
extern POA_Bonobo_ViewFrame__vepv bonobo_view_frame_vepv;
</VARIABLE>
<MACRO>
<NAME>BONOBO_WIDGET_TYPE</NAME>
#define BONOBO_WIDGET_TYPE        (bonobo_widget_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_WIDGET</NAME>
#define BONOBO_WIDGET(o)          (GTK_CHECK_CAST ((o), BONOBO_WIDGET_TYPE, BonoboWidget))
</MACRO>
<MACRO>
<NAME>BONOBO_WIDGET_CLASS</NAME>
#define BONOBO_WIDGET_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_WIDGET_TYPE, BonoboWidgetClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WIDGET</NAME>
#define BONOBO_IS_WIDGET(o)       (GTK_CHECK_TYPE ((o), BONOBO_WIDGET_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WIDGET_CLASS</NAME>
#define BONOBO_IS_WIDGET_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_WIDGET_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboWidget</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWidgetPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWidget</NAME>
struct BonoboWidget {
	GtkBin		          bin;

	BonoboWidgetPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboWidgetClass</NAME>
typedef struct {
	GtkBinClass	 bin_class;
} BonoboWidgetClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_widget_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_server</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
BonoboWidget     *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_new_control</NAME>
<RETURNS>GtkWidget           *</RETURNS>
const char       *goad_id,Bonobo_UIHandler  uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_new_control_from_objref</NAME>
<RETURNS>GtkWidget           *</RETURNS>
Bonobo_Control    control,Bonobo_UIHandler  uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_control_frame</NAME>
<RETURNS>BonoboControlFrame  *</RETURNS>
BonoboWidget     *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_new_subdoc</NAME>
<RETURNS>GtkWidget           *</RETURNS>
const char       *object_desc,Bonobo_UIHandler  uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_container</NAME>
<RETURNS>BonoboContainer     *</RETURNS>
BonoboWidget     *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_client_site</NAME>
<RETURNS>BonoboClientSite    *</RETURNS>
BonoboWidget     *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_view_frame</NAME>
<RETURNS>BonoboViewFrame     *</RETURNS>
BonoboWidget     *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_uih</NAME>
<RETURNS>Bonobo_UIHandler  </RETURNS>
BonoboWidget     *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_set_property</NAME>
<RETURNS>void  </RETURNS>
BonoboWidget      *control,const char        *first_prop,...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_property</NAME>
<RETURNS>void  </RETURNS>
BonoboWidget      *control,const char        *first_prop,...
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_WRAPPER</NAME>
#define GNOME_TYPE_WRAPPER            (bonobo_wrapper_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_WRAPPER</NAME>
#define BONOBO_WRAPPER(obj)            (GTK_CHECK_CAST ((obj), GNOME_TYPE_WRAPPER, BonoboWrapper))
</MACRO>
<MACRO>
<NAME>BONOBO_WRAPPER_CLASS</NAME>
#define BONOBO_WRAPPER_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_WRAPPER, BonoboWrapperClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WRAPPER</NAME>
#define BONOBO_IS_WRAPPER(obj)         (GTK_CHECK_TYPE ((obj), GNOME_TYPE_WRAPPER))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WRAPPER_CLASS</NAME>
#define BONOBO_IS_WRAPPER_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GNOME_TYPE_WRAPPER))
</MACRO>
<STRUCT>
<NAME>BonoboWrapper</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWrapperClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWrapperPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWrapper</NAME>
struct BonoboWrapper {
	GtkBin bin;

	/* Private data. */
	BonoboWrapperPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboWrapperClass</NAME>
struct BonoboWrapperClass {
	GtkBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_wrapper_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_wrapper_new</NAME>
<RETURNS>GtkWidget 	*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_wrapper_set_covered</NAME>
<RETURNS>void 	</RETURNS>
BonoboWrapper *wrapper, gboolean covered
</FUNCTION>
<FUNCTION>
<NAME>bonobo_wrapper_is_covered</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboWrapper *wrapper
</FUNCTION>
<FUNCTION>
<NAME>bonobo_wrapper_get_visibility</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboWrapper *wrapper
</FUNCTION>
<FUNCTION>
<NAME>bonobo_wrapper_set_visibility</NAME>
<RETURNS>void 	</RETURNS>
BonoboWrapper *wrapper, gboolean visible
</FUNCTION>
<MACRO>
<NAME>BONOBO_VIEW_TYPE</NAME>
#define BONOBO_VIEW_TYPE        (bonobo_view_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_VIEW</NAME>
#define BONOBO_VIEW(o)          (GTK_CHECK_CAST ((o), BONOBO_VIEW_TYPE, BonoboView))
</MACRO>
<MACRO>
<NAME>BONOBO_VIEW_CLASS</NAME>
#define BONOBO_VIEW_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_VIEW_TYPE, BonoboViewClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_VIEW</NAME>
#define BONOBO_IS_VIEW(o)       (GTK_CHECK_TYPE ((o), BONOBO_VIEW_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_VIEW_CLASS</NAME>
#define BONOBO_IS_VIEW_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_VIEW_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboView</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboViewPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboViewClass</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_VIEW_VERB_FUNC</NAME>
#define BONOBO_VIEW_VERB_FUNC(fn) ((BonoboViewVerbFunc)(fn))
</MACRO>
<USER_FUNCTION>
<NAME>BonoboViewVerbFunc</NAME>
<RETURNS>void </RETURNS>
BonoboView *view, const char *verb_name, void *user_data
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboView</NAME>
struct BonoboView {
	BonoboControl base;

	BonoboEmbeddable  *embeddable;
	Bonobo_ViewFrame   view_frame;
	BonoboViewPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboViewClass</NAME>
struct BonoboViewClass {
	BonoboControlClass parent_class;

	/*
	 * Signals
	 */
	void (*do_verb)                  (BonoboView *view,
					  const CORBA_char *verb_name);
	void (*set_zoom_factor)          (BonoboView *view, double zoom);
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_view_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_construct</NAME>
<RETURNS>BonoboView            *</RETURNS>
BonoboView         *view,Bonobo_View         corba_view,GtkWidget          *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_new</NAME>
<RETURNS>BonoboView            *</RETURNS>
GtkWidget          *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_corba_object_create</NAME>
<RETURNS>Bonobo_View  </RETURNS>
BonoboObject       *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_set_embeddable</NAME>
<RETURNS>void  </RETURNS>
BonoboView         *view,BonoboEmbeddable   *embeddable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_embeddable</NAME>
<RETURNS>BonoboEmbeddable      *</RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_set_view_frame</NAME>
<RETURNS>void  </RETURNS>
BonoboView         *view,Bonobo_ViewFrame    view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_view_frame</NAME>
<RETURNS>Bonobo_ViewFrame  </RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_remote_ui_handler</NAME>
<RETURNS>Bonobo_UIHandler  </RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_ui_handler</NAME>
<RETURNS>BonoboUIHandler       *</RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_activate_notify</NAME>
<RETURNS>void  </RETURNS>
BonoboView         *view,gboolean            activated
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_register_verb</NAME>
<RETURNS>void  </RETURNS>
BonoboView         *view,const char         *verb_name,BonoboViewVerbFunc  callback,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_unregister_verb</NAME>
<RETURNS>void  </RETURNS>
BonoboView         *view,const char         *verb_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_execute_verb</NAME>
<RETURNS>void  </RETURNS>
BonoboView         *view,const char         *verb_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_popup_verbs</NAME>
<RETURNS>char                  *</RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_epv</NAME>
<RETURNS>POA_Bonobo_View__epv  *</RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>bonobo_view_vepv</NAME>
extern POA_Bonobo_View__vepv bonobo_view_vepv;
</VARIABLE>
<TYPEDEF>
<NAME>BonoboArg</NAME>
typedef CORBA_any      BonoboArg;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboArgType</NAME>
typedef CORBA_TypeCode BonoboArgType;
</TYPEDEF>
<MACRO>
<NAME>BONOBO_ARG_NULL</NAME>
#define BONOBO_ARG_NULL    TC_null
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_BOOLEAN</NAME>
#define BONOBO_ARG_BOOLEAN TC_boolean
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_INT</NAME>
#define BONOBO_ARG_INT     TC_long
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_LONG</NAME>
#define BONOBO_ARG_LONG    TC_long
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_FLOAT</NAME>
#define BONOBO_ARG_FLOAT   TC_float
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_DOUBLE</NAME>
#define BONOBO_ARG_DOUBLE  TC_double
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_STRING</NAME>
#define BONOBO_ARG_STRING  TC_string
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_GET_GENERAL</NAME>
#define BONOBO_ARG_GET_GENERAL(a,t)   (g_assert ((a)->_type->kind == CORBA_tk##t),	\
				       *((CORBA##t *)(a->_value)))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_SET_GENERAL</NAME>
#define BONOBO_ARG_SET_GENERAL(a,v,t) (g_assert ((a)->_type->kind == CORBA_tk##t),	\
				       *((CORBA##t *)(a->_value)) = (CORBA##t)(v))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_GET_BOOLEAN</NAME>
#define BONOBO_ARG_GET_BOOLEAN(a)   (BONOBO_ARG_GET_GENERAL (a, _boolean))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_SET_BOOLEAN</NAME>
#define BONOBO_ARG_SET_BOOLEAN(a,v) (BONOBO_ARG_SET_GENERAL (a, v, _boolean))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_GET_INT</NAME>
#define BONOBO_ARG_GET_INT(a)       (BONOBO_ARG_GET_GENERAL (a, _long))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_SET_INT</NAME>
#define BONOBO_ARG_SET_INT(a,v)     (BONOBO_ARG_SET_GENERAL (a, v, _long))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_GET_LONG</NAME>
#define BONOBO_ARG_GET_LONG(a)      (BONOBO_ARG_GET_GENERAL (a, _long))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_SET_LONG</NAME>
#define BONOBO_ARG_SET_LONG(a,v)    (BONOBO_ARG_SET_GENERAL (a, v, _long))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_GET_FLOAT</NAME>
#define BONOBO_ARG_GET_FLOAT(a)     (BONOBO_ARG_GET_GENERAL (a, _float))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_SET_FLOAT</NAME>
#define BONOBO_ARG_SET_FLOAT(a,v)   (BONOBO_ARG_SET_GENERAL (a, v, _float))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_GET_DOUBLE</NAME>
#define BONOBO_ARG_GET_DOUBLE(a)    (BONOBO_ARG_GET_GENERAL (a, _double))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_SET_DOUBLE</NAME>
#define BONOBO_ARG_SET_DOUBLE(a,v)  (BONOBO_ARG_SET_GENERAL (a, v, _double))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_GET_STRING</NAME>
#define BONOBO_ARG_GET_STRING(a)    (g_assert ((a)->_type->kind == CORBA_tk_string),	\
				     *((CORBA_char **)(a->_value)))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_SET_STRING</NAME>
#define BONOBO_ARG_SET_STRING(a,v)  (g_assert ((a)->_type->kind == CORBA_tk_string),	\
				     *((CORBA_char **)(a->_value)) = CORBA_string_dup ((v)?(v):""))
</MACRO>
<FUNCTION>
<NAME>bonobo_arg_new</NAME>
<RETURNS>BonoboArg     *</RETURNS>
BonoboArgType t
</FUNCTION>
<FUNCTION>
<NAME>bonobo_arg_init_default</NAME>
<RETURNS>void  </RETURNS>
BonoboArg    *arg
</FUNCTION>
<FUNCTION>
<NAME>bonobo_arg_release</NAME>
<RETURNS>void  </RETURNS>
BonoboArg    *arg
</FUNCTION>
<FUNCTION>
<NAME>bonobo_arg_copy</NAME>
<RETURNS>BonoboArg     *</RETURNS>
BonoboArg    *arg
</FUNCTION>
<FUNCTION>
<NAME>bonobo_arg_from_gtk</NAME>
<RETURNS>void  </RETURNS>
BonoboArg    *a, const GtkArg       *arg
</FUNCTION>
<FUNCTION>
<NAME>bonobo_arg_type_from_gtk</NAME>
<RETURNS>BonoboArgType  </RETURNS>
GtkType       t
</FUNCTION>
<FUNCTION>
<NAME>bonobo_arg_to_gtk</NAME>
<RETURNS>void  </RETURNS>
GtkArg       *a, const BonoboArg    *arg
</FUNCTION>
<STRUCT>
<NAME>BonoboUIHandlerTopLevelData</NAME>
struct BonoboUIHandlerTopLevelData {
	/*
	 * These hash tables are used to maintain an internal
	 * representation of the menu and toolbar trees.  They store
	 * internal data structures which you shouldn't muck with.
	 */
	GHashTable			*path_to_menu_item;

	GHashTable			*path_to_toolbar_item;
	GHashTable			*name_to_toolbar;

	GHashTable                      *name_to_dock;

	/*
	 * Some application-global widget data.
	 */
	GnomeApp			*app;
	GtkAccelGroup			*accelgroup;
	GtkWidget			*statusbar;
	GtkWidget			*menubar;
	GtkWidget			*common_toolbar;
	GHashTable			*toolbars;

	/*
	 * This hash table maps menu item paths to the actual
	 * GtkMenuItem widgets.
	 */
	GHashTable			*path_to_menu_widget;

	/*
	 * This hash table maps subtree paths to the GtkMenuShell
	 * widget.
	 */
	GHashTable			*path_to_menu_shell;

	/* FIXME: Comments */
	GHashTable			*name_to_toolbar_widget;
	GHashTable			*path_to_toolbar_item_widget;

	/*
	 * If this UIHandler is for a top-level application which is
	 * acting as a container for one or more embedded objects,
	 * then this list contains the interfaces for the
	 * BonoboUIHandlers for the embedded objects.
	 */
	GList				*containee_uihs;
};
</STRUCT>
<STRUCT>
<NAME>MenuItemLocalInternal</NAME>
typedef struct {

	/*
	 * A list of child paths, if appropriate.  
	 */
	GList				*children;

	BonoboUIHandlerCallbackFunc	 callback;
	gpointer			 callback_data;
} MenuItemLocalInternal;
</STRUCT>
<STRUCT>
<NAME>ToolbarItemInternal</NAME>
</STRUCT>
<STRUCT>
<NAME>ToolbarToolbarInternal</NAME>
</STRUCT>
<STRUCT>
<NAME>ToolbarItemLocalInternal</NAME>
</STRUCT>
<STRUCT>
<NAME>ToolbarToolbarLocalInternal</NAME>
</STRUCT>
<STRUCT>
<NAME>ToolbarItemInternal</NAME>
struct ToolbarItemInternal {
	/*
	 * The BonoboUIHandler.
	 */
	BonoboUIHandler *uih;

	/*
	 * A copy of the BonoboUIHandlerToolbarItem for this toolbar item.
	 */
	BonoboUIHandlerToolbarItem *item;

	/*
	 * The UIHandler CORBA interface for the containee which owns
	 * this particular menu item.
	 */
	Bonobo_UIHandler uih_corba;

	/*
	 * In the world of toolbars, only radio groups can have
	 * children.
	 */
	GList *children;

	gboolean sensitive;
};
</STRUCT>
<STRUCT>
<NAME>ToolbarToolbarInternal</NAME>
struct ToolbarToolbarInternal {

	/*
	 * This toolbar's name. e.g. "Common"
	 * The path for a toolbar item will be something like "/Common/Help"
	 */
	char			 *name;

	/*
	 * A list of paths for the items in this toolbar.
	 */
	GList			 *children;

	/*
	 * The owner for this toolbar.
	 */
	Bonobo_UIHandler		 uih_corba;

	GtkOrientation		 orientation;
	GtkToolbarStyle		 style;
	GtkToolbarSpaceStyle	 space_style;
	int			 space_size;
	GtkReliefStyle		 relief;
};
</STRUCT>
<STRUCT>
<NAME>ToolbarItemLocalInternal</NAME>
struct ToolbarItemLocalInternal {
	BonoboUIHandlerCallbackFunc callback;
	gpointer	           callback_data;
};
</STRUCT>
<STRUCT>
<NAME>ToolbarToolbarLocalInternal</NAME>
struct ToolbarToolbarLocalInternal {
	GList		*children;
};
</STRUCT>
<STRUCT>
<NAME>UIRemoteAttributeData</NAME>
typedef struct {
	CORBA_char       *label, *hint;
	CORBA_long        accelerator_key, ac_mods, pos;
	CORBA_boolean     toggle_state, sensitive, active;
} UIRemoteAttributeData;
</STRUCT>
<STRUCT>
<NAME>ToolbarRemoteAttributeData</NAME>
typedef struct {
	Bonobo_UIHandler_ToolbarOrientation orientation;
	Bonobo_UIHandler_ToolbarStyle       style;
	Bonobo_UIHandler_ToolbarSpaceStyle  space_style;
	Bonobo_UIHandler_ReliefStyle        relief_style;
	CORBA_long                         space_size;
	CORBA_boolean                      sensitive;
} ToolbarRemoteAttributeData;
</STRUCT>
<FUNCTION>
<NAME>bonobo_ui_handler_path_tokenize</NAME>
<RETURNS>gchar     **</RETURNS>
const char *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_remote_attribute_data_free</NAME>
<RETURNS>void  </RETURNS>
UIRemoteAttributeData         *attrs
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toplevel_check_toplevel</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIHandler               *uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toplevel_add_containee</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler               *uih,Bonobo_UIHandler               containee
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_pixmap_free_data</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandlerPixmapType      pixmap_type,gpointer                       pixmap_info
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_pixmap_copy_data</NAME>
<RETURNS>gpointer  </RETURNS>
BonoboUIHandlerPixmapType      pixmap_type,const gconstpointer            pixmap_info
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_pixmap_data_to_corba</NAME>
<RETURNS>Bonobo_UIHandler_iobuf       *</RETURNS>
BonoboUIHandlerPixmapType      type,gpointer                       data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_pixmap_corba_to_type</NAME>
<RETURNS>Bonobo_UIHandler_PixmapType  </RETURNS>
Bonobo_UIHandler_PixmapType    type
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_pixmap_type_to_corba</NAME>
<RETURNS>Bonobo_UIHandler_PixmapType  </RETURNS>
BonoboUIHandlerPixmapType      type
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_pixmap_corba_to_data</NAME>
<RETURNS>gpointer  </RETURNS>
Bonobo_UIHandler_PixmapType    corba_pixmap_type,const Bonobo_UIHandler_iobuf  *corba_pixmap_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_local_do_path</NAME>
<RETURNS>void  </RETURNS>
const char                    *parent_path,const char                    *item_label,char                         **item_path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toplevel_check_toplevel</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIHandler               *uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_path_get_parent</NAME>
<RETURNS>gchar                        *</RETURNS>
const char                    *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toplevel_create_pixmap</NAME>
<RETURNS>GtkWidget                    *</RETURNS>
GtkWidget                     *window,BonoboUIHandlerPixmapType      pixmap_type,gpointer                       pixmap_info
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_uiinfo_pixmap_type_to_uih</NAME>
<RETURNS>BonoboUIHandlerPixmapType  </RETURNS>
GnomeUIPixmapType              ui_type
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_menu_toplevel_remove_item_internal</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler               *uih,MenuItemInternal              *internal,gboolean                       replace
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toolbar_toplevel_remove_item_internal</NAME>
<RETURNS>void  </RETURNS>
BonoboUIHandler               *uih,ToolbarItemInternal           *internal
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_menu_activated</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const CORBA_char                           *path,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_menu_overridden</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const CORBA_char                           *path,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_menu_create</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const Bonobo_UIHandler                      containee_uih,const CORBA_char                           *path,Bonobo_UIHandler_MenuType                   menu_type,const CORBA_char                           *label,const CORBA_char                           *hint,CORBA_long                                  pos,const Bonobo_UIHandler_PixmapType           pixmap_type,const Bonobo_UIHandler_iobuf               *pixmap_data,CORBA_unsigned_long                         accelerator_key,CORBA_long                                  modifier,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_menu_removed</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const CORBA_char                           *path,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_menu_reinstated</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const CORBA_char                           *path,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_menu_remove</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,Bonobo_UIHandler                            containee_uih,const CORBA_char                           *path,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_menu_fetch</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const CORBA_char                           *path,Bonobo_UIHandler_MenuType                  *type,CORBA_char                                **label,CORBA_char                                **hint,CORBA_long                                 *pos,Bonobo_UIHandler_PixmapType                *pixmap_type,Bonobo_UIHandler_iobuf                    **pixmap_data,CORBA_unsigned_long                        *accelerator_key,CORBA_long                                 *modifier,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_menu_get_children</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const CORBA_char                           *parent_path,Bonobo_UIHandler_StringSeq                **child_paths,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_menu_set_data</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,Bonobo_UIHandler                            containee_uih,const CORBA_char                           *path,Bonobo_UIHandler_PixmapType                 corba_pixmap_type,const Bonobo_UIHandler_iobuf               *corba_pixmap_data,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_menu_get_data</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,Bonobo_UIHandler                            containee_uih,const CORBA_char                           *path,Bonobo_UIHandler_PixmapType                *corba_pixmap_type,Bonobo_UIHandler_iobuf                    **corba_pixmap_data,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_menu_set_attributes</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const Bonobo_UIHandler                      containee_uih,const CORBA_char                           *path,CORBA_boolean                               sensitive,CORBA_long                                  pos,const CORBA_char                           *label,const CORBA_char                           *hint,CORBA_long                                  accelerator_key,CORBA_long                                  ac_mods,CORBA_boolean                               toggle_state,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_menu_get_attributes</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const Bonobo_UIHandler                      containee_uih,const CORBA_char                           *path,CORBA_boolean                              *sensitive,CORBA_long                                 *pos,CORBA_char                                **label,CORBA_char                                **hint,CORBA_long                                 *accelerator_key,CORBA_long                                 *ac_mods,CORBA_boolean                              *toggle_state,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_toolbar_create</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const Bonobo_UIHandler                      containee,const CORBA_char                           *name,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_toolbar_remove</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,Bonobo_UIHandler                            containee,const CORBA_char                           *name,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_toolbar_overridden</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const CORBA_char                           *path,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_toolbar_activated</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const CORBA_char                           *path,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_toolbar_create_item</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const Bonobo_UIHandler                      containee_uih,const CORBA_char                           *path,Bonobo_UIHandler_ToolbarType                toolbar_type,const CORBA_char                           *label,const CORBA_char                           *hint,CORBA_long                                  pos,const Bonobo_Control                        control,Bonobo_UIHandler_PixmapType                 pixmap_type,const Bonobo_UIHandler_iobuf               *pixmap_data,CORBA_unsigned_long                         accelerator_key,CORBA_long                                  modifier,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_toolbar_reinstated</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const CORBA_char                           *path,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_toolbar_removed</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const CORBA_char                           *path,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_toolbar_remove_item</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,Bonobo_UIHandler                            containee_uih,const CORBA_char                           *path,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_toolbar_item_get_attributes</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const Bonobo_UIHandler                      containee,const CORBA_char                           *path,CORBA_boolean                              *sensitive,CORBA_boolean                              *active,CORBA_long                                 *pos,CORBA_char                                **label,CORBA_char                                **hint,CORBA_long                                 *accelerator_key,CORBA_long                                 *ac_mods,CORBA_boolean                              *toggle_state,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_toolbar_item_set_attributes</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const Bonobo_UIHandler                      containee,const CORBA_char                           *path,CORBA_boolean                               sensitive,CORBA_boolean                               active,CORBA_long                                  pos,const CORBA_char                           *label,const CORBA_char                           *hint,CORBA_long                                  accelerator_key,CORBA_long                                  ac_mods,CORBA_boolean                               toggle_state,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_toolbar_item_set_data</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,Bonobo_UIHandler                            containee_uih,const CORBA_char                           *path,Bonobo_UIHandler_PixmapType                 corba_pixmap_type,const Bonobo_UIHandler_iobuf               *corba_pixmap_data,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_toolbar_item_get_data</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,Bonobo_UIHandler                            containee_uih,const CORBA_char                           *path,Bonobo_UIHandler_PixmapType                *corba_pixmap_type,Bonobo_UIHandler_iobuf                    **corba_pixmap_data,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_toolbar_set_attributes</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const Bonobo_UIHandler                      containee,const CORBA_char                           *name,const Bonobo_UIHandler_ToolbarOrientation   orientation,const Bonobo_UIHandler_ToolbarStyle         style,const Bonobo_UIHandler_ToolbarSpaceStyle    space_style,const Bonobo_UIHandler_ReliefStyle          relief_style,const CORBA_long                            space_size,const CORBA_boolean                         sensitive,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_toolbar_get_attributes</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant                      servant,const Bonobo_UIHandler                      containee,const CORBA_char                           *path,Bonobo_UIHandler_ToolbarOrientation        *orientation,Bonobo_UIHandler_ToolbarStyle              *style,Bonobo_UIHandler_ToolbarSpaceStyle         *space_style,Bonobo_UIHandler_ReliefStyle               *relief_style,CORBA_long                                 *space_size,CORBA_boolean                              *sensitive,CORBA_Environment                          *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_handler_toplevel_dock_remove</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIHandler        *uih,const Bonobo_UIHandler  containee,const char             *name
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_dock_add</NAME>
<RETURNS>CORBA_boolean  </RETURNS>
PortableServer_Servant                servant,const Bonobo_UIHandler                containee,const CORBA_char                     *name,const Bonobo_Control                  control,const CORBA_long                      corba_behavior,const Bonobo_UIHandler_DockPlacement  corba_placement,const CORBA_long                      band_num,const CORBA_long                      band_position,const CORBA_long                      offset,CORBA_Environment                    *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_dock_remove</NAME>
<RETURNS>CORBA_boolean  </RETURNS>
PortableServer_Servant                servant,const Bonobo_UIHandler                containee,const CORBA_char                     *name,CORBA_Environment                    *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_dock_set_sensitive</NAME>
<RETURNS>CORBA_boolean  </RETURNS>
PortableServer_Servant                servant,const Bonobo_UIHandler                containee,const CORBA_char                     *name,const CORBA_boolean                   sensitivity,CORBA_Environment                    *ev
</FUNCTION>
<FUNCTION>
<NAME>impl_Bonobo_UIHandler_dock_get_sensitive</NAME>
<RETURNS>CORBA_boolean  </RETURNS>
PortableServer_Servant                servant,const Bonobo_UIHandler                containee,const CORBA_char                     *name,CORBA_Environment                    *ev
</FUNCTION>
<MACRO>
<NAME>CORBIFY_STRING</NAME>
#define CORBIFY_STRING(s)   ((s) == NULL ? "" : (s))
</MACRO>
<MACRO>
<NAME>UNCORBIFY_STRING</NAME>
#define UNCORBIFY_STRING(s) ((strlen (s) == 0) ? NULL : (s))
</MACRO>
<MACRO>
<NAME>COPY_STRING</NAME>
#define COPY_STRING(s)      (s == NULL ? NULL : g_strdup (s))
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT_TYPE</NAME>
#define BONOBO_PRINT_TYPE        (bonobo_print_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT</NAME>
#define BONOBO_PRINT(o)          (GTK_CHECK_CAST ((o), BONOBO_PRINT_TYPE, BonoboPrint))
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT_CLASS</NAME>
#define BONOBO_PRINT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PRINT_TYPE, BonoboPrintClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PRINT</NAME>
#define BONOBO_IS_PRINT(o)       (GTK_CHECK_TYPE ((o), BONOBO_PRINT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PRINT_CLASS</NAME>
#define BONOBO_IS_PRINT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PRINT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPrint</NAME>
typedef struct {
        BonoboObject         object;

	BonoboPrintRenderFn *render;
	gpointer             user_data;
} BonoboPrint;
</STRUCT>
<STRUCT>
<NAME>BonoboPrintClass</NAME>
typedef struct {
	BonoboObjectClass parent;
} BonoboPrintClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_print_get_epv</NAME>
<RETURNS>POA_Bonobo_Print__epv  *</RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>bonobo_print_vepv</NAME>
extern POA_Bonobo_Print__vepv bonobo_print_vepv;
</VARIABLE>
<FUNCTION>
<NAME>bonobo_print_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_new</NAME>
<RETURNS>BonoboPrint     *</RETURNS>
BonoboPrintRenderFn *render,gpointer             user_data
</FUNCTION>
<STRUCT>
<NAME>BonoboPrintClient</NAME>
typedef struct {
	GtkObject    parent;
	Bonobo_Print corba_print;
} BonoboPrintClient;
</STRUCT>
<STRUCT>
<NAME>BonoboPrintClientClass</NAME>
typedef struct {
	GtkObjectClass			parent;
} BonoboPrintClientClass;
</STRUCT>
<STRUCT>
<NAME>BonoboPrintData</NAME>
typedef struct {
	double width;
	double height;
	
	double width_first_page;
	double width_per_page;
	double height_first_page;
	double height_per_page;

	GnomePrintMeta *meta_data;
} BonoboPrintData;
</STRUCT>
<FUNCTION>
<NAME>bonobo_print_client_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_client_new</NAME>
<RETURNS>BonoboPrintClient   *</RETURNS>
Bonobo_Print         corba_print
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_client_get</NAME>
<RETURNS>BonoboPrintClient   *</RETURNS>
BonoboObjectClient  *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_client_render</NAME>
<RETURNS>void  </RETURNS>
BonoboPrintClient   *client,BonoboPrintData     *pd
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_new</NAME>
<RETURNS>BonoboPrintData     *</RETURNS>
double               width,double               height
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_new_full</NAME>
<RETURNS>BonoboPrintData     *</RETURNS>
double               width,double               height,double               width_first_page,double               width_per_page,double               height_first_page,double               height_per_page
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_free</NAME>
<RETURNS>void  </RETURNS>
BonoboPrintData     *pd
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_get_meta</NAME>
<RETURNS>GnomePrintMeta      *</RETURNS>
BonoboPrintData     *pd
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_render</NAME>
<RETURNS>void  </RETURNS>
GnomePrintContext   *pc,double               x,double               y,BonoboPrintData     *pd,double               meta_x,double               meta_y
</FUNCTION>
<MACRO>
<NAME>BONOBO_PRINT_CLIENT_TYPE</NAME>
#define BONOBO_PRINT_CLIENT_TYPE        (bonobo_print_client_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT_CLIENT</NAME>
#define BONOBO_PRINT_CLIENT(o)          (GTK_CHECK_CAST ((o), BONOBO_PRINT_CLIENT_TYPE, BonoboPrintClient))
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT_CLIENT_CLASS</NAME>
#define BONOBO_PRINT_CLIENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PRINT_CLIENT_TYPE, BonoboPrintClientClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PRINT_CLIENT</NAME>
#define BONOBO_IS_PRINT_CLIENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_PRINT_CLIENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PRINT_CLIENT_CLASS</NAME>
#define BONOBO_IS_PRINT_CLIENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PRINT_CLIENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_STORAGE_EFS_TYPE</NAME>
#define BONOBO_STORAGE_EFS_TYPE        (bonobo_storage_efs_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_STORAGE_EFS</NAME>
#define BONOBO_STORAGE_EFS(o)          (GTK_CHECK_CAST ((o), BONOBO_STORAGE_EFS_TYPE, BonoboStorageEFS))
</MACRO>
<MACRO>
<NAME>BONOBO_STORAGE_EFS_CLASS</NAME>
#define BONOBO_STORAGE_EFS_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_STORAGE_EFS_TYPE, BonoboStorageEFSClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STORAGE_EFS</NAME>
#define BONOBO_IS_STORAGE_EFS(o)       (GTK_CHECK_TYPE ((o), BONOBO_STORAGE_EFS_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STORAGE_EFS_CLASS</NAME>
#define BONOBO_IS_STORAGE_EFS_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_STORAGE_EFS_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboStorageEFS</NAME>
typedef struct {
        BonoboStorage storage;
	BonoboStorage *owner;
	EFSDir *dir;
} BonoboStorageEFS;
</STRUCT>
<STRUCT>
<NAME>BonoboStorageEFSClass</NAME>
typedef struct {
	BonoboStorageClass parent_class;
} BonoboStorageEFSClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_storage_efs_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_efs_open</NAME>
<RETURNS>BonoboStorage  *</RETURNS>
const gchar *path, gint flags,gint mode
</FUNCTION>
<MACRO>
<NAME>BONOBO_STORAGE_FS_TYPE</NAME>
#define BONOBO_STORAGE_FS_TYPE        (bonobo_storage_fs_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_STORAGE_FS</NAME>
#define BONOBO_STORAGE_FS(o)          (GTK_CHECK_CAST ((o), BONOBO_STORAGE_FS_TYPE, BonoboStorageFS))
</MACRO>
<MACRO>
<NAME>BONOBO_STORAGE_FS_CLASS</NAME>
#define BONOBO_STORAGE_FS_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_STORAGE_FS_TYPE, BonoboStorageFSClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STORAGE_FS</NAME>
#define BONOBO_IS_STORAGE_FS(o)       (GTK_CHECK_TYPE ((o), BONOBO_STORAGE_FS_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STORAGE_FS_CLASS</NAME>
#define BONOBO_IS_STORAGE_FS_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_STORAGE_FS_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboStorageFS</NAME>
typedef struct {
	BonoboStorage storage;
	char *path;
} BonoboStorageFS;
</STRUCT>
<STRUCT>
<NAME>BonoboStorageFSClass</NAME>
typedef struct {
	BonoboStorageClass parent_class;
} BonoboStorageFSClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_storage_fs_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_fs_construct</NAME>
<RETURNS>BonoboStorage    *</RETURNS>
BonoboStorageFS *storage,Bonobo_Storage corba_storage,const char *path, const char *open_mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_fs_open</NAME>
<RETURNS>BonoboStorage    *</RETURNS>
const char *path,gint flags, gint mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_fs_create</NAME>
<RETURNS>BonoboStorage    *</RETURNS>
BonoboStorageFS *storage_fs,const CORBA_char *path
</FUNCTION>
<MACRO>
<NAME>BONOBO_STREAM_EFS_TYPE</NAME>
#define BONOBO_STREAM_EFS_TYPE        (bonobo_stream_efs_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_EFS</NAME>
#define BONOBO_STREAM_EFS(o)          (GTK_CHECK_CAST ((o), BONOBO_STREAM_EFS_TYPE, BonoboStreamEFS))
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_EFS_CLASS</NAME>
#define BONOBO_STREAM_EFS_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_STREAM_EFS_TYPE, BonoboStreamEFSClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM_EFS</NAME>
#define BONOBO_IS_STREAM_EFS(o)       (GTK_CHECK_TYPE ((o), BONOBO_STREAM_EFS_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM_EFS_CLASS</NAME>
#define BONOBO_IS_STREAM_EFS_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_STREAM_EFS_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboStreamEFS</NAME>
typedef struct {
	BonoboStream stream;
	BonoboStorageEFS *storage;
	EFSFile *file;
} BonoboStreamEFS;
</STRUCT>
<STRUCT>
<NAME>BonoboStreamEFSClass</NAME>
typedef struct {
	BonoboStreamClass parent_class;
} BonoboStreamEFSClass;
</STRUCT>
<FUNCTION>
<NAME>bonobo_stream_efs_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_efs_open</NAME>
<RETURNS>BonoboStream     *</RETURNS>
BonoboStorageEFS *storage,const CORBA_char *path,Bonobo_Storage_OpenMode mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_efs_create</NAME>
<RETURNS>BonoboStream     *</RETURNS>
BonoboStorageEFS *storage,const CORBA_char *path
</FUNCTION>
<MACRO>
<NAME>STDC_HEADERS</NAME>
#define STDC_HEADERS 1
</MACRO>
<MACRO>
<NAME>D_INO_IN_DIRENT</NAME>
#define D_INO_IN_DIRENT 1
</MACRO>
<MACRO>
<NAME>HAVE_DIRENT_H</NAME>
#define HAVE_DIRENT_H 1
</MACRO>
<MACRO>
<NAME>HAVE_FCNTL_H</NAME>
#define HAVE_FCNTL_H 1
</MACRO>
<MACRO>
<NAME>HAVE_SYS_FILE_H</NAME>
#define HAVE_SYS_FILE_H 1
</MACRO>
<MACRO>
<NAME>HAVE_UNISTD_H</NAME>
#define HAVE_UNISTD_H 1
</MACRO>
<MACRO>
<NAME>HAVE_ZLIB_H</NAME>
#define HAVE_ZLIB_H 1
</MACRO>
<MACRO>
<NAME>PACKAGE</NAME>
#define PACKAGE "libefs"
</MACRO>
<MACRO>
<NAME>VERSION</NAME>
#define VERSION "0.1.0"
</MACRO>
<VARIABLE>
<NAME>file_ops_comp_simple</NAME>
extern EFSFileOps file_ops_comp_simple;
</VARIABLE>
<VARIABLE>
<NAME>file_ops_comp_fsys</NAME>
extern EFSFileOps file_ops_comp_fsys;
</VARIABLE>
<STRUCT>
<NAME>COMPFile</NAME>
typedef struct {
	EFSFile      file;
        EFSFile      *of;
	z_stream     stream;
	guint8       *inbuf;
	guint8       *outbuf;
} COMPFile;
</STRUCT>
<MACRO>
<NAME>EFS_READ</NAME>
#define EFS_READ   1 
</MACRO>
<MACRO>
<NAME>EFS_WRITE</NAME>
#define EFS_WRITE  2
</MACRO>
<MACRO>
<NAME>EFS_RDWR</NAME>
#define EFS_RDWR   3
</MACRO>
<MACRO>
<NAME>EFS_CREATE</NAME>
#define EFS_CREATE 4
</MACRO>
<MACRO>
<NAME>EFS_EXCL</NAME>
#define EFS_EXCL   8
</MACRO>
<MACRO>
<NAME>EFS_FILE</NAME>
#define EFS_FILE  64
</MACRO>
<MACRO>
<NAME>EFS_DIR</NAME>
#define EFS_DIR   128
</MACRO>
<MACRO>
<NAME>EFS_COMP</NAME>
#define EFS_COMP  256
</MACRO>
<MACRO>
<NAME>EFS_ERASE</NAME>
#define EFS_ERASE 512
</MACRO>
<MACRO>
<NAME>EFS_MAXPATHLEN</NAME>
#define EFS_MAXPATHLEN 1024
</MACRO>
<MACRO>
<NAME>EFS_FDEL</NAME>
#define EFS_FDEL '/'
</MACRO>
<MACRO>
<NAME>EFS_FILE_ID</NAME>
#define EFS_FILE_ID "%EFS"
</MACRO>
<STRUCT>
<NAME>EFSFile</NAME>
</STRUCT>
<TYPEDEF>
<NAME>EFSDir</NAME>
typedef EFSFile         EFSDir;
</TYPEDEF>
<STRUCT>
<NAME>EFSDirEntry</NAME>
typedef struct {
	guint32 inode;
	guint8 type;
	guint16 offset;
	guint8 length;
	gchar *name;
} EFSDirEntry;
</STRUCT>
<STRUCT>
<NAME>EFSStat</NAME>
typedef struct {
	gchar *drivername;
	guint32 blocksize;
	guint32 blocks;
	guint32 free;
	guint32 version;
	guint32 inodes;
	guint32 namelen;
} EFSStat;
</STRUCT>
<FUNCTION>
<NAME>efs_open</NAME>
<RETURNS>EFSDir       *</RETURNS>
const char *path, gint flags, gint mode
</FUNCTION>
<FUNCTION>
<NAME>efs_close</NAME>
<RETURNS>gint  </RETURNS>
EFSDir *root
</FUNCTION>
<FUNCTION>
<NAME>efs_commit</NAME>
<RETURNS>gint  </RETURNS>
EFSDir *root
</FUNCTION>
<FUNCTION>
<NAME>efs_stat</NAME>
<RETURNS>EFSStat      *</RETURNS>
EFSDir *dir
</FUNCTION>
<FUNCTION>
<NAME>efs_file_open</NAME>
<RETURNS>EFSFile      *</RETURNS>
EFSDir *dir, const char *path, gint flags
</FUNCTION>
<FUNCTION>
<NAME>efs_file_close</NAME>
<RETURNS>gint  </RETURNS>
EFSFile *file
</FUNCTION>
<FUNCTION>
<NAME>efs_file_seek</NAME>
<RETURNS>gint32  </RETURNS>
EFSFile *file, gint32 offset, gint whence
</FUNCTION>
<FUNCTION>
<NAME>efs_file_read</NAME>
<RETURNS>gint32  </RETURNS>
EFSFile *file, void *buf, gint32 count
</FUNCTION>
<FUNCTION>
<NAME>efs_file_write</NAME>
<RETURNS>gint32  </RETURNS>
EFSFile *file, void *buf, gint32 count
</FUNCTION>
<FUNCTION>
<NAME>efs_file_trunc</NAME>
<RETURNS>gint  </RETURNS>
EFSFile *file, guint32 size
</FUNCTION>
<FUNCTION>
<NAME>efs_erase</NAME>
<RETURNS>gint  </RETURNS>
EFSDir *dir, const char *path
</FUNCTION>
<FUNCTION>
<NAME>efs_rename</NAME>
<RETURNS>gint  </RETURNS>
EFSDir *dir, const char *old_path,const char *new_path
</FUNCTION>
<FUNCTION>
<NAME>efs_dir_open</NAME>
<RETURNS>EFSDir       *</RETURNS>
EFSDir *dir, const char *path, gint flags
</FUNCTION>
<FUNCTION>
<NAME>efs_dir_close</NAME>
<RETURNS>gint  </RETURNS>
EFSDir *dir
</FUNCTION>
<FUNCTION>
<NAME>efs_dir_seek</NAME>
<RETURNS>gint32  </RETURNS>
EFSDir *dir, gint32 offset
</FUNCTION>
<FUNCTION>
<NAME>efs_dir_read</NAME>
<RETURNS>EFSDirEntry  *</RETURNS>
EFSDir *dir
</FUNCTION>
<MACRO>
<NAME>dirent</NAME>
# define dirent direct
</MACRO>
<STRUCT>
<NAME>FSYSFile</NAME>
typedef struct {
	EFSFile      file;
        gint         fd;
} FSYSFile;
</STRUCT>
<STRUCT>
<NAME>FSYSDir</NAME>
typedef struct {
	EFSDir       dir;
        DIR         *d;
	gchar       *path;
	EFSDirEntry  de;
} FSYSDir;
</STRUCT>
<VARIABLE>
<NAME>super_ops_fsys</NAME>
extern EFSSuperOps super_ops_fsys;
</VARIABLE>
<VARIABLE>
<NAME>inode_ops_fsys</NAME>
extern EFSINodeOps inode_ops_fsys;
</VARIABLE>
<VARIABLE>
<NAME>file_ops_fsys</NAME>
extern EFSFileOps  file_ops_fsys;
</VARIABLE>
<MACRO>
<NAME>SIMPLE_NAME_LEN</NAME>
#define SIMPLE_NAME_LEN 248
</MACRO>
<MACRO>
<NAME>SIMPLE_N_BLOCKS</NAME>
#define SIMPLE_N_BLOCKS 16
</MACRO>
<MACRO>
<NAME>NODEP</NAME>
#define NODEP(ce,inode) ((SimpleINode *)(ce->data+(inode%4)*128))
</MACRO>
<STRUCT>
<NAME>SimpleFile</NAME>
typedef struct {
	EFSFile      file;
        guint32      inode;
	guint32      pos;
} SimpleFile;
</STRUCT>
<STRUCT>
<NAME>SimpleDir</NAME>
typedef struct {
	EFSDir       dir;
        guint32      inode;
	guint32      pos;
	EFSDirEntry  de;
} SimpleDir;
</STRUCT>
<STRUCT>
<NAME>SimpleINode</NAME>
typedef struct {
	guint32 inode;
	guint16 rec_len;
	guint8  name_len;
	guint8  type;
	gchar   name[SIMPLE_NAME_LEN];
} SimpleDirEntry ;

typedef struct {
        guint32 num;
	guint32 size;
	guint32 blocks;
	guint32 block[SIMPLE_N_BLOCKS];
	guint32 mod_time;
	gchar   data[48];
} SimpleINode;
</STRUCT>
<STRUCT>
<NAME>SimpleBitmap</NAME>
typedef struct {
	guint32  mbc;
	gboolean modified;
	guint32 *data[512]; /* max 512*512*8 blocks = 1GB */
	guint32  fbc[512];
} SimpleBitmap;
</STRUCT>
<STRUCT>
<NAME>SimpleIMapEntry</NAME>
typedef struct {
	guint32 inode_ind;
	guint32 block[2];
} SimpleIMapEntry;
</STRUCT>
<STRUCT>
<NAME>SimpleIMap</NAME>
typedef struct {
	guint32          max;
	guint32          count;
	gboolean         modified;
	SimpleIMapEntry *data;
} SimpleIMap;
</STRUCT>
<STRUCT>
<NAME>SimpleHeader</NAME>
typedef struct {
	EFSHeader head;
	guint32   block_count;
	guint32   cb;             /* commited blocks */
	guint32   version;
	guint32   imap_start;
	guint32   imap_length;
	guint32   bmap_start;
	guint32   bmap_length;
	guint32   csum;

	gchar buf[512];
} SimpleHeader;
</STRUCT>
<STRUCT>
<NAME>SimpleEFS</NAME>
typedef struct {
	SimpleHeader  head;
	SimpleBitmap  bmap;
	SimpleIMap    imap;
} SimpleEFS;
</STRUCT>
<VARIABLE>
<NAME>super_ops_simple</NAME>
extern EFSSuperOps super_ops_simple;
</VARIABLE>
<VARIABLE>
<NAME>inode_ops_simple</NAME>
extern EFSINodeOps inode_ops_simple;
</VARIABLE>
<VARIABLE>
<NAME>file_ops_simple</NAME>
extern EFSFileOps  file_ops_simple;
</VARIABLE>
<FUNCTION>
<NAME>simple_write_imap</NAME>
<RETURNS>gint  </RETURNS>
EFS *efs
</FUNCTION>
<FUNCTION>
<NAME>simple_write_bmap</NAME>
<RETURNS>gint  </RETURNS>
EFS *efs
</FUNCTION>
<FUNCTION>
<NAME>simple_inode_clone</NAME>
<RETURNS>gint  </RETURNS>
EFS *efs, guint32 inode
</FUNCTION>
<FUNCTION>
<NAME>simple_block_alloc</NAME>
<RETURNS>guint32  </RETURNS>
EFS *efs
</FUNCTION>
<FUNCTION>
<NAME>simple_block_free</NAME>
<RETURNS>void  </RETURNS>
EFS *efs, guint32 block
</FUNCTION>
<FUNCTION>
<NAME>simple_print_fat</NAME>
<RETURNS>void  </RETURNS>
EFS *efs
</FUNCTION>
<MACRO>
<NAME>EFS_ROOT_INODE</NAME>
#define EFS_ROOT_INODE 1
</MACRO>
<MACRO>
<NAME>EFS_CACHE_SIZE</NAME>
#define EFS_CACHE_SIZE 20
</MACRO>
<MACRO>
<NAME>CLOCK</NAME>
#define CLOCK(ce) {ce->lock++;}
</MACRO>
<MACRO>
<NAME>CUNLOCK</NAME>
#define CUNLOCK(ce) {if (ce->lock) ce->lock--;}
</MACRO>
<STRUCT>
<NAME>EFS</NAME>
</STRUCT>
<STRUCT>
<NAME>EFSFile</NAME>
struct EFSFile {
	EFS         *efs;
	guint32      mode;
};
</STRUCT>
<STRUCT>
<NAME>EFSCacheEntry</NAME>
typedef struct {
	guint32   at;
	gboolean  dirty;
	guint16   lock;
	guint32   block;
	guint32   ref_block;
	guint32   ref_pos;
	gchar    *data;
} EFSCacheEntry;
</STRUCT>
<STRUCT>
<NAME>EFSINodeLEntry</NAME>
typedef struct {
	guint32  inode;
	guint32  ref_count;
	gboolean erase;
} EFSINodeLEntry;
</STRUCT>
<STRUCT>
<NAME>EFSDriver</NAME>
</STRUCT>
<STRUCT>
<NAME>EFSSuperOps</NAME>
typedef struct {
	EFSDir     *(*open)      (EFS *efs, const char *path, 
				  gint flags, gint mode);
	gint        (*close)     (EFS *efs);
	gint        (*commit)    (EFS *efs);
	EFSStat    *(*fsstat)    (EFS *efs);
	gint        (*map)       (EFS *efs, EFSCacheEntry *ce, guint32 block);
	gint        (*unmap)     (EFS *efs, EFSCacheEntry *ce);
} EFSSuperOps;
</STRUCT>
<STRUCT>
<NAME>EFSINodeOps</NAME>
typedef struct {
	guint32        (*inode_create) (EFS *efs);
	gint           (*inode_erase)  (EFS *efs, guint32 inode);
	gint           (*inode_trunc)  (EFS *efs, guint32 inode,
					guint32 block);
	EFSCacheEntry *(*inode_map)    (EFS *efs, guint32 inode);
	EFSCacheEntry *(*inode_bmap)   (EFS *efs, guint32 inode, 
					guint32 block);
} EFSINodeOps;
</STRUCT>
<STRUCT>
<NAME>EFSFileOps</NAME>
</STRUCT>
<STRUCT>
<NAME>EFSFileOps</NAME>
struct EFSFileOps {
	EFSFile     *(*file_open)  (EFSDir *dir, const char *path, gint flags);
	EFSDir      *(*dir_open)   (EFSDir *dir, const char *path, gint flags);
	gint         (*file_close) (EFSFile *file);
	gint         (*dir_close)  (EFSDir *dir);
	gint32       (*file_seek)  (EFSFile *file, gint32 offset, gint whence);
	gint32       (*dir_seek)   (EFSDir *dir, gint32 offset);
	gint32       (*file_read)  (EFSFile *file, void *buf, gint32 count);
	gint32       (*file_write) (EFSFile *file, void *buf, gint32 count);
	gint         (*file_trunc) (EFSFile *file, guint32 size);
	EFSDirEntry *(*dir_read)   (EFSDir *dir);
	gint         (*erase)      (EFSDir *dir, const char *path);
	gint         (*rename)     (EFSDir *dir, const char *old_path, 
				    const char *new_path);
	EFSFileOps  *base;
};
</STRUCT>
<STRUCT>
<NAME>EFSDriver</NAME>
struct EFSDriver {
	const gchar *drivername;
	guint        blocksize;
	EFSSuperOps *sops;
	EFSINodeOps *iops;
	EFSFileOps  *fops;
};
</STRUCT>
<STRUCT>
<NAME>EFSHeader</NAME>
typedef struct {
	gchar   efs_id[4];
	gchar   drivername[12];
} EFSHeader;
</STRUCT>
<STRUCT>
<NAME>EFS</NAME>
struct EFS {
	gint           fd;
	guint32        mode;
	EFSDriver     *driver;
	gpointer       pdata;
	EFSCacheEntry  cache[EFS_CACHE_SIZE];
	GList         *inode_list;
};
</STRUCT>
<VARIABLE>
<NAME>efs_driver_simple</NAME>
extern EFSDriver   efs_driver_simple;
</VARIABLE>
<VARIABLE>
<NAME>efs_driver_fsys</NAME>
extern EFSDriver   efs_driver_fsys;
</VARIABLE>
<FUNCTION>
<NAME>efs_inode_create</NAME>
<RETURNS>guint32  </RETURNS>
EFS *efs
</FUNCTION>
<FUNCTION>
<NAME>efs_inode_erase</NAME>
<RETURNS>gint  </RETURNS>
EFS *efs, guint32 inode
</FUNCTION>
<FUNCTION>
<NAME>efs_inode_trunc</NAME>
<RETURNS>gint  </RETURNS>
EFS *efs, guint32 inode, guint32 block
</FUNCTION>
<FUNCTION>
<NAME>efs_inode_map</NAME>
<RETURNS>EFSCacheEntry *</RETURNS>
EFS *efs, guint32 inode
</FUNCTION>
<FUNCTION>
<NAME>efs_inode_bmap</NAME>
<RETURNS>EFSCacheEntry *</RETURNS>
EFS *efs, guint32 inode, guint32 block
</FUNCTION>
<FUNCTION>
<NAME>efs_inode_ref</NAME>
<RETURNS>gint  </RETURNS>
EFS *efs, guint32 inode
</FUNCTION>
<FUNCTION>
<NAME>efs_inode_unref</NAME>
<RETURNS>gint  </RETURNS>
EFS *efs, guint32 inode
</FUNCTION>
<FUNCTION>
<NAME>efs_inode_refcount</NAME>
<RETURNS>gint  </RETURNS>
EFS *efs, guint32 inode
</FUNCTION>
<FUNCTION>
<NAME>efs_map</NAME>
<RETURNS>gint  </RETURNS>
EFS *efs, EFSCacheEntry *ce, guint32 block
</FUNCTION>
<FUNCTION>
<NAME>efs_unmap</NAME>
<RETURNS>gint  </RETURNS>
EFS *efs, EFSCacheEntry *ce
</FUNCTION>
<FUNCTION>
<NAME>efs_cache_map</NAME>
<RETURNS>EFSCacheEntry  *</RETURNS>
EFS *efs, guint32 block, guint32 ref_block,guint32 ref_pos, gboolean noread
</FUNCTION>
<FUNCTION>
<NAME>efs_cache_flush</NAME>
<RETURNS>void  </RETURNS>
EFS *efs
</FUNCTION>
<FUNCTION>
<NAME>efs_cache_touch</NAME>
<RETURNS>void  </RETURNS>
EFSCacheEntry *ce, gboolean dirty
</FUNCTION>
<FUNCTION>
<NAME>idl_browser_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>idl_browser_new_with_filenames</NAME>
<RETURNS>GtkWidget *</RETURNS>
int argc, char *argv[]
</FUNCTION>
<FUNCTION>
<NAME>nameservice_browser_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>object_browser_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>object_browser_register_new_object</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>TREECTRL_HEIGHT</NAME>
#define TREECTRL_HEIGHT 300
</MACRO>
<MACRO>
<NAME>TREECTRL_WIDTH</NAME>
#define TREECTRL_WIDTH 350
</MACRO>
<MACRO>
<NAME>USE_ANTIALIASING</NAME>
#define USE_ANTIALIASING
</MACRO>
<FUNCTION>
<NAME>message_box</NAME>
<RETURNS>void  </RETURNS>
gchar *format, ...
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_new_with_label_and_pixmap</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkWidget* window,gchar* label,gchar* stock_pixmap
</FUNCTION>
<FUNCTION>
<NAME>contains_non_whitespace</NAME>
<RETURNS>gboolean  </RETURNS>
gchar *str
</FUNCTION>
<FUNCTION>
<NAME>remove_leading_and_trailing_whitespace</NAME>
<RETURNS>gchar *</RETURNS>
gchar *str
</FUNCTION>
<FUNCTION>
<NAME>contains_whitespace</NAME>
<RETURNS>gboolean  </RETURNS>
gchar *str
</FUNCTION>
<FUNCTION>
<NAME>convert_to_alphanumeric</NAME>
<RETURNS>void  </RETURNS>
gchar *str
</FUNCTION>
<TYPEDEF>
<NAME>uuid_t[16]</NAME>
typedef unsigned char uuid_t[16];
</TYPEDEF>
<FUNCTION>
<NAME>uuid_clear</NAME>
<RETURNS>void  </RETURNS>
uuid_t uu
</FUNCTION>
<FUNCTION>
<NAME>uuid_compare</NAME>
<RETURNS>int  </RETURNS>
uuid_t uu1, uuid_t uu2
</FUNCTION>
<FUNCTION>
<NAME>uuid_copy</NAME>
<RETURNS>void  </RETURNS>
uuid_t uu1, uuid_t uu2
</FUNCTION>
<FUNCTION>
<NAME>uuid_generate</NAME>
<RETURNS>void  </RETURNS>
uuid_t out
</FUNCTION>
<FUNCTION>
<NAME>uuid_is_null</NAME>
<RETURNS>int  </RETURNS>
uuid_t uu
</FUNCTION>
<FUNCTION>
<NAME>uuid_parse</NAME>
<RETURNS>int  </RETURNS>
char *in, uuid_t uu
</FUNCTION>
<FUNCTION>
<NAME>uuid_unparse</NAME>
<RETURNS>void  </RETURNS>
uuid_t uu, char *out
</FUNCTION>
<MACRO>
<NAME>TIME_OFFSET_HIGH</NAME>
#define TIME_OFFSET_HIGH 0x01B21DD2
</MACRO>
<MACRO>
<NAME>TIME_OFFSET_LOW</NAME>
#define TIME_OFFSET_LOW  0x13814000
</MACRO>
<FUNCTION>
<NAME>uuid_pack</NAME>
<RETURNS>void  </RETURNS>
struct uuid *uu, uuid_t ptr
</FUNCTION>
<FUNCTION>
<NAME>uuid_unpack</NAME>
<RETURNS>void  </RETURNS>
uuid_t in, struct uuid *uu
</FUNCTION>
<STRUCT>
<NAME>embeddable_data_t</NAME>
typedef struct {
  BonoboEmbeddable *embeddable;

  gchar *sound;
  guint sound_len;
  
  gint update_callback_id;  
} embeddable_data_t;
</STRUCT>
<STRUCT>
<NAME>view_data_t</NAME>
typedef struct {
	embeddable_data_t *embeddable_data;
	
	GtkWidget        *canvas;
	GtkWidget        *vbox;
	GtkWidget        *hscroll;
	GnomeCanvasItem  *canvas_item;
} view_data_t;
</STRUCT>
<FUNCTION>
<NAME>color_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>color_alloc</NAME>
<RETURNS>int  </RETURNS>
gushort red, gushort green, gushort blue
</FUNCTION>
<FUNCTION>
<NAME>color_alloc_name</NAME>
<RETURNS>void  </RETURNS>
const char *name, GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>color_alloc_gdk</NAME>
<RETURNS>void  </RETURNS>
GdkColor *color
</FUNCTION>
<MACRO>
<NAME>ITEM_TYPE_AUDIO</NAME>
#define ITEM_TYPE_AUDIO			(item_audio_get_type ())
</MACRO>
<MACRO>
<NAME>ITEM_AUDIO</NAME>
#define ITEM_AUDIO(obj)			(GTK_CHECK_CAST ((obj), ITEM_TYPE_AUDIO, ItemAudio))
</MACRO>
<MACRO>
<NAME>ITEM_AUDIO_CLASS</NAME>
#define ITEM_AUDIO_CLASS(klass)		(GTK_CHECK_CLASS_CAST ((klass), ITEM_TYPE_AUDIO, ItemAudioClass))
</MACRO>
<MACRO>
<NAME>ITEM_IS_AUDIO</NAME>
#define ITEM_IS_AUDIO(obj)			(GTK_CHECK_TYPE ((obj), ITEM_TYPE_AUDIO))
</MACRO>
<MACRO>
<NAME>ITEM_IS_AUDIO_CLASS</NAME>
#define ITEM_IS_AUDIO_CLASS(klass)		(GTK_CHECK_CLASS_TYPE ((obj), ITEM_TYPE_AUDIO))
</MACRO>
<STRUCT>
<NAME>ItemAudio</NAME>
</STRUCT>
<STRUCT>
<NAME>ItemAudioClass</NAME>
</STRUCT>
<STRUCT>
<NAME>ItemAudio</NAME>
struct ItemAudio
{
  GnomeCanvasItem parent;

  /* Put your own, widget-specific fields here */
  embeddable_data_t *embeddable_data;
  double height;
  GdkGC *gc;			/* GC for drawing points */
  GdkGC *bg_gc;
  
  GdkColor   background;
  GdkColor   foreground;
};
</STRUCT>
<STRUCT>
<NAME>ItemAudioClass</NAME>
struct ItemAudioClass
{
  GnomeCanvasItemClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>item_audio_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_MINEFIELD</NAME>
#define GTK_MINEFIELD(obj) GTK_CHECK_CAST(obj, gtk_minefield_get_type(), GtkMineFieldView)
</MACRO>
<MACRO>
<NAME>GTK_MINEFIELD_CLASS</NAME>
#define GTK_MINEFIELD_CLASS(klass) GTK_CHECK_CLASS_CAST(klass, gtk_minefield_get_type(), GtkMineFieldViewClass);
</MACRO>
<MACRO>
<NAME>GTK_IS_MINEFIELD</NAME>
#define GTK_IS_MINEFIELD(obj) GTK_CHECK_TYPE(obj, gtk_minefield_get_type())
</MACRO>
<STRUCT>
<NAME>MineField</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkMineFieldView</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkMineFieldViewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>Mine</NAME>
struct Mine {
	guint mined:1;
	guint shown:1;
	guint marked:1;
	guint down:1;
        guint neighbours;
};
</STRUCT>
<STRUCT>
<NAME>Sign</NAME>
struct Sign {
	GdkPixmap *pixmap;
	GdkBitmap *mask;
	
        gint width;
        gint height;
};
</STRUCT>
<STRUCT>
<NAME>MineField</NAME>
struct MineField {
/* List of minefield widgets */
	GList     *views;

        guint      xsize;
	guint      ysize;
        guint      mcount;
	mine      *mines;
	guint      flags;
	guint      shown;
        gint       lose;
        gint       win;
};
</STRUCT>
<STRUCT>
<NAME>GtkMineFieldView</NAME>
struct GtkMineFieldView {
        GtkWidget  widget;
	MineField *data;

	gint       cdown;
        guint      cdownx;
        guint      cdowny;
	gint       bdown[3];
	gint       multi_mode;
	guint      minesize;
        GdkFont         *font;
	GdkColorContext *cc;
        sign             flag;
        sign             mine;
	struct {
		char text[2];
		gint dx, dy;
		GdkGC *gc;
	} numstr[9];
};
</STRUCT>
<FUNCTION>
<NAME>minefield_new</NAME>
<RETURNS>MineField  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>minefield_destroy</NAME>
<RETURNS>void  </RETURNS>
MineField *data
</FUNCTION>
<FUNCTION>
<NAME>minefield_set_size</NAME>
<RETURNS>void  </RETURNS>
MineField *data,guint xsize, guint ysize
</FUNCTION>
<FUNCTION>
<NAME>minefield_set_mines</NAME>
<RETURNS>void  </RETURNS>
MineField *data, guint mcount
</FUNCTION>
<FUNCTION>
<NAME>minefield_restart</NAME>
<RETURNS>void  </RETURNS>
MineField *data
</FUNCTION>
<FUNCTION>
<NAME>minefield_set_at</NAME>
<RETURNS>void  </RETURNS>
MineField *data, int x, int y,char num, char state
</FUNCTION>
<FUNCTION>
<NAME>minefield_get_at</NAME>
<RETURNS>void  </RETURNS>
MineField *data, int x, int y,char *num, char *state
</FUNCTION>
<FUNCTION>
<NAME>gtk_minefield_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_minefield_new_view</NAME>
<RETURNS>GtkWidget  *</RETURNS>
MineField *data
</FUNCTION>
<FUNCTION>
<NAME>gtk_minefield_set_minesize</NAME>
<RETURNS>void  </RETURNS>
GtkMineFieldView *data,guint minesize
</FUNCTION>
<STRUCT>
<NAME>Hello</NAME>
typedef struct {
	BonoboEmbeddable *bonobo_object;

	gchar *text;
} Hello;
</STRUCT>
<FUNCTION>
<NAME>hello_model_init</NAME>
<RETURNS>void  </RETURNS>
Hello * hello, BonoboEmbeddable * bonobo_object
</FUNCTION>
<FUNCTION>
<NAME>hello_model_set_text</NAME>
<RETURNS>void  </RETURNS>
Hello * hello, gchar * text
</FUNCTION>
<FUNCTION>
<NAME>hello_model_clear</NAME>
<RETURNS>void  </RETURNS>
Hello * hello
</FUNCTION>
<FUNCTION>
<NAME>hello_model_destroy</NAME>
<RETURNS>void  </RETURNS>
Hello * obj
</FUNCTION>
<FUNCTION>
<NAME>hello_object_pstream_load</NAME>
<RETURNS>void  </RETURNS>
BonoboPersistStream * ps,const Bonobo_Stream stream,Bonobo_Persist_ContentType type,void *data, CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>hello_object_pstream_save</NAME>
<RETURNS>void  </RETURNS>
BonoboPersistStream * ps,const Bonobo_Stream stream,Bonobo_Persist_ContentType type,void *data, CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>hello_object_pstream_get_max_size</NAME>
<RETURNS>CORBA_long  </RETURNS>
BonoboPersistStream *ps,void *data,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>hello_object_pstream_get_types</NAME>
<RETURNS>Bonobo_Persist_ContentTypeList  *</RETURNS>
BonoboPersistStream *ps,void *closure,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>hello_object_print</NAME>
<RETURNS>void</RETURNS>
GnomePrintContext * ctx,double width,double height,const Bonobo_PrintScissor * scissor,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>hello_object_factory</NAME>
<RETURNS>BonoboObject  *</RETURNS>
BonoboEmbeddableFactory * this,void *data
</FUNCTION>
<STRUCT>
<NAME>HelloView</NAME>
typedef struct {
	BonoboView *view;
	Hello *obj;

	GtkWidget *label;
	GtkWidget *widget;
} HelloView;
</STRUCT>
<FUNCTION>
<NAME>hello_view_factory</NAME>
<RETURNS>BonoboView  *</RETURNS>
BonoboEmbeddable * bonobo_object,const Bonobo_ViewFrame view_frame,void *data
</FUNCTION>
<FUNCTION>
<NAME>hello_view_refresh</NAME>
<RETURNS>void  </RETURNS>
HelloView * view
</FUNCTION>
<FUNCTION>
<NAME>component_load</NAME>
<RETURNS>void  </RETURNS>
Component * component, Bonobo_Stream stream
</FUNCTION>
<FUNCTION>
<NAME>component_save</NAME>
<RETURNS>void  </RETURNS>
Component * component, Bonobo_Stream stream
</FUNCTION>
<FUNCTION>
<NAME>component_save_id</NAME>
<RETURNS>void  </RETURNS>
Component * component, Bonobo_Stream stream
</FUNCTION>
<STRUCT>
<NAME>Component</NAME>
struct Component {
	SampleApp *container;

	BonoboClientSite *client_site;
	BonoboObjectClient *server;
	gchar *goad_id;

	GtkWidget *widget;
	GtkWidget *views_hbox;
	GList *views;
};
</STRUCT>
<FUNCTION>
<NAME>component_add_view</NAME>
<RETURNS>void  </RETURNS>
Component * component
</FUNCTION>
<FUNCTION>
<NAME>component_del_view</NAME>
<RETURNS>void  </RETURNS>
Component * component
</FUNCTION>
<FUNCTION>
<NAME>component_del</NAME>
<RETURNS>void  </RETURNS>
Component * component
</FUNCTION>
<FUNCTION>
<NAME>component_print</NAME>
<RETURNS>void  </RETURNS>
Component * component, GnomePrintContext * ctx,gdouble x, gdouble y, gdouble width, gdouble height
</FUNCTION>
<FUNCTION>
<NAME>component_create_frame</NAME>
<RETURNS>GtkWidget  *</RETURNS>
Component * component, gchar * goad_id
</FUNCTION>
<FUNCTION>
<NAME>container_request_file</NAME>
<RETURNS>void  </RETURNS>
SampleApp * app,gboolean save,GtkSignalFunc cb, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>sample_container_load</NAME>
<RETURNS>void  </RETURNS>
SampleApp * inst, const gchar * filename
</FUNCTION>
<FUNCTION>
<NAME>sample_container_save</NAME>
<RETURNS>void  </RETURNS>
SampleApp * inst, const gchar * filename
</FUNCTION>
<FUNCTION>
<NAME>sample_app_fill_menu</NAME>
<RETURNS>void  </RETURNS>
SampleApp * app
</FUNCTION>
<FUNCTION>
<NAME>sample_app_print_preview</NAME>
<RETURNS>void  </RETURNS>
SampleApp * app
</FUNCTION>
<MACRO>
<NAME>GUI</NAME>
#define GUI 1
</MACRO>
<MACRO>
<NAME>FILE</NAME>
#define FILE "/tmp/foo"
</MACRO>
<MACRO>
<NAME>OBJ_ID</NAME>
#define OBJ_ID "OAFIID:bonobo-sample:" VERSION
</MACRO>
<MACRO>
<NAME>OBJ_ID</NAME>
#define OBJ_ID "bonobo-object:sample"
</MACRO>
<STRUCT>
<NAME>SampleApp</NAME>
</STRUCT>
<STRUCT>
<NAME>Component</NAME>
</STRUCT>
<STRUCT>
<NAME>SampleApp</NAME>
struct SampleApp {
	BonoboContainer *container;
	BonoboUIHandler *ui_handler;

	BonoboViewFrame *curr_view;
	GList *components;

	GtkWidget *app;
	GtkWidget *box;
	GtkWidget *fileselection;
};
</STRUCT>
<FUNCTION>
<NAME>sample_app_add_component</NAME>
<RETURNS>Component  *</RETURNS>
SampleApp * app, gchar * goad_id
</FUNCTION>
<FUNCTION>
<NAME>sample_app_remove_component</NAME>
<RETURNS>void  </RETURNS>
SampleApp * app, Component * component
</FUNCTION>
<FUNCTION>
<NAME>sample_app_exit</NAME>
<RETURNS>void  </RETURNS>
SampleApp * app
</FUNCTION>
<STRUCT>
<NAME>Hello</NAME>
typedef struct {
	BonoboEmbeddable *bonobo_object;

	gchar *text;
} Hello;
</STRUCT>
<FUNCTION>
<NAME>hello_model_init</NAME>
<RETURNS>void  </RETURNS>
Hello * hello, BonoboEmbeddable * bonobo_object
</FUNCTION>
<FUNCTION>
<NAME>hello_model_set_text</NAME>
<RETURNS>void  </RETURNS>
Hello * hello, gchar * text
</FUNCTION>
<FUNCTION>
<NAME>hello_model_clear</NAME>
<RETURNS>void  </RETURNS>
Hello * hello
</FUNCTION>
<FUNCTION>
<NAME>hello_model_destroy</NAME>
<RETURNS>void  </RETURNS>
Hello * obj
</FUNCTION>
<FUNCTION>
<NAME>hello_object_pstream_load</NAME>
<RETURNS>int  </RETURNS>
BonoboPersistStream * ps,Bonobo_Stream stream, void *data
</FUNCTION>
<FUNCTION>
<NAME>hello_object_pstream_save</NAME>
<RETURNS>int  </RETURNS>
BonoboPersistStream * ps,Bonobo_Stream stream, void *data
</FUNCTION>
<FUNCTION>
<NAME>hello_object_print</NAME>
<RETURNS>void</RETURNS>
GnomePrintContext * ctx,double width,double height,const Bonobo_PrintScissor * scissor,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>hello_object_factory</NAME>
<RETURNS>BonoboObject  *</RETURNS>
BonoboEmbeddableFactory * this,void *data
</FUNCTION>
<STRUCT>
<NAME>HelloView</NAME>
typedef struct {
	BonoboView *view;
	Hello *obj;

	GtkWidget *label;
	GtkWidget *widget;
} HelloView;
</STRUCT>
<FUNCTION>
<NAME>hello_view_factory</NAME>
<RETURNS>BonoboView  *</RETURNS>
BonoboEmbeddable * bonobo_object,const Bonobo_ViewFrame view_frame,void *data
</FUNCTION>
<FUNCTION>
<NAME>hello_view_refresh</NAME>
<RETURNS>void  </RETURNS>
HelloView * view
</FUNCTION>
<FUNCTION>
<NAME>component_load</NAME>
<RETURNS>void  </RETURNS>
Component * component, Bonobo_Stream stream
</FUNCTION>
<FUNCTION>
<NAME>component_save</NAME>
<RETURNS>void  </RETURNS>
Component * component, Bonobo_Stream stream
</FUNCTION>
<FUNCTION>
<NAME>component_save_id</NAME>
<RETURNS>void  </RETURNS>
Component * component, Bonobo_Stream stream
</FUNCTION>
<STRUCT>
<NAME>Component</NAME>
struct Component {
	SampleApp *container;

	BonoboClientSite *client_site;
	BonoboObjectClient *server;
	gchar *goad_id;

	GtkWidget *widget;
	GtkWidget *views_hbox;
	GList *views;
};
</STRUCT>
<FUNCTION>
<NAME>component_add_view</NAME>
<RETURNS>void  </RETURNS>
Component * component
</FUNCTION>
<FUNCTION>
<NAME>component_del_view</NAME>
<RETURNS>void  </RETURNS>
Component * component
</FUNCTION>
<FUNCTION>
<NAME>component_del</NAME>
<RETURNS>void  </RETURNS>
Component * component
</FUNCTION>
<FUNCTION>
<NAME>component_print</NAME>
<RETURNS>void  </RETURNS>
Component * component, GnomePrintContext * ctx,gdouble x, gdouble y, gdouble width, gdouble height
</FUNCTION>
<FUNCTION>
<NAME>component_create_frame</NAME>
<RETURNS>GtkWidget  *</RETURNS>
Component * component, gchar * goad_id
</FUNCTION>
<FUNCTION>
<NAME>container_request_file</NAME>
<RETURNS>void  </RETURNS>
SampleApp * app,gboolean save,GtkSignalFunc cb, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>sample_container_load</NAME>
<RETURNS>void  </RETURNS>
SampleApp * inst, const gchar * filename
</FUNCTION>
<FUNCTION>
<NAME>sample_container_save</NAME>
<RETURNS>void  </RETURNS>
SampleApp * inst, const gchar * filename
</FUNCTION>
<FUNCTION>
<NAME>sample_app_fill_menu</NAME>
<RETURNS>void  </RETURNS>
SampleApp * app
</FUNCTION>
<FUNCTION>
<NAME>sample_app_print_preview</NAME>
<RETURNS>void  </RETURNS>
SampleApp * app
</FUNCTION>
<MACRO>
<NAME>GUI</NAME>
#define GUI 1
</MACRO>
<MACRO>
<NAME>FILE</NAME>
#define FILE "/tmp/foo"
</MACRO>
<MACRO>
<NAME>OBJ_ID</NAME>
#define OBJ_ID "OAFIID:bonobo-sample:" VERSION
</MACRO>
<MACRO>
<NAME>OBJ_ID</NAME>
#define OBJ_ID "bonobo-object:sample"
</MACRO>
<STRUCT>
<NAME>SampleApp</NAME>
</STRUCT>
<STRUCT>
<NAME>Component</NAME>
</STRUCT>
<STRUCT>
<NAME>SampleApp</NAME>
struct SampleApp {
	BonoboContainer *container;
	BonoboUIHandler *ui_handler;

	BonoboViewFrame *curr_view;
	GList *components;

	GtkWidget *app;
	GtkWidget *box;
	GtkWidget *fileselection;
};
</STRUCT>
<FUNCTION>
<NAME>sample_app_add_component</NAME>
<RETURNS>Component  *</RETURNS>
SampleApp * app, gchar * goad_id
</FUNCTION>
<FUNCTION>
<NAME>sample_app_remove_component</NAME>
<RETURNS>void  </RETURNS>
SampleApp * app, Component * component
</FUNCTION>
<FUNCTION>
<NAME>sample_app_exit</NAME>
<RETURNS>void  </RETURNS>
SampleApp * app
</FUNCTION>
<FUNCTION>
<NAME>bonobo_calculator_factory_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_clock_factory_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ECHO_TYPE</NAME>
#define ECHO_TYPE        (echo_get_type ())
</MACRO>
<MACRO>
<NAME>ECHO</NAME>
#define ECHO(o)          (GTK_CHECK_CAST ((o), ECHO_TYPE, Echo))
</MACRO>
<MACRO>
<NAME>ECHO_CLASS</NAME>
#define ECHO_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), ECHO_TYPE, EchoClass))
</MACRO>
<MACRO>
<NAME>IS_ECHO</NAME>
#define IS_ECHO(o)       (GTK_CHECK_TYPE ((o), ECHO_TYPE))
</MACRO>
<MACRO>
<NAME>IS_ECHO_CLASS</NAME>
#define IS_ECHO_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), ECHO_TYPE))
</MACRO>
<STRUCT>
<NAME>Echo</NAME>
typedef struct {
	BonoboObject parent;

	char *instance_data;
} Echo;
</STRUCT>
<STRUCT>
<NAME>EchoClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;
} EchoClass;
</STRUCT>
<FUNCTION>
<NAME>echo_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>echo_construct</NAME>
<RETURNS>Echo       	   *</RETURNS>
Echo *echo, Demo_Echo corba_echo
</FUNCTION>
<FUNCTION>
<NAME>echo_new</NAME>
<RETURNS>Echo       	   *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>echo_get_epv</NAME>
<RETURNS>POA_Demo_Echo__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ORBIT_IDL_SERIAL</NAME>
#define ORBIT_IDL_SERIAL 9
</MACRO>
<MACRO>
<NAME>Echo_H</NAME>
#define Echo_H 1
</MACRO>
<MACRO>
<NAME>ORBIT_DECL_Demo_Echo</NAME>
#define ORBIT_DECL_Demo_Echo 1
</MACRO>
<MACRO>
<NAME>Demo_Echo__free</NAME>
#define Demo_Echo__free CORBA_Object__free
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_Demo_Echo_0</NAME>
#define TC_IMPL_TC_Demo_Echo_0 'E'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_Demo_Echo_1</NAME>
#define TC_IMPL_TC_Demo_Echo_1 'c'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_Demo_Echo_2</NAME>
#define TC_IMPL_TC_Demo_Echo_2 'h'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_Demo_Echo_3</NAME>
#define TC_IMPL_TC_Demo_Echo_3 'o'
</MACRO>
<MACRO>
<NAME>TC_Demo_Echo</NAME>
#define TC_Demo_Echo ((CORBA_TypeCode)&TC_Demo_Echo_struct)
</MACRO>
<FUNCTION>
<NAME>POA_Demo_Echo__init</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>POA_Demo_Echo__fini</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant,CORBA_Environment * ev
</FUNCTION>
<MACRO>
<NAME>Demo_Echo_ref</NAME>
#define Demo_Echo_ref Bonobo_Unknown_ref
</MACRO>
<MACRO>
<NAME>Demo_Echo_unref</NAME>
#define Demo_Echo_unref Bonobo_Unknown_unref
</MACRO>
<MACRO>
<NAME>Demo_Echo_query_interface</NAME>
#define Demo_Echo_query_interface Bonobo_Unknown_query_interface
</MACRO>
<FUNCTION>
<NAME>Demo_Echo_echo</NAME>
<RETURNS>void  </RETURNS>
Demo_Echo _obj, const CORBA_char * message,CORBA_Environment * ev
</FUNCTION>
