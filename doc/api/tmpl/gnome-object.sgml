<!-- ##### SECTION Title ##### -->
GnomeObject

<!-- ##### SECTION Short_Description ##### -->
Base object for wrapping GNOME::Unknown derived objects.

<!-- ##### SECTION Long_Description ##### -->
<para>
  GnomeObject is the base object in Bonobo for wrapping CORBA servers
  as Gtk+ objects.  
</para>

<para>
  The <classname>GNOME::Unknown</classname> interface (wrapped by
  GnomeObject) is the foundation for the component system: it provides
  life cycle management for objects as well as service discovery.
</para>

<para>
  The Bonobo interfaces are all based on the
  <classname>GNOME::Unknown</classname> interface.  This
  interface is very simple and provides two basic services:
  object lifetime management and object
  functionality-discovery.   This interface only contains three
  methods, here it is:

  <programlisting>
  module GNOME {
      interface Unknown {
          void void ref ();
          void void unref ();
          Object query_interface (in string repoid);
      };
  };
  </programlisting>
</para>

<para>
  The <function>ref()</function>. and <function>unref()</function>
  methods are used to control the lifetime of an object.  The
  <function>query_interface</function> method is used to discover
  optional functionality provided by the object implementation.
</para>

<para>
  The lifetime management is based on reference counting: when a
  component is initially launched, it starts life with a reference
  count of one.  This reference is held by the component invoker.
  Each time a reference is kept to this object (say, you store a
  copy of the object in an array), the reference count in
  incremented.  Every time a reference goes out of scope, the
  reference count needs to be decremented.  When the reference
  count reaches zero, the component knows that there are no
  outstanding references to it, and it is safe to shutdown.  At
  this point, the component shuts-down.
</para>

<para>
  It is possible to query an object which implements the
  <classname>GNOME::Unknown</classname> interface if it supports
  other CORBA interfaces.  For example, it would be possible to
  query an object whether it supports the
  "IDL:GNOME/EmbeddablePrint:1.0" interface to find out if it is
  possible to print its contents.  If the return value from
  invoking the <function>query_interface</function> method on the
  interface is CORBA_OBJECT_NIL, then we know that the interface
  is not supported.  Otherwise, we can invoke
  IDL:GNOME/EmbeddablePrint:1.0 methods on the returned CORBA
  Object.
</para>

<para>
  Clients of the <function>query_interface</function> method use
  it to discover dynamically if a component supports a given
  interface.  Sometimes the client code would require a specific
  interface to exist, but many times it is possible to operate in
  a "downgraded" mode.  You should design your code to be able to
  cope with the lack of interfaces in objects.  This will allow
  your program to deal with more components, and this also allows
  components to work in more situations.
</para>

<para>
  For example, a help browser can load an HTML renderer component and
  ask this component which sort of features are supported by it:
  <programlisting>
_animations (BrowserHTML html)

  BrowserControl control

  control = html->query_interface ("IDL:Browser/Control:1.0");
  if (control)
          control->stop_animations ();

  </programlisting>
</para>

<para>
  The return value of the query_interface invocation contains a
  reference to a CORBA object that is derived from the
  <classname>GNOME::Unknown</classname> interface or
  CORBA_OBJECT_NIL if the interface is not supported by the
  object.  And this interface would have been already
  <function>ref()</function>ed before it was returned.  It is up
  to the caller to call <function>unref()</function> when they are
  done using the interface.
</para>

<para>
  GnomeObject implements the GNOME::Unknown interface and exports the
  implementations of the methods in this class to simplify creating
  new objects that inherit from GNOME::Unknown.  This base object
  provides default implementations for the ref, unref and
  query_interface methods.
</para>

<para>
  Other implementations reuse this implementation by listing on their
  VEPV tables the gnome_object_epv vector entry point.
</para>

<para>
  The <classname>GNOME::Unknown</classname> interface is inspired
  by the Microsoft COM <classname>IUnknown</classname> interface
  but it has been translated into the CORBA world.
</para>

<!-- ##### SECTION See_Also ##### -->
<para>
#GtkObject
</para>

<!-- ##### MACRO GNOME_OBJECT_TYPE ##### -->
<para>
Returns the #GtkType for the GnomeObject object.
</para>



<!-- ##### STRUCT GnomeObjectServant ##### -->
<para>
  This structure defines the type for GnomeObject-based CORBA servants.
</para>

<para>
  #GnomeObject provides a mapping from the servant to the #GnomeObject
  by using the gnome_object field in the structure.  Typically in the
  C CORBA binding, per-servant information is piggy-backed to the POA
  servant.  With the GnomeObject setup per-servant information is
  typically attached to the GnomeObject (by using the regular
  inheritance mechanism of Gtk+).  Going from a
  #PortableServer_Servant to the actual #GnomeObject is acomplished by
  using the gnome_object_from_servant() routine.  
</para>

<para>
  If you decide not to use this scheme for fetching your per-servant
  information, but still want to inherit from a #GnomeObject object,
  just make sure that the second field of your servant is a gpointer.
</para>

<!-- ##### STRUCT GnomeObjectPrivate ##### -->
<para>
   Private information kept by the GnomeObject.  This should not be
   used by GnomeObject users.
</para>


<!-- ##### FUNCTION gnome_object_construct ##### -->
<para>

</para>

@object: 
@corba_object: 
@Returns: 


<!-- ##### FUNCTION gnome_object_from_servant ##### -->
<para>

</para>

@servant: 
@Returns: 


<!-- ##### FUNCTION gnome_object_bind_to_servant ##### -->
<para>

</para>

@object: 
@servant: 


<!-- ##### FUNCTION gnome_object_get_servant ##### -->
<para>

</para>

@object: 
@Returns: 


<!-- ##### FUNCTION gnome_object_activate_servant ##### -->
<para>

</para>

@object: 
@servant: 
@Returns: 


<!-- ##### FUNCTION gnome_object_add_interface ##### -->
<para>

</para>

@object: 
@newobj: 


<!-- ##### FUNCTION gnome_object_query_interface ##### -->
<para>

</para>

@object: 
@repo_id: 
@Returns: 


<!-- ##### FUNCTION gnome_object_corba_objref ##### -->
<para>

</para>

@object: 
@Returns: 


<!-- ##### FUNCTION gnome_object_ref ##### -->
<para>

</para>

@object: 


<!-- ##### FUNCTION gnome_object_unref ##### -->
<para>

</para>

@object: 


<!-- ##### FUNCTION gnome_object_destroy ##### -->
<para>

</para>

@object: 


<!-- ##### FUNCTION gnome_object_check_env ##### -->
<para>

</para>

@object: 
@corba_object: 
@ev: 


<!-- ##### MACRO GNOME_OBJECT_CHECK ##### -->
<para>
   Checks if the exception in @e needs to be signaled.  If so, then
   the proper exception signal is generated on the GnomeObject object
   @o for the CORBA reference @c.
</para>

@o: 
@c: 
@e: 


<!-- ##### MACRO GNOME_OBJECT_EV ##### -->
<para>
   Fetches the <structname>CORBA_Environment</structname> field of a
   <classname>GnomeObject</classname>.
</para>

@o: 


<!-- ##### FUNCTION gnome_unknown_ping ##### -->
<para>

</para>

@object: 
@Returns: 


<!-- ##### VARIABLE gnome_object_base_epv ##### -->
<para>
   This is the CORBA Entry Point Vector (EPV) of the base GnomeObject
   that provides the implementaion for the GNOME::Unknown interface.
   Use this to construct your CORBA VEPV when deriving objects from
   GnomeObject.
</para>

<!-- ##### VARIABLE gnome_object_epv ##### -->
<para>
   This is the CORBA Entry Point Vector (EPV) of GnomeObject that
   provides the implementaion for the GNOME::Unknown interface.  Use
   this to construct your CORBA VEPV when deriving objects from
   GnomeObject.
</para>

<para>
   All Bonobo CORBA servers expose their epv vectors to enable
   programmers to fill in their CORBA VEPVs for any piece of code that
   wants to inherit the implementation.
</para>

<!-- ##### VARIABLE gnome_object_vepv ##### -->
<para>
<para>
   This is the CORBA Vector of EPVs (VEPV) of GnomeObject that
   provides the implementaion for the GNOME::Unknown interface.
</para>


