#include "config.h"
#include <gnome.h>
#include <bonobo.h>
#include <liboaf/liboaf.h>

#include "Bonobo.h"
#include "bonobo-ui-xml.h"
#include "bonobo-ui-util.h"
#include "bonobo-app.h"
#include "bonobo-app-item.h"
#include "bonobo-app-toolbar.h"

GtkObjectClass *bonobo_app_parent_class = NULL;

POA_Bonobo_UIContainer__vepv bonobo_app_vepv;

struct _BonoboAppPrivate {
	GtkWidget     *window;
	GnomeDock     *dock;

	GnomeDockItem *menu_item;
	GtkMenuBar    *menu;

	GnomeDockItem *status_item;
	GtkBox        *status;

	BonoboUIXml   *tree;

	GtkAccelGroup *accel_group;

	char          *name;		/* App name */
	char          *prefix;		/* App prefix */

	GHashTable    *radio_groups;
};

static inline BonoboApp *
bonobo_app_from_servant (PortableServer_Servant servant)
{
	return BONOBO_APP (bonobo_object_from_servant (servant));
}

typedef struct {
	BonoboUIXmlData parent;

	GtkWidget      *widget;
	Bonobo_Unknown  object;
} NodeInfo;

static gboolean
info_compare_fn (gpointer id_a, gpointer id_b)
{
	gboolean same;
	CORBA_Environment ev;

	if (!id_a && !id_b) /* Generated by auto path creation */
		return TRUE;

	if (!id_a || !id_b)
		return FALSE;

	CORBA_exception_init (&ev);
	same = CORBA_Object_is_equivalent (id_a, id_b, &ev);
	CORBA_exception_free (&ev);

	return same;
}

static void
info_override_fn (BonoboUIXmlData *a)
{
	((NodeInfo *)a)->widget = NULL;
}

static void
info_reinstate_fn (BonoboUIXmlData *a)
{
	g_assert (((NodeInfo *)a)->widget == NULL);
}

static void
info_dump_fn (BonoboUIXmlData *a)
{
	fprintf (stderr, " widget %p\n", ((NodeInfo *)a)->widget);
}

static BonoboUIXmlData *
info_new_fn (void)
{
	NodeInfo *info = g_new0 (NodeInfo, 1);

	info->object = CORBA_OBJECT_NIL;

	return (BonoboUIXmlData *) info;
}

static void
info_free_fn (BonoboUIXmlData *data)
{
	NodeInfo *info = (NodeInfo *) data;

	if (info->object != CORBA_OBJECT_NIL) {
		bonobo_object_release_unref (info->object, NULL);
		info->object = CORBA_OBJECT_NIL;
	}
	info->widget = NULL;

	g_free (data);
}

static GtkWidget *
node_get_widget (BonoboUIXml *tree, xmlNode *node)
{
	NodeInfo *info;

	if (!node)
		return NULL;

	info = bonobo_ui_xml_get_data (tree, node);

	return info->widget;
}

static void
override_fn (GtkObject *object, xmlNode *node, gpointer dummy)
{
	char *str = bonobo_ui_xml_make_path (node);

	fprintf (stderr, "Override '%s'\n", str);
	g_free (str);
}

static void
reinstate_fn (GtkObject *object, xmlNode *node, gpointer dummy)
{
	char *str = bonobo_ui_xml_make_path (node);

	fprintf (stderr, "Reinstate '%s'\n", str);
	g_free (str);
}

/*
 * Doesn't the GtkRadioMenuItem API suck badly !
 */
#define MAGIC_RADIO_KEY "Bonobo::RadioGroupName"

static void
radio_group_remove (GtkRadioMenuItem *menuitem,
		    char             *group_name)
{
	GtkRadioMenuItem *master;
	char             *orig_key;
	GSList           *l;
	BonoboAppPrivate *priv =
		gtk_object_get_data (GTK_OBJECT (menuitem), MAGIC_RADIO_KEY);

	if (!g_hash_table_lookup_extended
	    (priv->radio_groups, group_name, (gpointer *)&orig_key,
	     (gpointer *)&master)) {
		g_warning ("Radio group hash inconsistancy");
		return;
	}
	
	l = master->group;
	while (l && l->data == menuitem)
		l = l->next;
	
	g_hash_table_remove (priv->radio_groups, group_name);
	g_free (orig_key);

	if (l) { /* Entries left in group */
		g_hash_table_insert (priv->radio_groups,
				     group_name, l->data);
	} else /* alloced in signal_connect; grim hey */
		g_free (group_name);
}

static void
radio_group_add (BonoboAppPrivate *priv,
		 GtkRadioMenuItem *menuitem,
		 const char       *group_name)
{
	GtkRadioMenuItem *master;

	g_return_if_fail (priv != NULL);
	g_return_if_fail (menuitem != NULL);
	g_return_if_fail (group_name != NULL);

	if (!(master = g_hash_table_lookup (priv->radio_groups, group_name)))
		g_hash_table_insert (priv->radio_groups, g_strdup (group_name),
				     menuitem);
	else
		gtk_radio_menu_item_set_group (
			menuitem, gtk_radio_menu_item_group (master));

	gtk_object_set_data (GTK_OBJECT (menuitem), MAGIC_RADIO_KEY, priv);

	gtk_signal_connect (GTK_OBJECT (menuitem), "destroy",
			    (GtkSignalFunc) radio_group_remove,
			    g_strdup (group_name));
}

/**
 *  The widget / container sweep is neccessary since info->widget is a 'submenu' for
 * menu construction, and yet the GtkMenuItem needs to be destroyed which is
 * stored in the container.
 **/
static void
container_destroy_siblings (BonoboUIXml *tree, GtkWidget *widget, xmlNode *node)
{
	xmlNode *l;

	for (l = node; l; l = l->next) {
		NodeInfo *info;

		info = bonobo_ui_xml_get_data (tree, node);

		container_destroy_siblings (tree, info->widget, node->childs);

		if (info->widget)
			gtk_widget_destroy (info->widget);
		/* else freshly merged and no widget yet */
		info->widget = NULL;
	}

	if (GTK_IS_CONTAINER (widget))
		gtk_container_foreach (GTK_CONTAINER (widget),
				       (GtkCallback) gtk_widget_destroy,
				       NULL);
}

static gint
emit_verb (GtkWidget *item, xmlNode *node)
{
	BonoboUIXmlData *data;
	CORBA_char      *verb;

	g_return_val_if_fail (node != NULL, FALSE);

	data = bonobo_ui_xml_get_data (NULL, node);
	g_return_val_if_fail (data != NULL, FALSE);

	verb = xmlGetProp (node, "verb");
	if (!verb) {
		g_warning ("No verb on '%s' '%s'",
			   node->name, xmlGetProp (node, "name"));
		return FALSE;
	}

	if (data->id != CORBA_OBJECT_NIL) {
		CORBA_Environment ev;

		CORBA_exception_init (&ev);

		Bonobo_UIComponent_exec_verb (data->id, verb, &ev);

		if (ev._major != CORBA_NO_EXCEPTION) {
			/* FIXME: so if it is a sys exception do we de-merge ? */
			g_warning ("Exception executing verb '%s'", verb);
		}
		
		CORBA_exception_free (&ev);
	} else
		g_warning ("NULL Corba handle on '%s':'%s'",
			   node->name, xmlGetProp (node, "name"));

	return FALSE;
}

static void
real_emit_ui_event (Bonobo_UIComponent component, const char *path,
		    int type, const char *new_state)
{
	if (component != CORBA_OBJECT_NIL) {
		CORBA_Environment ev;

		CORBA_exception_init (&ev);

		Bonobo_UIComponent_ui_event (
			component, path, type, new_state, &ev);

		if (ev._major != CORBA_NO_EXCEPTION) {
			/* FIXME: so if it is a sys exception do we de-merge ? */
			g_warning ("Exception emitting state change '%s' '%s'",
				   path, new_state);
		}
		
		CORBA_exception_free (&ev);
	} else
		g_warning ("NULL Corba handle at '%s'", path);
}

static gint
menu_toggle_emit_ui_event (GtkCheckMenuItem *item, xmlNode *node)
{
	BonoboUIXmlData *data;
	char            *path, *state;

	g_return_val_if_fail (node != NULL, FALSE);

	data = bonobo_ui_xml_get_data (NULL, node);
	g_return_val_if_fail (data != NULL, FALSE);

	path = bonobo_ui_xml_make_path (node);
	g_return_val_if_fail (path != NULL, FALSE);

	if (item->active)
		state = "1";
	else
		state = "0";

	real_emit_ui_event (data->id, path,
			    Bonobo_UIComponent_STATE_CHANGED,
			    state);

	g_free (path);

	return FALSE;
}

static gint
app_item_emit_ui_event (BonoboAppItem *item, const char *new_state, xmlNode *node)
{
	BonoboUIXmlData *data;
	char            *path;

	g_return_val_if_fail (node != NULL, FALSE);

	data = bonobo_ui_xml_get_data (NULL, node);
	g_return_val_if_fail (data != NULL, FALSE);

	path = bonobo_ui_xml_make_path (node);
	g_return_val_if_fail (path != NULL, FALSE);
	g_return_val_if_fail (new_state != NULL, FALSE);

	real_emit_ui_event (data->id, path,
			    Bonobo_UIComponent_STATE_CHANGED,
			    new_state);
	g_free (path);

	return FALSE;
}

/*
 * see menu_toplevel_item_create_widget.
 */
static void
build_menu_widget (BonoboAppPrivate *priv, xmlNode *node)
{
	NodeInfo  *info;
	GtkWidget *parent, *menu_widget;
	char      *label_text, *verb, *sensitive, *type;

	g_return_if_fail (priv != NULL);
	g_return_if_fail (node != NULL);

	info = bonobo_ui_xml_get_data (priv->tree, node);

	parent = node_get_widget (priv->tree, node->parent);

	/* Create menu item */
	if ((type = xmlGetProp (node, "type"))) {
		char *state = xmlGetProp (node, "state");
		
		if (!strcmp (type, "radio")) {
			char *group = xmlGetProp (node, "group");

			menu_widget = gtk_radio_menu_item_new (NULL);

			if (group)
				radio_group_add (
					priv,
					GTK_RADIO_MENU_ITEM (menu_widget),
					group);

		} else if (!strcmp (type, "toggle"))
			menu_widget = gtk_check_menu_item_new ();

		else {
			g_warning ("Unhandled type of menu '%s'", type);
			return;
		}
			
		gtk_check_menu_item_set_show_toggle (
			GTK_CHECK_MENU_ITEM (menu_widget), TRUE);

		gtk_check_menu_item_set_active (
			GTK_CHECK_MENU_ITEM (menu_widget), 
			state ? atoi (state) : FALSE);

		gtk_signal_connect (GTK_OBJECT (menu_widget), "toggled",
				    (GtkSignalFunc) menu_toggle_emit_ui_event,
				    node);
	} else {
		if (xmlGetProp (node, "pixtype")) {
			GtkWidget *pixmap;

			menu_widget = gtk_pixmap_menu_item_new ();

			pixmap = bonobo_ui_util_xml_get_pixmap (menu_widget, node);

			gtk_widget_show (GTK_WIDGET (pixmap));
			gtk_pixmap_menu_item_set_pixmap (GTK_PIXMAP_MENU_ITEM (menu_widget),
							 GTK_WIDGET (pixmap));
		} else
			menu_widget = gtk_menu_item_new ();
	}

	/*
	 * FIXME: (toplevel_create_item_widget)
	 *   Placeholder
	 */ 

	if ((label_text = xmlGetProp (node, "label"))) {
		GtkWidget *label;
		guint      keyval;

		label = gtk_accel_label_new (label_text);

		/*
		 * Setup the widget.
		 */
		gtk_misc_set_alignment (GTK_MISC (label), 0.0, 0.5);
		gtk_widget_show (label);
		
		/*
		 * Insert it into the menu item widget and setup the
		 * accelerator.
		 */
		gtk_container_add (GTK_CONTAINER (menu_widget), label);
		gtk_accel_label_set_accel_widget (
			GTK_ACCEL_LABEL (label), menu_widget);
	
		keyval = gtk_label_parse_uline (GTK_LABEL (label), label_text);

		if (keyval != GDK_VoidSymbol) {
			if (GTK_IS_MENU (parent))
				gtk_widget_add_accelerator (
					menu_widget, "activate_item",
					gtk_menu_ensure_uline_accel_group (
						GTK_MENU (parent)),
					keyval, 0, 0);

			else if (GTK_IS_MENU_BAR (parent) &&
				 priv->accel_group != NULL)
				gtk_widget_add_accelerator (
					menu_widget, "activate_item",
					priv->accel_group,
					keyval, GDK_MOD1_MASK, 0);
			else
				g_warning ("Adding accelerator went bananas");
		}
	}

	if (!strcmp (node->name, "submenu")) {
		xmlNode      *l;
		GtkMenuShell *shell;
		GtkMenu      *menu;
		GtkWidget    *tearoff;

		if (parent == NULL)
			shell = GTK_MENU_SHELL (priv->menu);
		else
			shell = GTK_MENU_SHELL (parent);

		/* Create the menu shell. */
		menu = GTK_MENU (gtk_menu_new ());

		gtk_menu_set_accel_group (menu, priv->accel_group);

		/*
		 * Create the tearoff item at the beginning of the menu shell,
		 * if appropriate.
		 */
		if (gnome_preferences_get_menus_have_tearoff ()) {
			tearoff = gtk_tearoff_menu_item_new ();
			gtk_widget_show (tearoff);
			gtk_menu_prepend (GTK_MENU (menu), tearoff);
		}

		/*
		 * Associate this menu shell with the menu item for
		 * this submenu.
		 */
		gtk_menu_item_set_submenu (GTK_MENU_ITEM (menu_widget),
					   GTK_WIDGET (menu));

		info->widget = GTK_WIDGET (menu);

		gtk_menu_shell_append (shell, menu_widget);
		
		for (l = node->childs; l; l = l->next)
			build_menu_widget (priv, l);

		gtk_widget_show (GTK_WIDGET (menu));
		gtk_widget_show (GTK_WIDGET (shell));

	} else if (!strcmp (node->name, "menuitem")) {
		g_return_if_fail (parent != NULL);

		gtk_menu_shell_append (GTK_MENU_SHELL (parent), menu_widget);
	} else if (!strcmp (node->name, "control")) {
		g_return_if_fail (info->object != CORBA_OBJECT_NIL);

		menu_widget = bonobo_app_item_new_control (info->object);
		g_return_if_fail (menu_widget != NULL);

		if ((sensitive = xmlGetProp (node, "sensitive")))
			gtk_widget_set_sensitive (menu_widget, atoi (sensitive));

		gtk_menu_shell_append (GTK_MENU_SHELL (parent), menu_widget);
	} else {
		g_warning ("FIXME: Unknown name type '%s'", node->name);
		return;
	}

	if ((sensitive = xmlGetProp (node, "sensitive")))
		gtk_widget_set_sensitive (menu_widget, atoi (sensitive));
	
	gtk_widget_show (menu_widget);
	
	if ((verb = xmlGetProp (node, "verb"))) {
		gtk_signal_connect (GTK_OBJECT (menu_widget), "activate",
				    (GtkSignalFunc) emit_verb, node);
	}
}

static void
update_menus (BonoboAppPrivate *priv, xmlNode *node)
{
	xmlNode  *l;
	NodeInfo *info = bonobo_ui_xml_get_data (priv->tree, node);

	if (info->widget)
		container_destroy_siblings (priv->tree, info->widget, node->childs);
	else
		info->widget = GTK_WIDGET (priv->menu);

	for (l = node->childs; l; l = l->next)
		build_menu_widget (priv, l);
}

/*
 * see menu_toplevel_item_create_widget.
 */
static void
build_toolbar_widget (BonoboAppPrivate *priv, xmlNode *node)
{
	NodeInfo   *info;
	GtkWidget  *parent;
	const char *type, *verb, *sensitive;
	GtkWidget  *pixmap;
	GtkWidget  *item;

	g_return_if_fail (priv != NULL);
	g_return_if_fail (node != NULL);

	info = bonobo_ui_xml_get_data (priv->tree, node);

	parent = node_get_widget (priv->tree, node->parent);

	/* Create toolbar item */
	if (xmlGetProp (node, "pixtype")) {
		pixmap = bonobo_ui_util_xml_get_pixmap (parent, node);

		gtk_widget_show (GTK_WIDGET (pixmap));
	} else
		pixmap = NULL;

	/*
	 * FIXME: (toplevel_create_item_widget)
	 *   Placeholder
	 */ 
	
	type = xmlGetProp (node, "type");
	if (!type || !strcmp (type, "std"))
		item = bonobo_app_item_new_item (
			xmlGetProp (node, "label"), pixmap);
	
	else if (!strcmp (type, "toggle"))
		item = bonobo_app_item_new_toggle (
			xmlGetProp (node, "label"), pixmap);
	
	else if (!strcmp (type, "separator"))
		item = bonobo_app_item_new_separator ();
	
	else {
		/* FIXME: Implement radio-toolbars */
		g_warning ("Invalid type '%s'", type);
		return;
	}
	
	bonobo_app_toolbar_add (BONOBO_APP_TOOLBAR (parent), item);

	bonobo_app_item_set_tooltip (
		BONOBO_APP_ITEM (item),
		bonobo_app_toolbar_get_tooltips (
			BONOBO_APP_TOOLBAR (parent)),
		xmlGetProp (node, "descr"));

	gtk_widget_show (GTK_WIDGET (item));

	if ((verb = xmlGetProp (node, "verb"))) {
		gtk_signal_connect (GTK_OBJECT (item), "activate",
				    (GtkSignalFunc) emit_verb, node);
	}

	gtk_signal_connect (GTK_OBJECT (item), "state_altered",
			    (GtkSignalFunc) app_item_emit_ui_event, node);

	if ((sensitive = xmlGetProp (node, "sensitive")))
		gtk_widget_set_sensitive (item, atoi (sensitive));
}

static void
update_dockitem (BonoboAppPrivate *priv, xmlNode *node)
{
	xmlNode       *l;
	NodeInfo      *info = bonobo_ui_xml_get_data (priv->tree, node);
	const char    *txt;
	guint          dummy;
	const char    *dockname = xmlGetProp (node, "name");
	GnomeDockItem *item;
	BonoboAppToolbar *toolbar;
	gboolean          tooltips;

	item = gnome_dock_get_item_by_name (priv->dock,
					    dockname,
					    &dummy, &dummy,
					    &dummy, &dummy);
	
	if (!item) {
		GnomeDockItemBehavior beh = GNOME_DOCK_ITEM_BEH_EXCLUSIVE;
		
		if (!gnome_preferences_get_toolbar_detachable())
			beh |= GNOME_DOCK_ITEM_BEH_LOCKED;

		item = GNOME_DOCK_ITEM (gnome_dock_item_new (
			dockname, beh));

		gnome_dock_add_item (priv->dock, item,
				     GNOME_DOCK_TOP,
				     1, 0, 0, TRUE);
		gtk_widget_show (GTK_WIDGET (item));
	} else
		gtk_widget_destroy (GTK_BIN (item)->child);

	toolbar = BONOBO_APP_TOOLBAR (bonobo_app_toolbar_new ());
	info->widget = GTK_WIDGET (toolbar);

	gtk_container_add (GTK_CONTAINER (item),
			   info->widget);
	gtk_widget_show (info->widget);

	for (l = node->childs; l; l = l->next) {
		if (!strcmp (l->name, "toolitem"))
			build_toolbar_widget (priv, l);
	}

	if ((txt = xmlGetProp (node, "look"))) {
		if (!strcmp (txt, "both"))
			bonobo_app_toolbar_set_style (
				toolbar, GTK_TOOLBAR_BOTH);
		else
			bonobo_app_toolbar_set_style (
				toolbar, GTK_TOOLBAR_ICONS);
	}

	if ((txt = xmlGetProp (node, "relief"))) {

		if (!strcmp (txt, "normal"))
			bonobo_app_toolbar_set_relief (
				toolbar, GTK_RELIEF_NORMAL);

		else if (!strcmp (txt, "half"))
			bonobo_app_toolbar_set_relief (
				toolbar, GTK_RELIEF_HALF);
		else
			bonobo_app_toolbar_set_relief (
				toolbar, GTK_RELIEF_NONE);
	}

	tooltips = TRUE;
	if ((txt = xmlGetProp (node, "tips"))) {
		tooltips = atoi (txt);
	}
	
	bonobo_app_toolbar_set_tooltips (toolbar, tooltips);
}

typedef enum {
	UI_UPDATE_MENU,
	UI_UPDATE_STATUS,
	UI_UPDATE_DOCKITEM
} UIUpdateType;

static void
seek_dirty (BonoboAppPrivate *priv, xmlNode *node, UIUpdateType type)
{
	BonoboUIXmlData *info;

	info = bonobo_ui_xml_get_data (priv->tree, node);
	if (info->dirty) { /* Rebuild tree from here down */
		
		bonobo_ui_xml_set_dirty (priv->tree, node, FALSE);

		switch (type) {
		case UI_UPDATE_MENU:
			update_menus (priv, node);
			break;
		case UI_UPDATE_DOCKITEM:
			update_dockitem (priv, node);
			break;
		default:
			g_warning ("No status support yet");
			break;
		}
	} else {
		xmlNode *l;

		for (l = node->childs; l; l = l->next)
			seek_dirty (priv, l, type);
	}

/*	gtk_widget_show_all (GTK_WIDGET (priv->window));*/
}

static void
update_widgets (BonoboAppPrivate *priv)
{
	xmlNode *node;

	bonobo_ui_xml_dump (priv->tree, priv->tree->root, "Before update");

	for (node = priv->tree->root->childs; node; node = node->next) {
		if (!node->name)
			continue;

		if (!strcmp (node->name, "menu")) {
			seek_dirty (priv, node, UI_UPDATE_MENU);

		} else if (!strcmp (node->name, "status")) {
			seek_dirty (priv, node, UI_UPDATE_STATUS);

		} else if (!strcmp (node->name, "dockitem")) {
			seek_dirty (priv, node, UI_UPDATE_DOCKITEM);

		} /* else unknown */
	}
	bonobo_ui_xml_dump (priv->tree, priv->tree->root, "Updated widgets");
}

void
bonobo_app_set_contents (BonoboApp *app,
			 GtkWidget *contents)
{
	g_return_if_fail (app != NULL);
	g_return_if_fail (app->priv != NULL);
	g_return_if_fail (app->priv->dock != NULL);

	gnome_dock_set_client_area (app->priv->dock, contents);
}

GtkWidget *
bonobo_app_get_contents (BonoboApp *app)
{
	g_return_val_if_fail (app != NULL, NULL);
	g_return_val_if_fail (app->priv != NULL, NULL);
	g_return_val_if_fail (app->priv->dock != NULL, NULL);

	return gnome_dock_get_client_area (app->priv->dock);
}

static gboolean
radio_group_destroy (gpointer	key,
		     gpointer	value,
		     gpointer	user_data)
{
	g_free (key);
	g_slist_free (value);

	return TRUE;
}

static void
destroy_priv (BonoboAppPrivate *priv)
{
	gtk_widget_destroy (priv->window);
		
	gtk_object_unref (GTK_OBJECT (priv->tree));

	g_free (priv->name);
	g_free (priv->prefix);

	g_hash_table_foreach_remove (priv->radio_groups,
				     radio_group_destroy, NULL);
	g_hash_table_destroy (priv->radio_groups);

	g_free (priv);
}

static void
bonobo_app_destroy (GtkObject *object)
{
	BonoboApp *app = (BonoboApp *)object;
	
	if (app) {
		if (app->priv)
			destroy_priv (app->priv);
		app->priv = NULL;
	}
	GTK_OBJECT_CLASS (bonobo_app_parent_class)->destroy (object);
}

static void
impl_node_set (PortableServer_Servant   servant,
	       const CORBA_char        *path,
	       const CORBA_char        *xml,
	       const Bonobo_UIComponent listener,
	       CORBA_Environment       *ev)
{
	BonoboApp *app = bonobo_app_from_servant (servant);

	/* FIXME: malformed xml / returning errors */
	bonobo_app_xml_merge (app, path, xml, listener);
}

static CORBA_char *
impl_node_get (PortableServer_Servant servant,
	       const CORBA_char      *path,
	       const CORBA_boolean    nodeOnly,
	       CORBA_Environment     *ev)
{
	BonoboApp  *app = bonobo_app_from_servant (servant);
	xmlDoc     *doc;
	xmlChar    *mem = NULL;
	xmlNode    *children;
	int         size;
	CORBA_char *ret;

	doc = xmlNewDoc ("1.0");
	g_return_val_if_fail (
		doc != NULL,
		CORBA_string_dup ("<Error name=\"memory\"/>"));

	doc->root = bonobo_ui_xml_get_path (app->priv->tree, path);
	g_return_val_if_fail (
		doc != NULL,
		CORBA_string_dup ("<Error name=\"tree\"/>"));

	children = doc->root->childs;

	if (nodeOnly)
		doc->root->childs = NULL;

	xmlDocDumpMemory (doc, &mem, &size);

	if (nodeOnly)
		doc->root->childs = children;

	g_return_val_if_fail (
		mem != NULL,
		CORBA_string_dup ("<Error name=\"dump\"/>"));

	doc->root = NULL;
	xmlFreeDoc (doc);

	ret = CORBA_string_dup (mem);
	xmlFree (mem);

	return ret;
}

static void
impl_node_remove (PortableServer_Servant servant,
		  const CORBA_char      *path,
		  Bonobo_UIComponent     by_listener,
		  CORBA_Environment     *ev)
{
	BonoboApp *app = bonobo_app_from_servant (servant);

	bonobo_app_xml_rm (app, path, by_listener);
}

static CORBA_boolean
impl_node_exists (PortableServer_Servant servant,
		  const CORBA_char      *path,
		  CORBA_Environment     *ev)
{
	BonoboApp *app = bonobo_app_from_servant (servant);

	return bonobo_ui_xml_exists (app->priv->tree, path);
}

static void
impl_object_set (PortableServer_Servant servant,
		 const CORBA_char      *path,
		 const Bonobo_Unknown   control,
		 CORBA_Environment     *ev)
{
	BonoboApp *app = bonobo_app_from_servant (servant);
	xmlNode   *node;
	NodeInfo  *info;

	g_return_if_fail (app != NULL);
	g_return_if_fail (app->priv != NULL);

	node = bonobo_ui_xml_get_path (app->priv->tree, path);
	g_return_if_fail (node != NULL);

	info = bonobo_ui_xml_get_data (app->priv->tree, node);

	if (info->object)
		bonobo_object_release_unref (info->object, ev);

	info->object = bonobo_object_dup_ref (control, ev);
}

static Bonobo_Unknown
impl_object_get (PortableServer_Servant servant,
		 const CORBA_char      *path,
		 CORBA_Environment     *ev)
{
	BonoboApp *app = bonobo_app_from_servant (servant);
	xmlNode   *node;
	NodeInfo  *info;

	g_return_val_if_fail (app != NULL, CORBA_OBJECT_NIL);
	g_return_val_if_fail (app->priv != NULL, CORBA_OBJECT_NIL);

	node = bonobo_ui_xml_get_path (app->priv->tree, path);
	g_return_val_if_fail (node != NULL, CORBA_OBJECT_NIL);

	info = bonobo_ui_xml_get_data (app->priv->tree, node);

	return bonobo_object_dup_ref (info->object, ev);
}

/**
 * bonobo_app_get_epv:
 */
POA_Bonobo_UIContainer__epv *
bonobo_app_get_epv (void)
{
	POA_Bonobo_UIContainer__epv *epv;

	epv = g_new0 (POA_Bonobo_UIContainer__epv, 1);

	epv->node_set    = impl_node_set;
	epv->node_get    = impl_node_get;
	epv->node_remove = impl_node_remove;
	epv->node_exists = impl_node_exists;

	epv->object_set  = impl_object_set;
	epv->object_get  = impl_object_get;

	return epv;
}

static void
bonobo_app_corba_class_init ()
{
	bonobo_app_vepv.Bonobo_Unknown_epv = bonobo_object_get_epv ();
	bonobo_app_vepv.Bonobo_UIContainer_epv = bonobo_app_get_epv ();
}

static void
bonobo_app_class_init (BonoboAppClass *klass)
{
	GtkObjectClass *object_class = (GtkObjectClass *) klass;

	bonobo_app_parent_class =
		gtk_type_class (bonobo_object_get_type ());

	object_class->destroy = bonobo_app_destroy;

	bonobo_app_corba_class_init ();
}

static BonoboAppPrivate *
construct_priv (const char *app_name,
		const char *title)
{
	BonoboAppPrivate *priv;
	GnomeDockItemBehavior behavior;

	priv = g_new0 (BonoboAppPrivate, 1);

	priv->name   = g_strdup (app_name);
	priv->prefix = g_strconcat ("/", app_name, "/", NULL);

	priv->window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
	if (title)
		gtk_window_set_title (GTK_WINDOW (priv->window), title);

	priv->dock   = GNOME_DOCK (gnome_dock_new ());
	gtk_container_add (GTK_CONTAINER (priv->window),
			   GTK_WIDGET    (priv->dock));

	behavior = (GNOME_DOCK_ITEM_BEH_EXCLUSIVE
		    | GNOME_DOCK_ITEM_BEH_NEVER_VERTICAL);
	if (!gnome_preferences_get_menubar_detachable ())
		behavior |= GNOME_DOCK_ITEM_BEH_LOCKED;

	priv->menu_item = GNOME_DOCK_ITEM (gnome_dock_item_new (
		"menu", behavior));
	priv->menu      = GTK_MENU_BAR (gtk_menu_bar_new ());
	gtk_container_add (GTK_CONTAINER (priv->menu_item),
			   GTK_WIDGET    (priv->menu));
	gnome_dock_add_item (priv->dock, priv->menu_item,
			     GNOME_DOCK_TOP, 0, 0, 0, TRUE);

	priv->status_item = GNOME_DOCK_ITEM (gnome_dock_item_new (
		"status",
		(GNOME_DOCK_ITEM_BEH_NEVER_VERTICAL |
		 GNOME_DOCK_ITEM_BEH_LOCKED)));
	priv->status      = GTK_BOX (gtk_hbox_new (FALSE, 0));
	gtk_container_add (GTK_CONTAINER (priv->status_item),
			   GTK_WIDGET    (priv->status));
	gnome_dock_add_item (priv->dock, priv->status_item,
			     GNOME_DOCK_BOTTOM, 0, 0, 0, TRUE);

	gtk_widget_show_all (GTK_WIDGET (priv->window));

	priv->tree = bonobo_ui_xml_new (info_compare_fn,
					info_new_fn,
					info_free_fn,
					info_override_fn,
					info_reinstate_fn,
					info_dump_fn);

	gtk_signal_connect (GTK_OBJECT (priv->tree), "override",
			    (GtkSignalFunc) override_fn, NULL);

	gtk_signal_connect (GTK_OBJECT (priv->tree), "reinstate",
			    (GtkSignalFunc) reinstate_fn, NULL);

	priv->accel_group = gtk_accel_group_new ();
	gtk_window_add_accel_group (GTK_WINDOW (priv->window),
				    priv->accel_group);

	gtk_widget_show_all (GTK_WIDGET (priv->dock));

	priv->radio_groups = g_hash_table_new (
		g_str_hash, g_str_equal);

	return priv;
}

/**
 * bonobo_app_get_type:
 *
 * Returns: The GtkType for the BonoboApp class.
 */
GtkType
bonobo_app_get_type (void)
{
	static GtkType type = 0;

	if (!type) {
		GtkTypeInfo info = {
			"BonoboApp",
			sizeof (BonoboApp),
			sizeof (BonoboAppClass),
			(GtkClassInitFunc) bonobo_app_class_init,
			(GtkObjectInitFunc) NULL,
			NULL, /* reserved 1 */
			NULL, /* reserved 2 */
			(GtkClassInitFunc) NULL
		};

		type = gtk_type_unique (bonobo_object_get_type (), &info);
	}

	return type;
}

/**
 * bonobo_app_corba_object_create:
 * @object: The GtkObject that will wrap the CORBA object.
 *
 * Creates an activates the CORBA object that is wrapped
 * by the BonoboObject @object.
 *
 * Returns: An activated object reference to the created object or
 * %CORBA_OBJECT_NIL in case of failure.
 */
Bonobo_UIContainer
bonobo_app_corba_object_create (BonoboObject *object)
{
	POA_Bonobo_UIContainer *servant;
	CORBA_Environment ev;
	
	servant = (POA_Bonobo_UIContainer *)g_new0 (BonoboObjectServant, 1);
	servant->vepv = &bonobo_app_vepv;

	CORBA_exception_init (&ev);

	POA_Bonobo_UIContainer__init ((PortableServer_Servant) servant, &ev);
	if (ev._major != CORBA_NO_EXCEPTION){
		g_free (servant);
		CORBA_exception_free (&ev);
		return CORBA_OBJECT_NIL;
	}
	CORBA_exception_free (&ev);

	return bonobo_object_activate_servant (object, servant);
}

BonoboApp *
bonobo_app_construct (BonoboApp  *app,
		      Bonobo_UIContainer  corba_app,
		      const char *app_name,
		      const char *title)
{
	g_return_val_if_fail (app != NULL, NULL);
	g_return_val_if_fail (app_name != NULL, NULL);
	g_return_val_if_fail (BONOBO_IS_APP (app), NULL);
	g_return_val_if_fail (corba_app != CORBA_OBJECT_NIL, NULL);

	bonobo_object_construct (BONOBO_OBJECT (app), corba_app);
	
	app->priv = construct_priv (app_name, title);

	return app;
}

BonoboApp *
bonobo_app_new (const char   *app_name,
		const char   *title)
{
	Bonobo_UIContainer corba_app;
	BonoboApp *app;

	app = gtk_type_new (BONOBO_APP_TYPE);

	corba_app = bonobo_app_corba_object_create (BONOBO_OBJECT (app));
	if (corba_app == CORBA_OBJECT_NIL) {
		bonobo_object_unref (BONOBO_OBJECT (app));
		return NULL;
	}
	
	return bonobo_app_construct (app, corba_app, app_name, title);
}

void
bonobo_app_xml_merge_tree (BonoboApp  *app,
			   const char *path,
			   xmlNode    *tree,
			   gpointer    listener)
{
	g_return_if_fail (app != NULL);
	g_return_if_fail (app->priv != NULL);
	g_return_if_fail (app->priv->tree != NULL);

	bonobo_ui_xml_merge (app->priv->tree, path, tree, listener);
	update_widgets (app->priv);
}

void
bonobo_app_xml_merge (BonoboApp  *app,
		      const char *path,
		      const char *xml,
		      gpointer    listener)
{
	xmlDoc  *doc;

	g_return_if_fail (app != NULL);
	g_return_if_fail (xml != NULL);
	g_return_if_fail (app->priv != NULL);
	g_return_if_fail (app->priv->tree != NULL);

	doc = xmlParseDoc ((char *)xml);

	bonobo_app_xml_merge_tree (app, path, doc->root, listener);
	doc->root = NULL;
	
	xmlFreeDoc (doc);
}

void
bonobo_app_xml_rm (BonoboApp  *app,
		   const char *path,
		   gpointer    by_listener)
{
	g_return_if_fail (app != NULL);
	g_return_if_fail (app->priv != NULL);
	g_return_if_fail (app->priv->tree != NULL);

	bonobo_ui_xml_rm (app->priv->tree, "/", by_listener);
	update_widgets (app->priv);
}
